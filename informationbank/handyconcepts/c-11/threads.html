<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" itemscope="" itemtype="../../../../../schema.org/WebPage.html">

<!-- Mirrored from sites.google.com/site/sridharkritha/handyconcepts/c-11/threads by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 09 Jul 2021 10:31:35 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta http-equiv="X-UA-Compatible" content="chrome=1" />
<script type="text/javascript">/* Copyright 2008 Google. */ (function() { /*

Copyright The Closure Library Authors.
SPDX-License-Identifier: Apache-2.0
*/
(function(){function e(g){this.t={};this.tick=function(h,k,f){this.t[h]=[void 0!=f?f:(new Date).getTime(),k];if(void 0==f)try{window.console.timeStamp("CSI/"+h)}catch(m){}};this.getStartTickTime=function(){return this.t.start[0]};this.tick("start",null,g)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var l=0<d?new e(d):new e;window.jstiming={Timer:e,load:l};if(a){var b=a.navigationStart;0<b&&d>=b&&(window.jstiming.srt=d-b)}if(a){var c=window.jstiming.load;0<b&&d>=
b&&(c.tick("_wtsrt",void 0,b),c.tick("wtsrt_","_wtsrt",d),c.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),c&&0<b&&(c.tick("_tbnd",void 0,window.chrome.csi().startE),c.tick("tbnd_","_tbnd",b))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,c&&0<b&&(c.tick("_tbnd",void 0,window.external.startE),c.tick("tbnd_","_tbnd",b))),a&&(window.jstiming.pt=a)}catch(g){}})(); })()
</script>
<link rel="shortcut icon" type="image/x-icon" href="../../../../../www.google.com/images/icons/product/sites-16.ico" />
<link rel="apple-touch-icon" href="../../../../../ssl.gstatic.com/sites/p/a71eef/system/app/images/apple-touch-icon.png" type="image/png" />
<script type="text/javascript">/* Copyright 2008 Google. */ (function() { function d(a){return document.getElementById(a)}window.byId=d;function g(a){return a.replace(/^\s+|\s+$/g,"")}window.trim=g;var h=[],k=0;window.JOT_addListener=function(a,b,c){var f=new String(k++);a={eventName:a,handler:b,compId:c,key:f};h.push(a);return f};window.JOT_removeListenerByKey=function(a){for(var b=0;b<h.length;b++)if(h[b].key==a){h.splice(b,1);break}};window.JOT_removeAllListenersForName=function(a){for(var b=0;b<h.length;b++)h[b].eventName==a&&h.splice(b,1)};
window.JOT_postEvent=function(a,b,c){var f={eventName:a,eventSrc:b||{},payload:c||{}};if(window.JOT_fullyLoaded)for(b=h.length,c=0;c<b&&c<h.length;c++){var e=h[c];e&&e.eventName==a&&(f.listenerCompId=e.compId||"",(e="function"==typeof e.handler?e.handler:window[e.handler])&&e(f))}else window.JOT_delayedEvents.push({eventName:a,eventSrc:b,payload:c})};window.JOT_delayedEvents=[];window.JOT_fullyLoaded=!1;
window.JOT_formatRelativeToNow=function(a,b){a=((new Date).getTime()-a)/6E4;if(1440<=a||0>a)return null;var c=0;60<=a&&(a/=60,c=2);2<=a&&c++;return b?window.JOT_siteRelTimeStrs[c].replace("__duration__",Math.floor(a)):window.JOT_userRelTimeStrs[c].replace("__duration__",Math.floor(a))}; })()
</script>
<script>

  

  var breadcrumbs = [{"path":"/site/sridharkritha/handyconcepts","deleted":false,"title":"handyconcepts","dir":"ltr"},{"path":"/site/sridharkritha/handyconcepts/c-11","deleted":false,"title":"C++ 11","dir":"ltr"},{"path":"/site/sridharkritha/handyconcepts/c-11/threads","deleted":false,"title":"threads","dir":"ltr"}];
  var JOT_clearDotPath = '../../../../../ssl.gstatic.com/sites/p/a71eef/system/app/images/cleardot.gif';

  
  var JOT_userRelTimeStrs = ["a minute ago","__duration__ minutes ago","an hour ago","__duration__ hours ago"];

  
  

  

  var webspace = {"gvizGstaticVersion":"current","enableAnalytics":false,"pageSharingId":"jotspot_page","codeembeds":{"outerIframeSrc":"https://www.gstatic.com/jotspot/embeds/code/0f08d42392f2000e7e3f3daf5b427a43/outer_iframe.html","innerIframeSrc":"https://507389089-jotspot-embeds.googleusercontent.com/code/8d87fa64604b2a11fae2ed06104c58d3/inner_iframe.html"},"enableUniversalAnalytics":false,"sharingPolicy":"OPENED","siteTitle":"sridharkritha","experiments":{"enableSubpagesGadgetInTakeout":true,"DisableSiteEditingFeature__disable_site_editing":true,"disableDomainEditing":false},"jot2atari":{"eligibility":"INELIGIBLE"},"onepickUrl":"https://docs.google.com/picker","adsensePublisherId":null,"features":{"moreMobileStyleImprovements":null,"subscriptionDataMigrationInProgress":null,"plusBadge":false},"configProperties":{"disableSiteEditing":null},"isPublic":true,"newSitesBaseUrl":"https://sites.google.com","isConsumer":true,"serverFlags":{"jot2AtariLearnMoreUrl":"https://support.google.com/sites/answer/7035197"},"domainAnalyticsAccountId":"","plusPageId":"","signInUrl":"https://accounts.google.com/AccountChooser?continue\u003dhttps://sites.google.com/site/sridharkritha/handyconcepts/c-11/threads\u0026service\u003djotspot","analyticsAccountId":"","scottyUrl":"/_/upload","homePath":"/","siteNoticeUrlEnabled":null,"plusPageUrl":"","adsensePromoClickedOrSiteIneligible":true,"csiReportUri":"https://gg.google.com/csi","sharingId":"jotspot","termsUrl":"//www.google.com/intl/en/policies/terms/","gvizVersion":1,"editorResources":{"sitelayout":["https://ssl.gstatic.com/sites/p/a71eef/system/app/css/sitelayouteditor.css"],"text":["https://ssl.gstatic.com/sites/p/a71eef/system/js/codemirror.js","../../../../../ssl.gstatic.com/sites/p/a71eef/system/app/css/codemirror_css.css","../../../../../ssl.gstatic.com/sites/p/a71eef/system/js/trog_edit__en.js","../../../../../ssl.gstatic.com/sites/p/a71eef/system/app/css/trogedit.css","../../_/rsrc/1624520311000/system/app/css/editor.css","../../../../../ssl.gstatic.com/sites/p/a71eef/system/app/css/codeeditor.css","/site/sridharkritha/_/rsrc/1624520311000/system/app/css/camelot/editor-jfk.css"]},"sharingUrlPrefix":"/_/sharing","isAdsenseEnabled":true,"domain":"defaultdomain","baseUri":"/site/sridharkritha","name":"sridharkritha","siteTemplateId":false,"siteNoticeRevision":null,"siteNoticeUrlAddress":null,"siteNoticeMessage":null,"page":{"isRtlLocale":false,"canDeleteWebspace":null,"isPageDraft":null,"parentPath":"/handyconcepts/c-11","parentWuid":"wuid:gx:62048820bd9fddf3","siteLocale":"en","timeZone":"America/Los_Angeles","type":"text","title":"threads","locale":"en","wuid":"wuid:gx:c5642b8744cce00","revision":36,"path":"/handyconcepts/c-11/threads","isSiteRtlLocale":false,"pageInheritsPermissions":null,"name":"threads","canChangePath":true,"state":"","properties":{},"bidiEnabled":false,"currentTemplate":{"path":"/system/app/pagetemplates/text","title":"Web Page"}},"canPublishScriptToAnyone":true,"user":{"keyboardShortcuts":true,"sessionIndex":"","guest_":true,"displayNameOrEmail":"guest","userName":"guest","uid":"","renderMobile":false,"domain":"","namespace":"","hasWriteAccess":false,"namespaceUser":false,"primaryEmail":"guest","hasAdminAccess":false},"gadgets":{"baseUri":"/site/sridharkritha/system/app/pages/gadgets"}};
  webspace.page.breadcrumbs = breadcrumbs;

  
  var JOT_siteRelTimeStrs = ["a minute ago","__duration__ minutes ago","an hour ago","__duration__ hours ago"];

</script>
<script type="text/javascript">
                window.jstiming.load.tick('scl');
              </script>
<meta name="title" content="threads - sridharkritha" />
<meta itemprop="name" content="threads - sridharkritha" />
<meta property="og:title" content="threads - sridharkritha" />
<meta name="description" content="Information Bank - Computer Science" />
<meta itemprop="description" content="Information Bank - Computer Science" />
<meta id="meta-tag-description" property="og:description" content="Information Bank - Computer Science" />
<style type="text/css">
</style>
<link rel="stylesheet" type="text/css" href="../../../../../ssl.gstatic.com/sites/p/a71eef/system/app/themes/ember/standard-css-ember-ltr-ltr.css" />
<link rel="stylesheet" type="text/css" href="../../_/rsrc/1624520311000/system/app/css/overlaydd2a.css?cb=ember150goog-ws-noside" />
<link rel="stylesheet" type="text/css" href="../../_/rsrc/1624520311000/system/app/css/camelot/allthemes-view.css" />
<!--[if IE]>
          <link rel="stylesheet" type="text/css" href="/site/sridharkritha/system/app/css/camelot/allthemes%2die.css" />
        <![endif]-->
<title>threads - sridharkritha</title>
<script type="text/javascript">
                window.jstiming.load.tick('cl');
              </script>
</head>
<body xmlns="http://www.google.com/ns/jotspot" id="body" class=" en            ">
<div id="sites-page-toolbar" class="sites-header-divider">
<div xmlns="http://www.w3.org/1999/xhtml" id="sites-status" class="sites-status" style="display:none;"><div id="sites-notice" class="sites-notice" role="status" aria-live="assertive"> </div></div>
</div>
<div id="sites-chrome-everything-scrollbar">
<div id="sites-chrome-everything" class="">
<div id="sites-chrome-page-wrapper" style="direction: ltr">
<div id="sites-chrome-page-wrapper-inside">
<div xmlns="http://www.w3.org/1999/xhtml" id="sites-chrome-header-wrapper" style="">
<table id="sites-chrome-header" class="sites-layout-hbox" cellspacing="0" style="">
<tr class="sites-header-primary-row" id="sites-chrome-userheader">
<td id="sites-header-title" class="" role="banner"><div class="sites-header-cell-buffer-wrapper"><h2></h2></div></td><td class="sites-layout-searchbox  "></td>
</tr>
<tr class="sites-header-secondary-row" id="sites-chrome-horizontal-nav">
<td colspan="2" id="sites-chrome-header-horizontal-nav-container" role="navigation">
</td>
</tr>
</table>
</div>
<div id="sites-chrome-main-wrapper">
<div id="sites-chrome-main-wrapper-inside">
<table id="sites-chrome-main" class="sites-layout-hbox" cellspacing="0" cellpadding="{scmCellpadding}" border="0">
<tr>
<td id="sites-chrome-sidebar-left" class="sites-layout-sidebar-left" style="display: none; width: 150px">
</td>
<td id="sites-canvas-wrapper">
<div id="sites-canvas" role="main">
<div id="goog-ws-editor-toolbar-container"> </div>
<div xmlns="http://www.w3.org/1999/xhtml" id="title-crumbs" style="">
<A href="../../handyconcepts.html" dir="ltr">handyconcepts</A>‎ &gt; ‎<A href="../c-11.html" dir="ltr">C++ 11</A>‎ &gt; ‎
  </div>
<h3 xmlns="http://www.w3.org/1999/xhtml" id="sites-page-title-header" style="" align="left">
<span id="sites-page-title" dir="ltr" tabindex="-1" style="outline: none">threads</span>
</h3>
<div id="sites-canvas-main" class="sites-canvas-main">
<div id="sites-canvas-main-content">
<div xmlns="http://www.w3.org/1999/xhtml" class="sites-layout-name-left-sidebar-hf sites-layout-vbox"><div class="sites-layout-tile sites-tile-name-header sites-layout-empty-tile"><div dir="ltr"><br /></div></div><table cellspacing="0" class="sites-layout-hbox"><tbody><tr><td class="sites-layout-tile sites-tile-name-content-1 sites-canvas-sidebar sites-layout-empty-tile"><div dir="ltr"><br /></div></td><td class="sites-layout-tile sites-tile-name-content-2"><div dir="ltr"><div><b>Summary:</b></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div>    <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">funValStrParam</span>(<span style="color:#4ec9b0">string</span> <span style="color:#9cdcfe">s</span>) { <span style="color:#4ec9b0">std</span>::cout &lt;&lt; s &lt;&lt; <span style="color:#4ec9b0">std</span>::endl; }<span style="color:#6a9955">  // std::move even without &amp;&amp;</span></div><div>    <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">funRefStrParam</span>(<span style="color:#4ec9b0">string</span><span style="color:#569cd6">&amp;</span> <span style="color:#9cdcfe">s</span>) { <span style="color:#4ec9b0">std</span>::cout &lt;&lt; s &lt;&lt; <span style="color:#4ec9b0">std</span>::endl; }<span style="color:#6a9955"> // std::move even without &amp;&amp;</span></div><br /><div>    <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">funValParam</span>(<span style="color:#569cd6">int</span> <span style="color:#9cdcfe">v</span>) { <span style="color:#4ec9b0">std</span>::cout &lt;&lt; v &lt;&lt; <span style="color:#4ec9b0">std</span>::endl; }</div><div>    <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">funRefParam</span>(<span style="color:#569cd6">int&amp;</span> <span style="color:#9cdcfe">r</span>) { <span style="color:#4ec9b0">std</span>::cout &lt;&lt; r &lt;&lt; <span style="color:#4ec9b0">std</span>::endl; }<span style="color:#6a9955">     // std::ref</span></div><div>    <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">funRefRefParam</span>(<span style="color:#569cd6">int&amp;&amp;</span> <span style="color:#9cdcfe">r</span>) { <span style="color:#4ec9b0">std</span>::cout &lt;&lt; r &lt;&lt; <span style="color:#4ec9b0">std</span>::endl; }<span style="color:#6a9955"> // std::move</span></div><div>    <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">funPtrParam</span>(<span style="color:#569cd6">int*</span> <span style="color:#9cdcfe">p</span>) { <span style="color:#4ec9b0">std</span>::cout &lt;&lt; *p &lt;&lt; <span style="color:#4ec9b0">std</span>::endl; }</div><br /><div>    <span style="color:#569cd6">struct</span> <span style="color:#4ec9b0">Fctor</span> {</div><div>        <span style="color:#569cd6">void</span> <span style="color:#c586c0">operator()</span>(<span style="color:#4ec9b0">string</span><span style="color:#569cd6">&amp;</span> <span style="color:#9cdcfe">r</span>) { <span style="color:#4ec9b0">std</span>::cout &lt;&lt; r &lt;&lt; <span style="color:#4ec9b0">std</span>::endl; }</div><div>    };</div><br /><div>    <span style="color:#569cd6">struct</span> <span style="color:#4ec9b0">Base</span> {</div><div>        <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">memFunRefParam</span>(<span style="color:#569cd6">int&amp;</span> <span style="color:#9cdcfe">r</span>) { <span style="color:#4ec9b0">std</span>::cout &lt;&lt; <span style="color:#9cdcfe">r</span> &lt;&lt; <span style="color:#4ec9b0">std</span>::endl; }</div><div>        <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">memFunPtrParam</span>(<span style="color:#569cd6">int*</span> <span style="color:#9cdcfe">p</span>) { <span style="color:#4ec9b0">std</span>::cout &lt;&lt; *<span style="color:#9cdcfe">p</span> &lt;&lt; <span style="color:#4ec9b0">std</span>::endl; }</div><div>    };</div><br /><div>    <span style="color:#569cd6">int</span> <span style="color:#dcdcaa">main</span>() {</div><div>        <span style="color:#569cd6">int</span> <span style="color:#9cdcfe">n</span> = <span style="color:#b5cea8">5</span>;</div><div>        <span style="color:#569cd6">int</span>* <span style="color:#9cdcfe">ip</span> = <span style="color:#c586c0">new</span> <span style="color:#569cd6">int</span>{ <span style="color:#b5cea8">7</span> };</div><div>        <span style="color:#4ec9b0">string</span> <span style="color:#9cdcfe">str</span> = <span style="color:#ce9178">"sridhar"</span>;</div><div>        <span style="color:#4ec9b0">string</span>* <span style="color:#9cdcfe">strPtr</span> = <span style="color:#c586c0">new</span> <span style="color:#4ec9b0">string</span>(<span style="color:#ce9178">"krishnan"</span>);</div><br /><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">thread</span> <span style="color:#9cdcfe">t1</span>(funValParam, <span style="color:#9cdcfe">n</span>); </div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">thread</span> <span style="color:#9cdcfe">t2</span>(funValParam, <span style="color:#4ec9b0">std</span>::<span style="color:#dcdcaa">ref</span>(<span style="color:#9cdcfe">n</span>));<span style="color:#6a9955">  // OK - even if you pass by std::ref(n) for val param callee</span></div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">thread</span> <span style="color:#9cdcfe">t3</span>(funValParam, <span style="color:#4ec9b0">std</span>::<span style="color:#dcdcaa">move</span>(<span style="color:#9cdcfe">n</span>));<span style="color:#6a9955"> // OK - 'n' ownership has moved</span></div><div>        cout &lt;&lt; <span style="color:#9cdcfe">n</span>;<span style="color:#6a9955"> // 5 - BAD - Do NOT access 'n' after moved. </span></div><br /><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">thread</span> <span style="color:#9cdcfe">t4</span>(funValParam, *<span style="color:#9cdcfe">ip</span>);<span style="color:#6a9955">            // OK</span></div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">thread</span> <span style="color:#9cdcfe">t5</span>(funValParam, <span style="color:#4ec9b0">std</span>::<span style="color:#dcdcaa">ref</span>(*<span style="color:#9cdcfe">ip</span>));<span style="color:#6a9955">  // OK</span></div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">thread</span> <span style="color:#9cdcfe">t6</span>(funValParam, <span style="color:#4ec9b0">std</span>::<span style="color:#dcdcaa">move</span>(*<span style="color:#9cdcfe">ip</span>));<span style="color:#6a9955"> // OK</span></div><div>        cout &lt;&lt; *<span style="color:#9cdcfe">ip</span>;<span style="color:#6a9955"> // 7 - BAD - Do NOT access 'n' after moved. </span></div><br /><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">thread</span> <span style="color:#9cdcfe">t7</span>(funValStrParam, <span style="color:#4ec9b0">std</span>::<span style="color:#dcdcaa">move</span>(<span style="color:#9cdcfe">str</span>));<span style="color:#6a9955"> // OK</span></div><br /><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">thread</span> <span style="color:#9cdcfe">t7</span>(funRefStrParam, <span style="color:#4ec9b0">std</span>::<span style="color:#dcdcaa">ref</span>(<span style="color:#9cdcfe">str</span>));<span style="color:#6a9955">      // OK</span></div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">thread</span> <span style="color:#9cdcfe">t7</span>(funRefStrParam, <span style="color:#4ec9b0">std</span>::<span style="color:#dcdcaa">move</span>(<span style="color:#9cdcfe">str</span>));<span style="color:#6a9955">     // Error</span></div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">thread</span> <span style="color:#9cdcfe">t7</span>(funRefStrParam, <span style="color:#4ec9b0">std</span>::<span style="color:#dcdcaa">move</span>(*<span style="color:#9cdcfe">strPtr</span>));<span style="color:#6a9955"> // OK</span></div><div>        cout &lt;&lt; <span style="color:#9cdcfe">str</span>;<span style="color:#6a9955"> // Prints NOTHING if it is string</span></div><br /><div><span style="color:#6a9955">        // ref - &amp;</span></div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">thread</span> <span style="color:#9cdcfe">t8</span>(funRefParam, <span style="color:#9cdcfe">n</span>);<span style="color:#6a9955">  // Error: n MUST be passed by std::ref(n)</span></div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">thread</span> <span style="color:#9cdcfe">t9</span>(funRefParam, &amp;<span style="color:#9cdcfe">n</span>);<span style="color:#6a9955"> // Error: NOT &amp;n MUST be passed by std::ref(n)</span></div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">thread</span> <span style="color:#9cdcfe">t10</span>(funRefParam, <span style="color:#4ec9b0">std</span>::<span style="color:#dcdcaa">ref</span>(<span style="color:#9cdcfe">n</span>));<span style="color:#6a9955"> // OK</span></div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">thread</span> <span style="color:#9cdcfe">t11</span>(funRefParam, <span style="color:#4ec9b0">std</span>::<span style="color:#dcdcaa">move</span>(<span style="color:#9cdcfe">n</span>));<span style="color:#6a9955"> // Error: n MUST be passed by std::ref(n)</span></div><br /><div><span style="color:#6a9955">        // move - &amp;&amp;</span></div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">thread</span> <span style="color:#9cdcfe">t12</span>(funRefRefParam, <span style="color:#4ec9b0">std</span>::<span style="color:#dcdcaa">ref</span>(<span style="color:#9cdcfe">n</span>));<span style="color:#6a9955">  // Error bcos of &amp;&amp;</span></div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">thread</span> <span style="color:#9cdcfe">t13</span>(funRefRefParam, <span style="color:#4ec9b0">std</span>::<span style="color:#dcdcaa">move</span>(<span style="color:#9cdcfe">n</span>));<span style="color:#6a9955"> // OK</span></div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">thread</span> <span style="color:#9cdcfe">t14</span>(funRefRefParam, <span style="color:#9cdcfe">n</span>);<span style="color:#6a9955">  // OK</span></div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">thread</span> <span style="color:#9cdcfe">t15</span>(funRefRefParam, &amp;<span style="color:#9cdcfe">n</span>);<span style="color:#6a9955"> // Error bcos of &amp;&amp;</span></div><div>        cout &lt;&lt; <span style="color:#9cdcfe">n</span>;</div><br /><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">thread</span> <span style="color:#9cdcfe">t16</span>(funPtrParam, &amp;<span style="color:#9cdcfe">n</span>);<span style="color:#6a9955"> // OK for pointer param callee</span></div><br /><div>        Fctor <span style="color:#9cdcfe">obj</span>;<span style="color:#6a9955"> // obj is a callable object</span></div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">thread</span> <span style="color:#9cdcfe">t17</span>(<span style="color:#9cdcfe">obj</span>, <span style="color:#4ec9b0">std</span>::<span style="color:#dcdcaa">ref</span>(<span style="color:#9cdcfe">str</span>));<span style="color:#6a9955"> // OK. (&amp;obj - NOT allowed in callable object)</span></div><br /><div>        <span style="color:#4ec9b0">Base</span> <span style="color:#9cdcfe">b</span>;</div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">thread</span> <span style="color:#9cdcfe">t18</span>(&amp;<span style="color:#4ec9b0">Base</span>::<span style="color:#dcdcaa">memFunRefParam</span>, <span style="color:#9cdcfe">b</span>, <span style="color:#4ec9b0">std</span>::<span style="color:#dcdcaa">ref</span>(<span style="color:#9cdcfe">n</span>));<span style="color:#6a9955">  // copy of b</span></div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">thread</span> <span style="color:#9cdcfe">t19</span>(&amp;<span style="color:#4ec9b0">Base</span>::<span style="color:#dcdcaa">memFunRefParam</span>, &amp;<span style="color:#9cdcfe">b</span>, <span style="color:#4ec9b0">std</span>::<span style="color:#dcdcaa">ref</span>(<span style="color:#9cdcfe">n</span>));<span style="color:#6a9955"> // original b</span></div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">thread</span> <span style="color:#9cdcfe">t20</span>(&amp;<span style="color:#4ec9b0">Base</span>::<span style="color:#dcdcaa">memFunPtrParam</span>, &amp;<span style="color:#9cdcfe">b</span>, &amp;<span style="color:#9cdcfe">n</span>);<span style="color:#6a9955"> // original b, ptr param callee so NO need for std::ref(n)</span></div><br /><div>        <span style="color:#9cdcfe">t1</span>.<span style="color:#dcdcaa">join</span>(); <span style="color:#9cdcfe">t2</span>.<span style="color:#dcdcaa">join</span>(); <span style="color:#9cdcfe">t3</span>.<span style="color:#dcdcaa">join</span>(); <span style="color:#9cdcfe">t4</span>.<span style="color:#dcdcaa">join</span>(); <span style="color:#9cdcfe">t5</span>.<span style="color:#dcdcaa">join</span>(); <span style="color:#9cdcfe">t6</span>.<span style="color:#dcdcaa">join</span>(); <span style="color:#9cdcfe">t7</span>.<span style="color:#dcdcaa">join</span>(); <span style="color:#9cdcfe">t8</span>.<span style="color:#dcdcaa">join</span>(); <span style="color:#9cdcfe">t9</span>.<span style="color:#dcdcaa">join</span>(); <span style="color:#9cdcfe">t10</span>.<span style="color:#dcdcaa">join</span>();</div><div>        <span style="color:#9cdcfe">t11</span>.<span style="color:#dcdcaa">join</span>();<span style="color:#9cdcfe">t12</span>.<span style="color:#dcdcaa">join</span>();<span style="color:#9cdcfe">t13</span>.<span style="color:#dcdcaa">join</span>();<span style="color:#9cdcfe">t14</span>.<span style="color:#dcdcaa">join</span>();<span style="color:#9cdcfe">t15</span>.<span style="color:#dcdcaa">join</span>();<span style="color:#9cdcfe">t16</span>.<span style="color:#dcdcaa">join</span>();<span style="color:#9cdcfe">t17</span>.<span style="color:#dcdcaa">join</span>();<span style="color:#9cdcfe">t18</span>.<span style="color:#dcdcaa">join</span>();<span style="color:#9cdcfe">t19</span>.<span style="color:#dcdcaa">join</span>();<span style="color:#9cdcfe">t20</span>.<span style="color:#dcdcaa">join</span>();</div><div>    }</div></div></div><div><br /></div><div><b>thread function with reference parameter: </b><span style="background-color:transparent">The arguments to the thread function are <b>moved </b>or <b>copied </b>by value. </span><span style="background-color:transparent;font-size:10pt">If a reference argument needs to be passed to the thread function, it has to be wrapped (e.g. with <b>std::ref</b> or <b>std::cref</b>).</span></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div>    <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">run</span>(<span style="color:#569cd6">int&amp;</span> <span style="color:#9cdcfe">a</span>)<span style="color:#6a9955"> // reference</span></div><div>    {</div><div>        cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; <span style="color:#ce9178">":"</span> &lt;&lt; a &lt;&lt; endl;<span style="color:#6a9955"> // void run(int&amp;):6</span></div><div>    }</div><br /><div>    <span style="color:#569cd6">int</span> <span style="color:#dcdcaa">main</span>()</div><div>    {</div><div>        <span style="color:#569cd6">int</span> a = <span style="color:#b5cea8">6</span>;</div><div><span style="color:#6a9955">        // auto t = std::thread(run, a)); // Error - Needs std::ref(a)</span></div><div>        <span style="color:#569cd6">auto</span> t = <span style="color:#4ec9b0">std</span>::<span style="color:#dcdcaa">thread</span>(run, <span style="color:#4ec9b0">std</span>::<span style="color:#dcdcaa">ref</span>(a));</div><div>        <span style="color:#9cdcfe">t</span>.<span style="color:#dcdcaa">join</span>();</div><div>    }</div></div></div><div><br /></div><div><div><span style="font-size:13.3333px"><b>std::move(): </b>Does not move, it casts (using static_cast) its argument into an <b>r-value reference.</b></span></div><div>std::move can be used whenever we want to treat an l-value like an r-value for the purpose of invoking move semantics instead of copy semantics.</div><div><span style="font-size:13.3333px">std::move is defined in the <b>&lt;utility&gt;</b> header.</span></div></div><div><br /></div><div><b style="background-color:transparent;font-size:10pt">30. Threads Basic :</b></div><div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div style="line-height:22px"><div><span style="color:#6a9955">    // Ref: C++ Threading #1: Introduction</span></div><div><span style="color:#6a9955">    // https://www.youtube.com/watch?v=LL8wkskDlbs&amp;list=PL5jc9xFGsL8E12so1wlMS0r0hTQoJL74M&amp;index=2&amp;t=411s</span></div><div><span style="color:#569cd6">    </span><span style="color:#c586c0">#include</span><span style="color:#569cd6"> </span><span style="color:#ce9178">&lt;iostream&gt;</span></div><div><span style="color:#569cd6">    </span><span style="color:#c586c0">#include</span><span style="color:#569cd6"> </span><span style="color:#ce9178">&lt;thread&gt;</span></div><div>    <span style="color:#c586c0">using</span> <span style="color:#569cd6">namespace</span> <span style="color:#4ec9b0">std</span>;</div><br /><div>    <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">function_1</span>() {</div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#9cdcfe">cout</span> &lt;&lt; <span style="color:#ce9178">"Hello, World"</span> &lt;&lt; <span style="color:#4ec9b0">std</span>::<span style="color:#dcdcaa">endl</span>;</div><div>    }</div><br /><div>    <span style="color:#569cd6">int</span> <span style="color:#dcdcaa">main</span>() {</div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">thread</span> <span style="color:#9cdcfe">t1</span>(<span style="color:#dcdcaa">function_1</span>);<span style="color:#6a9955"> // t1 starts running</span></div><div>        <span style="color:#9cdcfe">t1</span>.<span style="color:#dcdcaa">join</span>();<span style="color:#6a9955">                  // main thread wait for t1 to finish</span></div><div><span style="color:#6a9955">        // t1.detach(); // main thread let t1 to run on its own: t1 is a daemon process.</span></div><div><span style="color:#6a9955">                        // C++ runtime library is responsible for returning t1's resources</span></div><div><span style="color:#6a9955">                        // and main thread may finish before t2 prints "Hello, World"</span></div><div><span style="color:#6a9955">        // t1.join();   // crash bcos once it is detached then it is detached forever</span></div><br /><div>        <span style="color:#c586c0">if</span>(<span style="color:#9cdcfe">t1</span>.<span style="color:#dcdcaa">joinable</span>())</div><div>            <span style="color:#9cdcfe">t1</span>.<span style="color:#dcdcaa">join</span>(); <span style="color:rgb(106,153,85)">// 't1' MUST call join/detach (exactly once) before 't1' goes out of scope - </span></div><br /><div>        <span style="color:#c586c0">return</span> <span style="color:#b5cea8">0</span>;</div><div>    }</div><div><span style="color:#6a9955">    // If neither detach nor join is called, terminate() will be called for the t1.</span></div><div><span style="color:#6a9955">    // A thread can only be joined once or detached once. After it is joined on detached</span></div><div><span style="color:#6a9955">    // it becomes unjoinable ( t.joinable() returns false )</span></div></div></div></div><div><br /></div><div><b>31. Thread Management - I:</b></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div style="line-height:22px"><div><span style="color:#6a9955">    // Ref: C++ Threading #2: Thread Management</span></div><div><span style="color:#6a9955">    // https://www.youtube.com/watch?v=f2nMqNj7vxE&amp;list=PL5jc9xFGsL8E12so1wlMS0r0hTQoJL74M&amp;index=2</span></div><div><span style="color:#569cd6">    </span><span style="color:#c586c0">#include</span><span style="color:#569cd6"> </span><span style="color:#ce9178">&lt;iostream&gt;</span></div><div><span style="color:#569cd6">    </span><span style="color:#c586c0">#include</span><span style="color:#569cd6"> </span><span style="color:#ce9178">&lt;thread&gt;</span></div><div>    <span style="color:#c586c0">using</span> <span style="color:#569cd6">namespace</span> <span style="color:#4ec9b0">std</span>;</div><br /><div><span style="color:#6a9955">    // Function as a thread</span></div><div>    <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">function_1</span>() {</div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#9cdcfe">cout</span> &lt;&lt; <span style="color:#ce9178">"Hello, World"</span> &lt;&lt; <span style="color:#4ec9b0">std</span>::<span style="color:#dcdcaa">endl</span>;</div><div>    }</div><br /><div>    <span style="color:#569cd6">int</span> <span style="color:#dcdcaa">main</span>() {</div><div><span style="color:#6a9955">        // t1.join() should be called at last but before the function goes out of scope</span></div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">thread</span> <span style="color:#9cdcfe">t1</span>(<span style="color:#dcdcaa">function_1</span>);<span style="color:#6a9955"> // t1 starts running</span></div><div>        </div><br /><div><span style="color:#6a9955">        // Wrong approach</span></div><div>        <span style="color:#c586c0">for</span> (<span style="color:#569cd6">int</span> <span style="color:#9cdcfe">i</span>=<span style="color:#b5cea8">0</span>; <span style="color:#9cdcfe">i</span>&lt;<span style="color:#b5cea8">100</span>; <span style="color:#9cdcfe">i</span>++)</div><div>        {</div><div><span style="color:#6a9955">            // Suppose exception is thrown inside this function (main())</span></div><div><span style="color:#6a9955">            // then t1.join() is never going to be executed</span></div><div>            <span style="color:#9cdcfe">cout</span> &lt;&lt; <span style="color:#ce9178">"from main: "</span> &lt;&lt; <span style="color:#9cdcfe">i</span> &lt;&lt; <span style="color:#dcdcaa">endl</span>;</div><div>        }</div><div>        <span style="color:#9cdcfe">t1</span>.<span style="color:#dcdcaa">join</span>();</div><br /><div><span style="color:#6a9955">        // Solution: 1 - RAII approach.</span></div><br /><div><span style="color:#6a9955">        // Solution: 2 - try/catch :</span></div><div>        <span style="color:#c586c0">try</span> {</div><div>            <span style="color:#c586c0">for</span> (<span style="color:#569cd6">int</span> <span style="color:#9cdcfe">i</span>=<span style="color:#b5cea8">0</span>; <span style="color:#9cdcfe">i</span>&lt;<span style="color:#b5cea8">100</span>; <span style="color:#9cdcfe">i</span>++)</div><div>                <span style="color:#9cdcfe">cout</span> &lt;&lt; <span style="color:#ce9178">"from main: "</span> &lt;&lt; <span style="color:#9cdcfe">i</span> &lt;&lt; <span style="color:#dcdcaa">endl</span>;<span style="color:#6a9955">  // Exception may happen here</span></div><div>        } <span style="color:#c586c0">catch</span> (...) {</div><div>            <span style="color:#9cdcfe">t1</span>.<span style="color:#dcdcaa">join</span>();</div><div>            <span style="color:#c586c0">throw</span>;</div><div>        }</div><div><span style="color:rgb(156,220,254)"><span>    </span><span>    </span>t1</span>.<span style="color:rgb(220,220,170)">join</span>();</div><div>    }</div></div></div></div><div><br /></div><div><b>32. Thread Management - II:</b></div><div><b><br /></b></div><div><b>Passing parameters to a thread: </b><span style="background-color:transparent">Parameters are <b>always </b>passed by <b>value (copied)</b>.  </span></div><div><span style="background-color:transparent">Why? same reason as<b> bind(): D</b>eferred execution means the parameter </span><span style="background-color:transparent">objects might not be valid at the time of execution.</span></div><div><br /></div><div><div><b>To pass by reference - use:</b></div><div>    <b> 1. std::ref</b></div><div><b>     2. pointer</b></div></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div style="line-height:22px"><div><span style="color:#6a9955">    // Ref: https://en.cppreference.com/w/cpp/thread/thread/thread       </span></div><div><span style="color:#569cd6">    </span><span style="color:#c586c0">#include</span><span style="color:#569cd6"> </span><span style="color:#ce9178">&lt;iostream&gt;</span></div><div><span style="color:#569cd6">    </span><span style="color:#c586c0">#include</span><span style="color:#569cd6"> </span><span style="color:#ce9178">&lt;utility&gt;</span></div><div><span style="color:#569cd6">    </span><span style="color:#c586c0">#include</span><span style="color:#569cd6"> </span><span style="color:#ce9178">&lt;thread&gt;</span></div><div><span style="color:#569cd6">    </span><span style="color:#c586c0">#include</span><span style="color:#569cd6"> </span><span style="color:#ce9178">&lt;chrono&gt;</span></div><br /><div>    <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">f1</span>(<span style="color:#569cd6">int</span> <span style="color:#9cdcfe">n</span>)</div><div>    {</div><div>        <span style="color:#c586c0">for</span> (<span style="color:#569cd6">int</span> i = <span style="color:#b5cea8">0</span>; i &lt; <span style="color:#b5cea8">5</span>; ++i) {</div><div>            <span style="color:#4ec9b0">std</span>::cout &lt;&lt; <span style="color:#ce9178">"Thread t1 =&gt; f1(int n) executing</span><span style="color:#d7ba7d">\n</span><span style="color:#ce9178">"</span>;</div><div>            ++n;</div><div>            <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">this_thread</span>::<span style="color:#dcdcaa">sleep_for</span>(<span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">chrono</span>::<span style="color:#dcdcaa">milliseconds</span>(<span style="color:#b5cea8">10</span>));</div><div>        }</div><div>    }</div><br /><div>    <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">f2</span>(<span style="color:#569cd6">int&amp;</span> <span style="color:#9cdcfe">n</span>)</div><div>    {</div><div>        <span style="color:#c586c0">for</span> (<span style="color:#569cd6">int</span> i = <span style="color:#b5cea8">0</span>; i &lt; <span style="color:#b5cea8">5</span>; ++i) {</div><div>            <span style="color:#4ec9b0">std</span>::cout &lt;&lt; <span style="color:#ce9178">"Thread t2/t3 =&gt; f2(int&amp; n) executing</span><span style="color:#d7ba7d">\n</span><span style="color:#ce9178">"</span>;</div><div>            ++n;</div><div>            <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">this_thread</span>::<span style="color:#dcdcaa">sleep_for</span>(<span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">chrono</span>::<span style="color:#dcdcaa">milliseconds</span>(<span style="color:#b5cea8">10</span>));</div><div>        }</div><div>    }</div><br /><div>    <span style="color:#569cd6">class</span> <span style="color:#4ec9b0">foo</span></div><div>    {</div><div>    <span style="color:#569cd6">public:</span></div><div>        <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">bar</span>()</div><div>        {</div><div>            <span style="color:#c586c0">for</span> (<span style="color:#569cd6">int</span> i = <span style="color:#b5cea8">0</span>; i &lt; <span style="color:#b5cea8">5</span>; ++i) {</div><div>                <span style="color:#4ec9b0">std</span>::cout &lt;&lt; <span style="color:#ce9178">"Thread t4 =&gt; foo::bar() executing</span><span style="color:#d7ba7d">\n</span><span style="color:#ce9178">"</span>;</div><div>                ++n;</div><div>                <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">this_thread</span>::<span style="color:#dcdcaa">sleep_for</span>(<span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">chrono</span>::<span style="color:#dcdcaa">milliseconds</span>(<span style="color:#b5cea8">10</span>));</div><div>            }</div><div>        }</div><div>        <span style="color:#569cd6">int</span> n = <span style="color:#b5cea8">0</span>;</div><div>    };</div><br /><div>    <span style="color:#569cd6">class</span> <span style="color:#4ec9b0">baz</span></div><div>    {</div><div>    <span style="color:#569cd6">public:</span></div><div>        <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">operator()</span>()</div><div>        {</div><div>            <span style="color:#c586c0">for</span> (<span style="color:#569cd6">int</span> <span style="color:#9cdcfe">i</span> = <span style="color:#b5cea8">0</span>; <span style="color:#9cdcfe">i</span> &lt; <span style="color:#b5cea8">5</span>; ++<span style="color:#9cdcfe">i</span>) {</div><div>                <span style="color:#4ec9b0">std</span>::<span style="color:#9cdcfe">cout</span> &lt;&lt; <span style="color:#ce9178">"Thread t5 =&gt; baz()() executing</span><span style="color:#d7ba7d">\n</span><span style="color:#ce9178">"</span>;</div><div>                ++<span style="color:#9cdcfe">n</span>;</div><div>                <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">this_thread</span>::<span style="color:#9cdcfe">sleep_for</span>(<span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">chrono</span>::<span style="color:#4ec9b0">milliseconds</span>(<span style="color:#b5cea8">10</span>));</div><div>            }</div><div>        }</div><div>        <span style="color:#569cd6">int</span> <span style="color:#9cdcfe">n</span> = <span style="color:#b5cea8">0</span>;</div><div>    };</div><br /><div>    <span style="color:#569cd6">int</span> <span style="color:#dcdcaa">main</span>()</div><div>    {</div><div>        <span style="color:#569cd6">int</span> <span style="color:#9cdcfe">n</span> = <span style="color:#b5cea8">0</span>;</div><div>        <span style="color:#4ec9b0">foo</span> <span style="color:#9cdcfe">f</span>;</div><div>        <span style="color:#4ec9b0">baz</span> <span style="color:#9cdcfe">b</span>;</div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">thread</span> <span style="color:#9cdcfe">t0</span>;<span style="color:#6a9955">                  // t0 is not a thread</span></div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">thread</span> <span style="color:#9cdcfe">t1</span>(<span style="color:#dcdcaa">f1</span>, <span style="color:#9cdcfe">n</span> + <span style="color:#b5cea8">1</span>);<span style="color:#6a9955">       // pass by value</span></div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">thread</span> <span style="color:#9cdcfe">t2</span>(<span style="color:#dcdcaa">f2</span>, <span style="color:#4ec9b0">std</span>::<span style="color:#dcdcaa">ref</span>(<span style="color:#9cdcfe">n</span>));<span style="color:#6a9955"> // pass by reference</span></div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">thread</span> <span style="color:#9cdcfe">t3</span>(<span style="color:#4ec9b0">std</span>::<span style="color:#dcdcaa">move</span>(<span style="color:#9cdcfe">t2</span>));<span style="color:#6a9955">   // t3 is now running f2(). t2 is no longer a thread</span></div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">thread</span> <span style="color:#9cdcfe">t4</span>(&amp;<span style="color:#4ec9b0">foo</span>::<span style="color:#dcdcaa">bar</span>, &amp;<span style="color:#9cdcfe">f</span>);<span style="color:#6a9955">   // t4 runs foo::bar() on SAME object f (NOT copy) - pass by ref</span></div><div><span style="color:rgb(78,201,176)">        std</span>::<span style="color:rgb(78,201,176)">thread</span> <span style="color:rgb(156,220,254)">t5</span>(&amp;<span style="color:rgb(78,201,176)">foo</span>::<span style="color:rgb(220,220,170)">bar</span>, <span style="color:rgb(156,220,254)">f</span>);<span style="color:rgb(106,153,85)">    // t5 runs foo::bar() on COPY of object f         - pass by value</span></div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">thread</span> <span style="color:#9cdcfe">t6</span>(<span style="color:#9cdcfe">b</span>);<span style="color:#6a9955">               // t5 runs baz::operator() on a COPY of object b  - pass by value</span></div><div>        <span style="color:#9cdcfe">t1</span>.<span style="color:#dcdcaa">join</span>(); <span style="color:rgb(156,220,254)">t2</span>.<span style="color:rgb(220,220,170)">join</span>(); <span style="color:rgb(156,220,254)">t3</span>.<span style="color:rgb(220,220,170)">join</span>(); <span style="color:rgb(156,220,254)">t4</span>.<span style="color:rgb(220,220,170)">join</span>(); <span style="color:rgb(156,220,254)">t5</span>.<span style="color:rgb(220,220,170)">join</span>(); <span style="color:rgb(156,220,254)">t6</span>.<span style="color:rgb(220,220,170)">join</span>(); </div><div>        </div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#9cdcfe">cout</span> &lt;&lt; <span style="color:#ce9178">"Final value of n is "</span> &lt;&lt; <span style="color:#9cdcfe">n</span> &lt;&lt; <span style="color:#ce9178">'</span><span style="color:#d7ba7d">\n</span><span style="color:#ce9178">'</span>;              <span style="color:rgb(106,153,85)">// 5</span></div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#9cdcfe">cout</span> &lt;&lt; <span style="color:#ce9178">"Final value of f.n (foo::n) is "</span> &lt;&lt; <span style="color:#9cdcfe">f</span>.<span style="color:#9cdcfe">n</span> &lt;&lt; <span style="color:#ce9178">'</span><span style="color:#d7ba7d">\n</span><span style="color:#ce9178">'</span>; <span style="color:rgb(106,153,85)">// 5</span></div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#9cdcfe">cout</span> &lt;&lt; <span style="color:#ce9178">"Final value of b.n (baz::n) is "</span> &lt;&lt; <span style="color:#9cdcfe">b</span>.<span style="color:#9cdcfe">n</span> &lt;&lt; <span style="color:#ce9178">'</span><span style="color:#d7ba7d">\n</span><span style="color:#ce9178">'</span>; <span style="color:rgb(106,153,85)">// 0</span></div><div>    }</div></div></div></div><div><b><br /></b></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div><span style="color:rgb(106,153,85)">        Thread t1 =&gt; f1(int n) executing</span></div><div><span style="color:rgb(106,153,85)">        Thread t2/t3 =&gt; f2(int&amp; n) executing</span></div><div><span style="color:rgb(106,153,85)">        Thread t4 =&gt; foo::bar() executing</span></div><div><span style="color:rgb(106,153,85)">        Thread t5 =&gt; baz()() executing</span></div><div><span style="color:rgb(106,153,85)">        Thread t4 =&gt; foo::bar() executing</span></div><div><span style="color:rgb(106,153,85)">        Thread t5 =&gt; baz()() executing</span></div><div><span style="color:rgb(106,153,85)">        Thread t2/t3 =&gt; f2(int&amp; n) executing</span></div><div><span style="color:rgb(106,153,85)">        Thread t1 =&gt; f1(int n) executing</span></div><div><span style="color:rgb(106,153,85)">        Thread t2/t3 =&gt; f2(int&amp; n) executing</span></div><div><span style="color:rgb(106,153,85)">        Thread t4 =&gt; foo::bar() executing</span></div><div><span style="color:rgb(106,153,85)">        Thread t5 =&gt; baz()() executing</span></div><div><span style="color:rgb(106,153,85)">        Thread t1 =&gt; f1(int n) executing</span></div><div><span style="color:rgb(106,153,85)">        Thread t1 =&gt; f1(int n) executing</span></div><div><span style="color:rgb(106,153,85)">        Thread t2/t3 =&gt; f2(int&amp; n) executing</span></div><div><span style="color:rgb(106,153,85)">        Thread t4 =&gt; foo::bar() executing</span></div><div><span style="color:rgb(106,153,85)">        Thread t5 =&gt; baz()() executing</span></div><div><span style="color:rgb(106,153,85)">        Thread t2/t3 =&gt; f2(int&amp; n) executing</span></div><div><span style="color:rgb(106,153,85)">        Thread t4 =&gt; foo::bar() executing</span></div><div><span style="color:rgb(106,153,85)">        Thread t5 =&gt; baz()() executing</span></div><div><span style="color:rgb(106,153,85)">        Thread t1 =&gt; f1(int n) executing</span></div><div><span style="color:rgb(106,153,85)">        Final value of n is 5</span></div><div><span style="color:rgb(106,153,85)">        Final value of f.n (foo::n) is 5</span></div><div><span style="color:rgb(106,153,85)">        Final value of b.n (baz::n) is 0</span></div></div></div><div><b><br /></b></div><div>Ex: 2</div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div style="line-height:22px"><div style="line-height:22px"><div><span style="color:#6a9955">    // Ref: C++ Threading #2: Thread Management</span></div><div><span style="color:#6a9955">    // https://www.youtube.com/watch?v=f2nMqNj7vxE&amp;list=PL5jc9xFGsL8E12so1wlMS0r0hTQoJL74M&amp;index=2</span></div><div><span style="color:#569cd6">    </span><span style="color:#c586c0">#include</span><span style="color:#569cd6"> </span><span style="color:#ce9178">&lt;iostream&gt;</span></div><div><span style="color:#569cd6">    </span><span style="color:#c586c0">#include</span><span style="color:#569cd6"> </span><span style="color:#ce9178">&lt;string&gt;</span></div><div><span style="color:#569cd6">    </span><span style="color:#c586c0">#include</span><span style="color:#569cd6"> </span><span style="color:#ce9178">&lt;thread&gt;</span></div><div>    <span style="color:#c586c0">using</span> <span style="color:#569cd6">namespace</span> <span style="color:#4ec9b0">std</span>;</div><br /><div><span style="color:#6a9955">    // To pass a class method as thread's initial function, use pointers</span></div><div>    <span style="color:#569cd6">class</span> <span style="color:#4ec9b0">A</span> {</div><div>    <span style="color:#569cd6">public:</span></div><div>        <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">ptrParmMemFun</span>(<span style="color:#4ec9b0">string</span><span style="color:#569cd6">*</span> <span style="color:#9cdcfe">msg</span>) {</div><div>            *<span style="color:#9cdcfe">msg</span> <span style="color:#dcdcaa">=</span> <span style="color:#ce9178">"Beauty is only skin-deep"</span>;<span style="color:#6a9955"> // overwriting the source content</span></div><div>            <span style="color:#9cdcfe">cout</span> &lt;&lt; <span style="color:#ce9178">"t1 says: "</span> &lt;&lt; *<span style="color:#9cdcfe">msg</span> &lt;&lt; <span style="color:#dcdcaa">endl</span>; </div><div>        }</div><div>    };</div><br /><div><div style="line-height:22px"><div style="line-height:22px"><div><span style="color:#6a9955">    // Functor as a thread</span></div><div>    <span style="color:#569cd6">class</span> <span style="color:#4ec9b0">Fctor</span> {</div><div>    <span style="color:#569cd6">public:</span></div><div>        <span style="color:#569cd6">void</span> <span style="color:#c586c0">operator()</span>() {</div><div>            <span style="color:#4ec9b0">std</span>::cout &lt;&lt; <span style="color:#ce9178">"Life is beautiful"</span> &lt;&lt; <span style="color:#4ec9b0">std</span>::endl;</div><div>        }</div><br /><div><span style="color:#6a9955">        // Passing by value</span></div><div>        <span style="color:#569cd6">void</span> <span style="color:#c586c0">operator()</span>(<span style="color:#4ec9b0">string</span> <span style="color:#9cdcfe">msg</span>) {</div><div>            <span style="color:#4ec9b0">std</span>::cout &lt;&lt; <span style="color:#ce9178">"t1 says: "</span> &lt;&lt; msg &lt;&lt; <span style="color:#4ec9b0">std</span>::endl;</div><div>            msg = <span style="color:#ce9178">"I'm altering the source msg"</span>;</div><div>        }</div><br /><div><span style="color:#6a9955">        // OK              -  caller std::thread t4((Fctor()), s); pick above function and ignore below function</span></div><div><span style="color:#6a9955">        // Error(conflict) -  caller std::thread t4((Fctor()), std::ref(s)); - confuse which to choose</span></div><div><span style="color:#6a9955">        // void operator()(string&amp; msg) {</span></div><div><span style="color:#6a9955">        //  std::cout &lt;&lt; "t1 says: " &lt;&lt; msg &lt;&lt; std::endl;</span></div><div><span style="color:#6a9955">        //  msg = "I'm altering the source msg";</span></div><div><span style="color:#6a9955">        // }</span></div><div>    };</div></div></div></div><br /><div>    <span style="color:#569cd6">class</span> <span style="color:#4ec9b0">FctorRefParam</span> {</div><div>        <span style="color:#569cd6">public:</span></div><div><span style="color:#6a9955">        // Looks like a pass by reference but it actually a pass by value if it is used as a thread function</span></div><div><span style="color:#6a9955">        // parameter to thread always pass by value even if you capture using &amp;</span></div><div>        <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">operator()</span>(<span style="color:#4ec9b0">string</span><span style="color:#569cd6">&amp;</span> <span style="color:#9cdcfe">msg</span>) {</div><div>            <span style="color:#4ec9b0">std</span>::<span style="color:#9cdcfe">cout</span> &lt;&lt; <span style="color:#ce9178">"t1 says: "</span> &lt;&lt; <span style="color:#9cdcfe">msg</span> &lt;&lt; <span style="color:#4ec9b0">std</span>::<span style="color:#dcdcaa">endl</span>;</div><div>            <span style="color:#9cdcfe">msg</span> <span style="color:#dcdcaa">=</span> <span style="color:#ce9178">"I'm altering the source msg"</span>;</div><div>        }</div><div>    };</div><br /><div>    <span style="color:#569cd6">void</span> <span style="color:rgb(220,220,170)">functionRefParam</span>(<span style="color:#4ec9b0">string</span><span style="color:#569cd6">&amp;</span> <span style="color:#9cdcfe">msg</span>) {</div><div>        <span style="color:#9cdcfe">msg</span> <span style="color:#dcdcaa">=</span> <span style="color:#ce9178">"Beauty is only skin-deep"</span>;</div><div>        <span style="color:#9cdcfe">cout</span> &lt;&lt; <span style="color:#ce9178">"t1 says: "</span> &lt;&lt; <span style="color:#9cdcfe">msg</span> &lt;&lt; <span style="color:#dcdcaa">endl</span>;</div><div>    }</div><br /><div><span style="color:#6a9955">    // Thread with moving parameters</span></div><div>    <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">functionValueParam</span>(<span style="color:#4ec9b0">string</span> <span style="color:#9cdcfe">msg</span>) { <span style="color:rgb(156,220,254)">cout</span> &lt;&lt; <span style="color:rgb(206,145,120)">"t1 says: "</span> &lt;&lt; <span style="color:rgb(156,220,254)">msg</span> &lt;&lt; <span style="color:rgb(220,220,170)">endl</span>; }</div><br /><div><span style="color:#6a9955">    // Case 4: move semantics  (by return)</span></div><div>    <span style="color:#4ec9b0">thread</span> <span style="color:#dcdcaa">f</span>() { <span style="color:rgb(197,134,192)">return</span> <span style="color:rgb(78,201,176)">std</span>::<span style="color:rgb(78,201,176)">thread</span>(<span style="color:rgb(220,220,170)">functionValueParam</span>); }</div><br /><div><span style="color:#6a9955">    // Case 5: move semantics (pass by value)</span></div><div>    <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">funMove</span>(<span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">thread</span> <span style="color:#9cdcfe">t</span>) { }</div><div><br /></div><div><div><span style="color:rgb(106,153,85)">    // Function as a thread</span></div><div>    <span style="color:rgb(86,156,214)">void</span> <span style="color:rgb(220,220,170)">function_1</span>() { <span style="color:rgb(78,201,176)">std</span>::<span style="color:rgb(156,220,254)">cout</span> &lt;&lt; <span style="color:rgb(206,145,120)">"Hello, World"</span> &lt;&lt; <span style="color:rgb(78,201,176)">std</span>::<span style="color:rgb(220,220,170)">endl</span>; }</div></div><br /><div>    <span style="color:#569cd6">int</span> <span style="color:#dcdcaa">main</span>() {</div><div><span style="color:#6a9955">        // 4 = how many threads truly the processor can run = No. of core's</span></div><div>        <span style="color:#9cdcfe">cout</span>&lt;&lt; <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">thread</span>::<span style="color:#dcdcaa">hardware_concurrency</span>() &lt;&lt; <span style="color:#dcdcaa">endl</span>;  </div><div>        <span style="color:#9cdcfe">cout</span>&lt;&lt; <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">this_thread</span>::<span style="color:#dcdcaa">get_id</span>() &lt;&lt; <span style="color:#dcdcaa">endl</span>;<span style="color:#6a9955"> // parent thread id</span></div><br /><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">thread</span> <span style="color:#9cdcfe">t1</span>(<span style="color:#dcdcaa">function_1</span>);</div><div>        <span style="color:#9cdcfe">cout</span>&lt;&lt; <span style="color:#9cdcfe">t1</span>.<span style="color:#dcdcaa">get_id</span>() &lt;&lt; <span style="color:#dcdcaa">endl</span>;<span style="color:#6a9955"> // child thread id</span></div><div>        </div><div>        <span style="color:#4ec9b0">Fctor</span> <span style="color:#9cdcfe">fct</span>;</div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">thread</span> <span style="color:#9cdcfe">t2</span>(<span style="color:#9cdcfe">fct</span>);</div><div>        <span style="color:#9cdcfe">t2</span>.<span style="color:#dcdcaa">join</span>();<span style="color:#6a9955"> // "Life is beautiful</span></div><br /><div><span style="color:#6a9955">        // Below instead of creating a thread (variable definition), we are 'declaring' a function t3 </span></div><div><span style="color:#6a9955">        // (function declaration) that takes an arg and return a thread</span></div><div><span style="color:#6a9955">        // std::thread t3(Fctor()); // CompilationErr - vexing syntax - variable definition / function declaration ??</span></div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">thread</span> <span style="color:#9cdcfe">t3</span>((<span style="color:#4ec9b0">Fctor</span>()));<span style="color:#6a9955">  // NOTE: () - forcing the compiler to consider as 'variable definition'</span></div><div>        <span style="color:#9cdcfe">t3</span>.<span style="color:#dcdcaa">join</span>();<span style="color:#6a9955"> // "Life is beautiful</span></div><br /><div>        <span style="color:#4ec9b0">string</span> <span style="color:#9cdcfe">s</span> = <span style="color:#ce9178">"Where there is no trust, there is no love"</span>;</div><div><span style="color:#6a9955">        // parameter to thread always pass by value even if the capturing function using &amp; for the input parameter</span></div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">thread</span> <span style="color:#9cdcfe">t4</span>((<span style="color:rgb(78,201,176)">FctorRefParam</span> ()), <span style="color:#9cdcfe">s</span>);<span style="color:#6a9955"> // pass by value, even it capture the param by &amp;</span></div><div>        <span style="color:#9cdcfe">t4</span>.<span style="color:#dcdcaa">join</span>();</div><div>        <span style="color:#9cdcfe">cout</span> &lt;&lt; <span style="color:#ce9178">"from main: "</span> &lt;&lt; <span style="color:#9cdcfe">s</span> &lt;&lt; <span style="color:#dcdcaa">endl</span>;<span style="color:#6a9955"> // from main: Where there is no trust, there is no love</span></div><br /><div><span style="color:#6a9955">        // Explicitly want to send the thread params - by reference (Method 1)</span></div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">thread</span> <span style="color:#9cdcfe">t5</span>((<span style="color:rgb(78,201,176)">FctorRefParam</span> ()), <span style="color:#4ec9b0">std</span>::<span style="color:#dcdcaa">ref</span>(<span style="color:#9cdcfe">s</span>));<span style="color:#6a9955"> // both child and parent share the same 's' - It is dangerous</span></div><div>        <span style="color:#9cdcfe">t5</span>.<span style="color:#dcdcaa">join</span>();</div><div>        <span style="color:#9cdcfe">cout</span> &lt;&lt; <span style="color:#ce9178">"from main: "</span> &lt;&lt; <span style="color:#9cdcfe">s</span> &lt;&lt; <span style="color:#dcdcaa">endl</span>;<span style="color:#6a9955"> // from main: I'm altering the source msg [ALTERED BY CHILD THREAD]</span></div><br /><div><span style="color:#6a9955">        // Explicitly want to send the thread params - by pointers (Method 2 - old way)</span></div><div>        <span style="color:#4ec9b0">string</span> <span style="color:#9cdcfe">str</span> = <span style="color:#ce9178">"A friend in need is a friend indeed."</span>;</div><div>        <span style="color:#4ec9b0">A</span> <span style="color:#9cdcfe">a</span>;</div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">thread</span> <span style="color:#9cdcfe">tp</span>(&amp;<span style="color:#4ec9b0">A</span>::<span style="color:rgb(220,220,170)">ptrParmMemFun</span>, &amp;<span style="color:#9cdcfe">a</span>, &amp;<span style="color:#9cdcfe">str</span>);<span style="color:#6a9955"> // &amp;a - is must</span></div><div>        <span style="color:#9cdcfe">tp</span>.<span style="color:#dcdcaa">detach</span>();</div><div>        <span style="color:#9cdcfe">cout</span> &lt;&lt; <span style="color:#ce9178">"main says: "</span> &lt;&lt; <span style="color:#9cdcfe">str</span> &lt;&lt; <span style="color:#dcdcaa">endl</span>;<span style="color:#6a9955"> //  Beauty is only skin-deep</span></div><br /><div><span style="color:#6a9955">        // move 's' from parent to child by reference (Like moving unique pointer, fstream, thread object etc)</span></div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">thread</span> <span style="color:#9cdcfe">t6</span>((<span style="color:#4ec9b0">Fctor</span>()), <span style="color:#4ec9b0">std</span>::<span style="color:#dcdcaa">move</span>(<span style="color:#9cdcfe">s</span>));<span style="color:#6a9955"> // parent thead then no longer have an access to 's'   </span></div><div>        <span style="color:#9cdcfe">t6</span>.<span style="color:#dcdcaa">join</span>();</div><div><span style="color:#6a9955">        // cout &lt;&lt; "from main: " &lt;&lt; s &lt;&lt; endl; // It cann't access the moved 's'</span></div><br /><div>        <span style="color:#4ec9b0">string</span>* <span style="color:#9cdcfe">ps</span> = <span style="color:#c586c0">new</span> <span style="color:#4ec9b0">string</span>(<span style="color:#ce9178">"A friend in need is a friend indeed."</span>);</div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">thread</span> <span style="color:#9cdcfe">tps</span>(<span style="color:rgb(220,220,170)">functionRefParam</span>, <span style="color:#4ec9b0">std</span>::<span style="color:#dcdcaa">move</span>(*<span style="color:#9cdcfe">ps</span>));<span style="color:#6a9955"> // Beauty is only skin-deep</span></div><div>        <span style="color:#9cdcfe">tps</span>.<span style="color:#dcdcaa">join</span>();</div><div>        <span style="color:#9cdcfe">cout</span> &lt;&lt; <span style="color:#ce9178">"main: "</span> &lt;&lt; *<span style="color:#9cdcfe">ps</span> &lt;&lt; <span style="color:#dcdcaa">endl</span>;<span style="color:#6a9955"> // main: [empty string]</span></div><div><br /></div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">thread</span> <span style="color:#9cdcfe">t7</span>((<span style="color:#4ec9b0">Fctor</span>()), <span style="color:#4ec9b0">std</span>::<span style="color:#dcdcaa">move</span>(<span style="color:#9cdcfe">s</span>));<span style="color:#6a9955"> // parent thead then no longer have an access to 's'</span></div><div><span style="color:#6a9955">        </span><span style="color:rgb(106,153,85)">// A thread object cannot be copied. But it can be moved.  Like fstream, unique_ptr, etc.</span></div><div><span style="color:rgb(106,153,85)">        // Case 1: move semantics</span></div><div><span style="color:#6a9955">        // std::thread t8 = t7; // Error: thread cannot be copied only be moved.</span></div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">thread</span> <span style="color:#9cdcfe">t8</span> = <span style="color:#4ec9b0">std</span>::<span style="color:#dcdcaa">move</span>(<span style="color:#9cdcfe">t7</span>);<span style="color:#6a9955"> // changing ownership from t7 to t8.</span></div><div><span style="color:rgb(106,153,85)">        // t7.join(); // if you are moving the thread object then join using by the moved one (t8.join())</span></div><div>        <span style="color:#9cdcfe">t8</span>.<span style="color:#dcdcaa">join</span>();</div><br /><div><span style="color:#6a9955">        // Case 2: move semantics</span></div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">thread</span> <span style="color:#9cdcfe">t9</span>(<span style="color:rgb(220,220,170)">functionValueParam</span>);</div><div><span style="color:#6a9955">        // move semantics</span></div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">thread</span> <span style="color:#9cdcfe">t10</span> = <span style="color:rgb(78,201,176)">std</span>::<span style="color:rgb(220,220,170)">move</span>(<span style="color:rgb(156,220,254)">t9</span>);<span style="color:rgb(106,153,85)">  // t10 become the owner of the thread</span></div><div>        <span style="color:#9cdcfe">t10</span>.<span style="color:#dcdcaa">join</span>();</div><br /><div><span style="color:#6a9955">        // Case 3: move semantics</span></div><div>        <span style="color:#dcdcaa">funMove</span>(<span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">thread</span>(<span style="color:rgb(220,220,170)">functionValueParam</span>)); <span style="color:rgb(106,153,85)">// passing thread to another function</span></div><div>    }</div></div></div></div></div><div><br /></div><div><b>33. Data Race and Mutex:</b></div><div><b>cout - data race</b></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div>    <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">coutRace</span>() { </div><div>        <span style="color:#c586c0">for</span> (<span style="color:#569cd6">int</span> i = <span style="color:#b5cea8">0</span>; i &gt; -<span style="color:#b5cea8">100</span>; --i) cout &lt;&lt; <span style="color:#ce9178">"thread: "</span> &lt;&lt; i &lt;&lt; endl;</div><div>    }</div><br /><div>    <span style="color:#569cd6">int</span> <span style="color:#dcdcaa">main</span>()</div><div>    {</div><div>        thread t{ coutRace };</div><div>        <span style="color:#c586c0">for</span> (<span style="color:#569cd6">int</span> i = <span style="color:#b5cea8">0</span>; i &lt; <span style="color:#b5cea8">100</span>; ++i) cout &lt;&lt; <span style="color:#ce9178">"main: "</span> &lt;&lt; i &lt;&lt; endl;</div><div>        <span style="color:#9cdcfe">t</span>.<span style="color:#dcdcaa">join</span>();</div><div>    }</div></div></div><div><b><br /></b></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div><span style="color:#6a9955">    main: 0</span></div><div><span style="color:#6a9955">    main : 1</span></div><div><span style="color:#6a9955">    main : 2</span></div><div><span style="color:#6a9955">    thread : 0</span></div><div><span style="color:#6a9955">    thread : -1</span></div><div><span style="color:#6a9955">    main: thread: -2</span></div><div><span style="color:#6a9955">    thread : -4</span></div><div><span style="color:#6a9955">    3</span></div><div><span style="color:#6a9955">    main : 4</span></div></div></div><div><br /></div><div><b>Solution: mutex:</b></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div>    <span style="color:#4ec9b0">std</span>::mutex mu;</div><br /><div>    <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">shared_print</span>(<span style="color:#4ec9b0">string</span> <span style="color:#9cdcfe">msg</span>, <span style="color:#569cd6">int</span> <span style="color:#9cdcfe">i</span>)</div><div>    {</div><div>        <span style="color:#9cdcfe">mu</span>.<span style="color:#dcdcaa">lock</span>();</div><div>        cout &lt;&lt; <span style="color:#9cdcfe">msg</span> &lt;&lt; <span style="color:#9cdcfe">i</span> &lt;&lt; endl;</div><div>        <span style="color:#9cdcfe">mu</span>.<span style="color:#dcdcaa">unlock</span>();</div><div>    }</div><br /><div>    <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">coutRace</span>() {</div><div>        <span style="color:#c586c0">for</span> (<span style="color:#569cd6">int</span> <span style="color:#9cdcfe">i</span> = <span style="color:#b5cea8">0</span>; <span style="color:#9cdcfe">i</span> &gt; -<span style="color:#b5cea8">100</span>; --<span style="color:#9cdcfe">i</span>) <span style="color:#dcdcaa">shared_print</span>(<span style="color:#ce9178">"thread: "</span>, <span style="color:#9cdcfe">i</span>);</div><div>    }</div><br /><div>    <span style="color:#569cd6">int</span> <span style="color:#dcdcaa">main</span>()</div><div>    {</div><div>        thread t{ coutRace };</div><div>        <span style="color:#c586c0">for</span> (<span style="color:#569cd6">int</span> <span style="color:#9cdcfe">i</span> = <span style="color:#b5cea8">0</span>; <span style="color:#9cdcfe">i</span> &lt; <span style="color:#b5cea8">100</span>; ++<span style="color:#9cdcfe">i</span>) <span style="color:#dcdcaa">shared_print</span>(<span style="color:#ce9178">"main: "</span>, <span style="color:#9cdcfe">i</span>);</div><div>        <span style="color:#9cdcfe">t</span>.<span style="color:#dcdcaa">join</span>();</div><div>    }</div></div></div><div><b><br /></b></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div><span style="color:#6a9955">    main: 0</span></div><div><span style="color:#6a9955">    main : 1</span></div><div><span style="color:#6a9955">    thread : 0</span></div><div><span style="color:#6a9955">    main : 2</span></div><div><span style="color:#6a9955">    main : 3</span></div><div><span style="color:#6a9955">    thread : 1</span></div></div></div><div><b><br /></b></div><div><b>Explanation:</b></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div style="line-height:22px"><div><span style="color:#6a9955">    // Ref: C++ Threading #3: Data Race and Mutex</span></div><div><span style="color:#6a9955">    // https://www.youtube.com/watch?v=3ZxZPeXPaM4&amp;list=PL5jc9xFGsL8E12so1wlMS0r0hTQoJL74M&amp;index=4&amp;t=44s</span></div><div><span style="color:#569cd6">    </span><span style="color:#c586c0">#include</span><span style="color:#569cd6"> </span><span style="color:#ce9178">&lt;iostream&gt;</span></div><div><span style="color:#569cd6">    </span><span style="color:#c586c0">#include</span><span style="color:#569cd6"> </span><span style="color:#ce9178">&lt;string&gt;</span></div><div><span style="color:#569cd6">    </span><span style="color:#c586c0">#include</span><span style="color:#569cd6"> </span><span style="color:#ce9178">&lt;fstream&gt;</span><span style="color:#569cd6"> </span><span style="color:#6a9955">// ofstream f;</span></div><br /><div><span style="color:#569cd6">    </span><span style="color:#c586c0">#include</span><span style="color:#569cd6"> </span><span style="color:#ce9178">&lt;thread&gt;</span></div><div><span style="color:#569cd6">    </span><span style="color:#c586c0">#include</span><span style="color:#569cd6"> </span><span style="color:#ce9178">&lt;mutex&gt;</span></div><div>    <span style="color:#c586c0">using</span> <span style="color:#569cd6">namespace</span> <span style="color:#4ec9b0">std</span>;</div><br /><div>    <span style="color:#4ec9b0">std</span>::mutex <span style="color:#9cdcfe">mu</span>;</div><br /><div><span style="color:#6a9955">    // Method 1: Synchronization using mu.lock/unlock - NOT exception safe</span></div><div>    <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">shared_print</span>(<span style="color:#4ec9b0">string</span> <span style="color:#9cdcfe">msg</span>, <span style="color:#569cd6">int</span> <span style="color:#9cdcfe">id</span>) {</div><div>        <span style="color:#9cdcfe">mu</span>.<span style="color:#dcdcaa">lock</span>();</div><div><span style="color:#6a9955">        // Now access of 'cout' is synchronous</span></div><div>        <span style="color:#9cdcfe">cout</span> &lt;&lt; <span style="color:#9cdcfe">msg</span> &lt;&lt; <span style="color:#9cdcfe">id</span> &lt;&lt; <span style="color:#dcdcaa">endl</span>;<span style="color:#6a9955"> // If it throws exception there then locked forever</span></div><div>        <span style="color:#9cdcfe">mu</span>.<span style="color:#dcdcaa">unlock</span>();</div><div>    }</div></div></div></div><div><br /></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div style="line-height:22px"><div><span style="color:#6a9955">    // Method 2: Synchronization using lock_guard - exception safe by RAII</span></div><div>    <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">shared_print</span>(<span style="color:#4ec9b0">string</span> <span style="color:#9cdcfe">msg</span>, <span style="color:#569cd6">int</span> <span style="color:#9cdcfe">id</span>) {</div><div>        <span style="color:#4ec9b0">std</span>::lock_guard&lt;<span style="color:#4ec9b0">std</span>::mutex&gt; <span style="color:#dcdcaa">guard</span>(mu);<span style="color:#6a9955"> // RAII</span></div><div><span style="color:#6a9955">        // Now access of 'cout' is synchronous</span></div><div>        cout &lt;&lt; msg &lt;&lt; id &lt;&lt; endl;<span style="color:#6a9955"> // Unlocked even if there will be an exception</span></div><div>    }</div></div></div></div><div><br /></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div style="line-height:22px"><div><span style="color:#6a9955">    // Method 3: file synchronization (it gives complete synchronization, </span><span style="color:rgb(106,153,85)">unlike 'cout'</span><span style="color:rgb(106,153,85)">)</span></div><div><span style="color:#6a9955">    // (NOTE: we cann't achieve the complete </span><span style="color:rgb(106,153,85)">synchronization </span><span style="color:#6a9955">in 'cout' bcos 'cout' is a global object so it can</span></div><div><span style="color:#6a9955">    // used without lock mechanism by someone else)</span></div><div>    <span style="color:#569cd6">class</span> <span style="color:#4ec9b0">LogFile</span></div><div>    {</div><div>        <span style="color:#4ec9b0">std</span>::mutex m_mutex;</div><div>        ofstream f;</div><br /><div>    <span style="color:#569cd6">public:</span></div><div>        <span style="color:#dcdcaa">LogFile</span>() { <span style="color:#9cdcfe">f</span>.<span style="color:#dcdcaa">open</span>(<span style="color:#ce9178">"log.txt"</span>); }</div><div>        <span style="color:#dcdcaa">~LogFile</span>() { <span style="color:#9cdcfe">f</span>.<span style="color:#dcdcaa">close</span>(); }</div><br /><div>        <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">shared_print_log</span>(<span style="color:#4ec9b0">string</span> <span style="color:#9cdcfe">msg</span>, <span style="color:#569cd6">int</span> <span style="color:#9cdcfe">id</span>)</div><div>        {</div><div>            <span style="color:#4ec9b0">std</span>::lock_guard&lt;<span style="color:#4ec9b0">std</span>::mutex&gt; <span style="color:#dcdcaa">guard</span>(mu);<span style="color:#6a9955"> // RAII</span></div><div>            f &lt;&lt; msg &lt;&lt; id &lt;&lt; endl;<span style="color:#6a9955">                // Unlocked even if there will be an exception</span></div><div>        }</div><br /><div><span style="color:#6a9955">        // To keep 'f' is a complete synchronous access.  Don't expose 'f' to the outside world bcos 'f' can be</span></div><div><span style="color:#6a9955">        // used without going through the lock mechanism</span></div><div><span style="color:#6a9955">        // 1. Never return 'f' to the outside world. Example</span></div><div><span style="color:#6a9955">        // <span>    </span>ofstream&amp; getStream() { return f; }</span></div><div><span style="color:#6a9955">        // 2. Never pass 'f' as an argument to user provided function/ call back function. Example</span></div><div><span style="color:#6a9955">        // <span>    </span>void process_f(void fun(ofstream&amp;)) {</span></div><div><span style="color:#6a9955">        //  <span>    </span><span>    </span>fun(f);</span></div><div><span style="color:#6a9955">        // <span>     </span>}</span></div><div>    };</div></div></div></div><div><br /></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div style="line-height:22px"><div><span style="color:#6a9955">    // Racing for 'cout' access!!</span></div><div>    <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">function_1</span>() {</div><div>        <span style="color:#c586c0">for</span>(<span style="color:#569cd6">int</span> i = <span style="color:#b5cea8">0</span>; i &gt; -<span style="color:#b5cea8">100</span>; --i) {</div><div><span style="color:#6a9955">            // cout&lt;&lt; "Fromt t1: " &lt;&lt; i &lt;&lt; endl;  // cout in asynchronous access - cout without lock</span></div><div>            <span style="color:#dcdcaa">shared_print</span>(<span style="color:#dcdcaa">string</span>(<span style="color:#ce9178">"From t1: "</span>), i);<span style="color:#6a9955"> // cout in synchronous access  - cout with lock</span></div><div>        }</div><div>    }</div></div></div></div><div><br /></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div style="line-height:22px"><div><span style="color:#6a9955">    // Racing for 'file' access !!</span></div><div>    <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">function_log</span>(<span style="color:#4ec9b0">LogFile</span><span style="color:#569cd6">&amp;</span> <span style="color:#9cdcfe">log</span>) {</div><div><span style="color:#6a9955">        // file access is synchronous</span></div><div>        <span style="color:#c586c0">for</span>(<span style="color:#569cd6">int</span> i = <span style="color:#b5cea8">0</span>; i &gt; -<span style="color:#b5cea8">100</span>; --i) <span style="color:#9cdcfe">log</span>.<span style="color:#dcdcaa">shared_print_log</span>(<span style="color:#dcdcaa">string</span>(<span style="color:#ce9178">"From t1: "</span>), i);</div><div>    }</div></div></div></div><div><br /></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div style="line-height:22px"><div>    <span style="color:#569cd6">int</span> <span style="color:#dcdcaa">main</span>() {</div><div><span style="color:#6a9955">        // 'cout' shared access</span></div><div>        <span style="color:#4ec9b0">std</span>::thread <span style="color:#dcdcaa">t1</span>(function_1);<span style="color:#6a9955"> // t1 starts running</span></div><br /><div>        <span style="color:#c586c0">for</span>(<span style="color:#569cd6">int</span> i = <span style="color:#b5cea8">0</span>; i &lt; <span style="color:#b5cea8">100</span>; ++i) {</div><div><span style="color:#6a9955">            // cout&lt;&lt; "Fromt main: " &lt;&lt; i &lt;&lt; endl;  // cout in asynchronous access</span></div><div>            <span style="color:#dcdcaa">shared_print</span>(<span style="color:#dcdcaa">string</span>(<span style="color:#ce9178">"From main: "</span>), i);<span style="color:#6a9955"> // cout in synchronous access</span></div><div>        }</div><div>        <span style="color:#9cdcfe">t1</span>.<span style="color:#dcdcaa">join</span>();</div><br /><div><span style="color:#6a9955">        // 'file' shared access</span></div><div>        LogFile log;</div><div>        <span style="color:#4ec9b0">std</span>::thread <span style="color:#dcdcaa">t2</span>(function_log, <span style="color:#4ec9b0">std</span>::<span style="color:#dcdcaa">ref</span>(log));<span style="color:#6a9955"> // passing 'log' by reference</span></div><br /><div>        <span style="color:#c586c0">for</span>(<span style="color:#569cd6">int</span> i = <span style="color:#b5cea8">0</span>; i &lt; <span style="color:#b5cea8">100</span>; ++i) </div><div>        <span style="color:#9cdcfe">log</span>.<span style="color:#dcdcaa">shared_print_log</span>(<span style="color:#dcdcaa">string</span>(<span style="color:#ce9178">"From t1: "</span>), i);</div><div>        <span style="color:#9cdcfe">t2</span>.<span style="color:#dcdcaa">join</span>();</div><div>    }</div></div></div></div><div><br /></div><div><b>34. stl STACK interface is not Thread Safe:</b></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div style="line-height:22px"><div><span style="color:#6a9955">    /* STACK (native) - Interface is NOT thread safe */</span></div><div>    <span style="color:#569cd6">class</span> <span style="color:#4ec9b0">stack</span> {</div><div>        <span style="color:#569cd6">int</span>* _data;<span style="color:#6a9955">     // integer array to store the _data</span></div><div>        <span style="color:#4ec9b0">std</span>::mutex _mu;<span style="color:#6a9955"> // assume pop / top access the data through mutex _mu </span></div><div>    <span style="color:#569cd6">public:</span></div><div><span style="color:#6a9955">        // separated functions top() and pop() makes the data NOT thread safe</span></div><div>        <span style="color:#569cd6">int&amp;</span> <span style="color:#dcdcaa">top</span>();<span style="color:#6a9955"> // returns the item on top</span></div><div>        <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">pop</span>();<span style="color:#6a9955"> // pops off the item on top of the stack but NOT return any value  </span></div><div><span style="color:rgb(106,153,85)">     // int&amp; pop(); // thread safe but NOT exception safe.</span><span style="color:#6a9955"> </span></div><div>    };</div></div></div></div><div><br /></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div style="line-height:22px"><div>    <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">process</span>(<span style="color:#569cd6">int</span> <span style="color:#9cdcfe">d</span>) {</div><div>        cout&lt;&lt; <span style="color:#b5cea8">10</span> * d;</div><div>    }</div></div></div></div><div><br /></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div style="line-height:22px"><div>    <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">function_1</span>(<span style="color:#4ec9b0">stack</span><span style="color:#569cd6">&amp;</span> <span style="color:#9cdcfe">st</span>) {</div><div>        <span style="color:#569cd6">int</span> v = <span style="color:#9cdcfe">st</span>.<span style="color:#dcdcaa">top</span>();</div><div>        <span style="color:#9cdcfe">st</span>.<span style="color:#dcdcaa">pop</span>();</div><div>        <span style="color:#dcdcaa">process</span>(v);</div><div>    }</div></div></div></div><div><br /></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div style="line-height:22px"><div><span style="color:#6a9955">    _data = [6,8,3,9]</span></div><div><span style="color:#6a9955">            Thread 1                        Thread 2</span></div><div><span style="color:#6a9955">    --------------------------------------------------------------</span></div><div><span style="color:#6a9955">    1.  int v = st.top(); // 6</span></div><div><span style="color:#6a9955">    2.                                  int v = st.top(); // 6</span></div><div><span style="color:#6a9955">    3.  st.pop(); // 6</span></div><div><span style="color:#6a9955">    4.                                  st.pop(); // 8</span></div><div><span style="color:#6a9955">    5.                                  process(v); // 60</span></div><div><span style="color:#6a9955">    6.  process(v); // 60</span></div><br /><div><span style="color:#6a9955">    NOT thread safe - 6 processed 'twice' and 8 popped but not processed - even it is protected by mutex.</span></div><div><span style="color:#6a9955">   Culprit's are 'pop' and 'top' interfaces.</span></div></div></div></div><div><br /></div><div><b>Solution:</b></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div style="line-height:22px"><div><span style="color:#6a9955">    /* STACK (user defined) - Interface is thread safe */</span></div><div>    <span style="color:#569cd6">class</span> <span style="color:#4ec9b0">stackSafe</span> {</div><div>        <span style="color:#569cd6">int</span>* _data;<span style="color:#6a9955"> // integer array to store the _data</span></div><div>        <span style="color:#4ec9b0">std</span>::mutex _mu;<span style="color:#6a9955"> // pop access the data through mutex _mu </span></div><div>    <span style="color:#569cd6">public:</span></div><div><span style="color:#6a9955">        // combine pop &amp; top into one interface for making data access thread safe</span></div><div>        <span style="color:#569cd6">int&amp;</span> <span style="color:#dcdcaa">pop</span>();<span style="color:#6a9955"> // pops off the item on top of the stack but RETURNS data</span></div><div>    };</div></div></div></div><div><br /></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div style="line-height:22px"><div>    <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">function_2</span>(<span style="color:#4ec9b0">stackSafe</span><span style="color:#569cd6">&amp;</span> <span style="color:#9cdcfe">st</span>) {</div><div>        <span style="color:#569cd6">int</span> v = <span style="color:#9cdcfe">st</span>.<span style="color:#dcdcaa">pop</span>();</div><div>        <span style="color:#dcdcaa">process</span>(v);</div><div>    }</div></div></div></div><div><br /></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div style="line-height:22px"><div><span style="color:#6a9955">    _data = [6,8,3,9]</span></div><div><span style="color:#6a9955">            Thread 1                        Thread 2</span></div><div><span style="color:#6a9955">    --------------------------------------------------------------</span></div><div><span style="color:#6a9955">    1.  int v = st.pop(); // 6</span></div><div><span style="color:#6a9955">    2.                                  int v = st.pop(); // 8</span></div><div><span style="color:#6a9955">    5.                                  process(v); // 80</span></div><div><span style="color:#6a9955">    6.  process(v); // 60</span></div><div><span style="color:#6a9955">    Thread safe - All element accessed once by either one of thread and processed only one time.</span></div></div></div></div><div><br /></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div style="line-height:22px"><div>    <span style="color:#569cd6">int</span> <span style="color:#dcdcaa">main</span>() {</div><div>        <span style="color:#4ec9b0">std</span>::thread <span style="color:#dcdcaa">t1</span>(function_1);<span style="color:#6a9955"> // t1 starts running</span></div><div>        <span style="color:#4ec9b0">std</span>::thread <span style="color:#dcdcaa">t2</span>(function_1);<span style="color:#6a9955"> // t2 starts running</span></div><div>        <span style="color:#9cdcfe">t2</span>.<span style="color:#dcdcaa">join</span>(); <span style="color:#9cdcfe">t1</span>.<span style="color:#dcdcaa">join</span>();</div><br /><div>        <span style="color:#4ec9b0">std</span>::thread <span style="color:#dcdcaa">t3</span>(function_2);<span style="color:#6a9955"> // t3 starts running</span></div><div>        <span style="color:#4ec9b0">std</span>::thread <span style="color:#dcdcaa">t4</span>(function_2);<span style="color:#6a9955"> // t4 starts running</span></div><div>        <span style="color:#9cdcfe">t4</span>.<span style="color:#dcdcaa">join</span>(); <span style="color:#9cdcfe">t3</span>.<span style="color:#dcdcaa">join</span>();</div><div>    }</div></div></div></div><div><br /></div><div><b>35. Deadlock (due to use of mutex):</b></div><div><div style="color:rgb(248,248,242);background-color:rgb(39,40,34);font-family:Consolas,Courier New,monospace;font-size:15px;line-height:20px;white-space:pre"><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-size:16px;line-height:22px"><div><span style="color:#6a9955">    // Ref: C++ Threading #4: Deadlock</span></div><div><span style="color:#6a9955">    // https://www.youtube.com/watch?v=_N0B5ua7oN8&amp;list=PL5jc9xFGsL8E12so1wlMS0r0hTQoJL74M&amp;index=5&amp;t=9s</span></div><div><span style="color:#569cd6">    </span><span style="color:#c586c0">#include</span><span style="color:#569cd6"> </span><span style="color:#ce9178">&lt;iostream&gt;</span></div><div><span style="color:#569cd6">    </span><span style="color:#c586c0">#include</span><span style="color:#569cd6"> </span><span style="color:#ce9178">&lt;string&gt;</span></div><div><span style="color:#569cd6">    </span><span style="color:#c586c0">#include</span><span style="color:#569cd6"> </span><span style="color:#ce9178">&lt;fstream&gt;</span><span style="color:#569cd6"> </span><span style="color:#6a9955">// ofstream f;</span></div><br /><div><span style="color:#569cd6">    </span><span style="color:#c586c0">#include</span><span style="color:#569cd6"> </span><span style="color:#ce9178">&lt;thread&gt;</span></div><div><span style="color:#569cd6">    </span><span style="color:#c586c0">#include</span><span style="color:#569cd6"> </span><span style="color:#ce9178">&lt;mutex&gt;</span></div><div>    <span style="color:#c586c0">using</span> <span style="color:#569cd6">namespace</span> <span style="color:#4ec9b0">std</span>;</div><br /><div>    <span style="color:#569cd6">class</span> <span style="color:#4ec9b0">LogFile</span> {</div><div>        <span style="color:#4ec9b0">std</span>::mutex <span style="color:#9cdcfe">_mu1</span>;</div><div>        <span style="color:#4ec9b0">std</span>::mutex <span style="color:#9cdcfe">_mu2</span>;</div><div>        <span style="color:#4ec9b0">ofstream</span> <span style="color:#9cdcfe">f</span>;</div><div>    <span style="color:#569cd6">public:</span></div><div>        <span style="color:#dcdcaa">LogFile</span>()  { <span style="color:#9cdcfe">f</span>.<span style="color:#dcdcaa">open</span>(<span style="color:#ce9178">"log.txt"</span>); }</div><div>        <span style="color:#dcdcaa">~LogFile</span>() { <span style="color:#9cdcfe">f</span>.<span style="color:#dcdcaa">close</span>(); }</div><br /><div>        <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">shared_print_log_1</span>(<span style="color:#4ec9b0">string</span> <span style="color:#9cdcfe">msg</span>, <span style="color:#569cd6">int</span> <span style="color:#9cdcfe">id</span>) {</div><div><span style="color:#6a9955">            // Consider a case we need more than one mutex to protect the shared data.</span></div><div><span style="color:#6a9955">            // Method 1:</span></div><div><span style="color:#6a9955">            // std::lock_guard&lt;std::mutex&gt; locker1(_mu1);</span></div><div><span style="color:#6a9955">            // std::lock_guard&lt;std::mutex&gt; locker2(_mu2);</span></div><br /><div><span style="color:#6a9955">            // Method 2:</span></div><div><span style="color:#6a9955">            // C++ library provides additional algorithms for deadlock avoidance in case of more than one mutex </span></div><div><span style="color:#6a9955">            // usage situations. </span></div><div>            <span style="color:#4ec9b0">std</span>::<span style="color:#dcdcaa">lock</span>(<span style="color:#9cdcfe">_mu1</span>, <span style="color:#9cdcfe">_mu2</span>); <span style="color:rgb(106,153,85)">// internally uses deadlock avoidance algorithm</span></div><div>            <span style="color:#4ec9b0">std</span>::lock_guard&lt;<span style="color:#4ec9b0">std</span>::mutex&gt; <span style="color:#dcdcaa">locker1</span>(<span style="color:#9cdcfe">_mu1</span>, <span style="color:#4ec9b0">std</span>::adopt_lock); <span style="color:rgb(106,153,85)">// already mutex is locked previously so</span></div><div>            <span style="color:#4ec9b0">std</span>::lock_guard&lt;<span style="color:#4ec9b0">std</span>::mutex&gt; <span style="color:#dcdcaa">locker2</span>(<span style="color:#9cdcfe">_mu2</span>, <span style="color:#4ec9b0">std</span>::adopt_lock); <span style="color:rgb(106,153,85)">// just adopt the ownership of that mutex</span></div><br /><div><span style="color:#6a9955">            // f &lt;&lt; msg &lt;&lt; id &lt;&lt; endl; </span></div><div>            <span style="color:#9cdcfe">cout</span> &lt;&lt; <span style="color:#9cdcfe">msg</span> &lt;&lt; <span style="color:#9cdcfe">id</span> &lt;&lt; <span style="color:#dcdcaa">endl</span>;</div><div>        }</div><br /><div>        <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">shared_print_log_2</span>(<span style="color:#4ec9b0">string</span> <span style="color:#9cdcfe">msg</span>, <span style="color:#569cd6">int</span> <span style="color:#9cdcfe">id</span>) {</div><div><span style="color:#6a9955">            // Method 1:</span></div><div><span style="color:#6a9955">            // Lock/unlock the mutuxes in the same order, otherwise classical DEADLOCK will happen.</span></div><div><span style="color:#6a9955">            // Problem: DEADLOCK - by Unordered way of Locking the mutuxes </span></div><div><span style="color:#6a9955">            // std::lock_guard&lt;std::mutex&gt; locker2(_mu2); </span></div><div><span style="color:#6a9955">            // std::lock_guard&lt;std::mutex&gt; locker1(_mu1); </span></div><br /><div><span style="color:#6a9955">            // Solution: NO DEADLOCK - locked the mutuxes in the same order like others</span></div><div><span style="color:#6a9955">            // std::lock_guard&lt;std::mutex&gt; locker1(_mu1); </span></div><div><span style="color:#6a9955">            // std::lock_guard&lt;std::mutex&gt; locker2(_mu2);</span></div><br /><div><span style="color:#6a9955">            // Method 2:</span></div><div>            <span style="color:#4ec9b0">std</span>::<span style="color:#dcdcaa">lock</span>(<span style="color:#9cdcfe">_mu1</span>, <span style="color:#9cdcfe">_mu2</span>);</div><div>            <span style="color:#4ec9b0">std</span>::lock_guard&lt;<span style="color:#4ec9b0">std</span>::mutex&gt; <span style="color:#dcdcaa">locker1</span>(<span style="color:#9cdcfe">_mu1</span>, <span style="color:#4ec9b0">std</span>::adopt_lock);</div><div>            <span style="color:#4ec9b0">std</span>::lock_guard&lt;<span style="color:#4ec9b0">std</span>::mutex&gt; <span style="color:#dcdcaa">locker2</span>(<span style="color:#9cdcfe">_mu2</span>, <span style="color:#4ec9b0">std</span>::adopt_lock);</div><br /><div><span style="color:#6a9955">            // f &lt;&lt; msg &lt;&lt; id &lt;&lt; endl; </span></div><div>            <span style="color:#9cdcfe">cout</span> &lt;&lt; <span style="color:#9cdcfe">msg</span> &lt;&lt; <span style="color:#9cdcfe">id</span> &lt;&lt; <span style="color:#dcdcaa">endl</span>;</div><div>        }</div><div>    };</div><br /><div><span style="color:#6a9955">    // Racing for 'file' access !!</span></div><div>    <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">function_log</span>(<span style="color:#4ec9b0">LogFile</span><span style="color:#569cd6">&amp;</span> <span style="color:#9cdcfe">log</span>) {</div><div><span style="color:#6a9955">        // file access is synchronous</span></div><div>        <span style="color:#c586c0">for</span> (<span style="color:#569cd6">int</span> <span style="color:#9cdcfe">i</span> = <span style="color:#b5cea8">0</span>; <span style="color:#9cdcfe">i</span> &gt; -<span style="color:#b5cea8">100</span>; --<span style="color:#9cdcfe">i</span>) <span style="color:#9cdcfe">log</span>.<span style="color:#dcdcaa">shared_print_log_1</span>(<span style="color:#4ec9b0">string</span>(<span style="color:#ce9178">"From t1: "</span>), <span style="color:#9cdcfe">i</span>);<span style="color:#6a9955"> // shared_print_log_1</span></div><div>    }</div><br /><div>    <span style="color:#569cd6">int</span> <span style="color:#dcdcaa">main</span>() {</div><div><span style="color:#6a9955">        // file shared access</span></div><div>        <span style="color:#4ec9b0">LogFile</span> <span style="color:#9cdcfe">log</span>;</div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">thread</span> <span style="color:#9cdcfe">t1</span>(<span style="color:#dcdcaa">function_log</span>, <span style="color:#4ec9b0">std</span>::<span style="color:#dcdcaa">ref</span>(<span style="color:#9cdcfe">log</span>));<span style="color:#6a9955"> // passing 'log' by reference</span></div><br /><div>        <span style="color:#c586c0">for</span> (<span style="color:#569cd6">int</span> <span style="color:#9cdcfe">i</span> = <span style="color:#b5cea8">0</span>; <span style="color:#9cdcfe">i</span> &lt; <span style="color:#b5cea8">100</span>; ++<span style="color:#9cdcfe">i</span>)</div><div>            <span style="color:#9cdcfe">log</span>.<span style="color:#dcdcaa">shared_print_log_2</span>(<span style="color:#4ec9b0">string</span>(<span style="color:#ce9178">"From main: "</span>), <span style="color:#9cdcfe">i</span>);<span style="color:#6a9955"> // shared_print_log_2</span></div><div>        <span style="color:#9cdcfe">t1</span>.<span style="color:#dcdcaa">join</span>();</div><div>    }</div></div></div></div><div><br /></div><div><div style="color:rgb(248,248,242);background-color:rgb(39,40,34);font-family:Consolas,Courier New,monospace;font-size:15px;line-height:20px;white-space:pre"><div>Avoiding deadlock:</div><div><span style="color:rgb(174,129,255)">1.</span> Prefer locking using a single mutex if possible.</div><div><span style="color:rgb(174,129,255)">2.</span> Avoid locking a mutex and then calling a user-provided function. User may lock another mutex inside their function.</div><div><span style="color:rgb(174,129,255)">3.</span> Use <span style="color:rgb(166,226,46)">std</span>::<span style="color:rgb(166,226,46)">lock</span>() to lock more than one mutex.</div><div><span style="color:rgb(174,129,255)">4.</span> Lock the mutex in the same order. Prefer hierarchical locking <span style="color:rgb(249,38,114)">-</span> lower level mutex will <span style="color:rgb(249,38,114)">NOT</span> lock the higher level mutex.</div><br /><div>Locking Granularity:</div><div>* Fine<span style="color:rgb(249,38,114)">-</span>grained lock:protects small amount of data but more possibilities of getting deadlock by <span style="color:rgb(249,38,114)">using</span> more no. of mutexes.</div><div>* Coarse<span style="color:rgb(249,38,114)">-</span>grained lock: protects big amount of data but loses the parallelism.</div></div></div><div><br /></div><div><b>36. Unique Lock:</b></div><div><div style="color:rgb(248,248,242);background-color:rgb(39,40,34);font-family:Consolas,Courier New,monospace;font-size:15px;line-height:20px;white-space:pre"><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-size:16px;line-height:22px"><div><span style="color:#6a9955">    // Ref: C++ Threading #5: Unique Lock and Lazy Initialization</span></div><div><span style="color:#6a9955">    // https://www.youtube.com/watch?v=IBu5ka1MQ7w&amp;list=PL5jc9xFGsL8E12so1wlMS0r0hTQoJL74M&amp;index=5</span></div><div><span style="color:#569cd6">    </span><span style="color:#c586c0">#include</span><span style="color:#569cd6"> </span><span style="color:#ce9178">&lt;iostream&gt;</span></div><div><span style="color:#569cd6">    </span><span style="color:#c586c0">#include</span><span style="color:#569cd6"> </span><span style="color:#ce9178">&lt;string&gt;</span></div><div><span style="color:#569cd6">    </span><span style="color:#c586c0">#include</span><span style="color:#569cd6"> </span><span style="color:#ce9178">&lt;fstream&gt;</span><span style="color:#569cd6"> </span><span style="color:#6a9955">// ofstream f;</span></div><br /><div><span style="color:#569cd6">    </span><span style="color:#c586c0">#include</span><span style="color:#569cd6"> </span><span style="color:#ce9178">&lt;thread&gt;</span></div><div><span style="color:#569cd6">    </span><span style="color:#c586c0">#include</span><span style="color:#569cd6"> </span><span style="color:#ce9178">&lt;mutex&gt;</span></div><div>    <span style="color:#c586c0">using</span> <span style="color:#569cd6">namespace</span> <span style="color:#4ec9b0">std</span>;</div><br /><div><span style="color:#6a9955">    // unique_lock - has more flexible methods but heavier than 'lock_guard'</span></div><br /><div>    <span style="color:#569cd6">class</span> <span style="color:#4ec9b0">LogFile</span></div><div>    {</div><div>        <span style="color:#4ec9b0">std</span>::mutex <span style="color:#9cdcfe">_mu1</span>;</div><div>        <span style="color:#4ec9b0">std</span>::mutex <span style="color:#9cdcfe">_mu2</span>;</div><div>        <span style="color:#4ec9b0">ofstream</span> <span style="color:#9cdcfe">f</span>;</div><br /><div>    <span style="color:#569cd6">public:</span></div><div>        <span style="color:#dcdcaa">LogFile</span>() { <span style="color:#9cdcfe">f</span>.<span style="color:#dcdcaa">open</span>(<span style="color:#ce9178">"log.txt"</span>); }</div><div>        <span style="color:#dcdcaa">~LogFile</span>() { <span style="color:#9cdcfe">f</span>.<span style="color:#dcdcaa">close</span>(); }</div><br /><div>        <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">shared_print_log_1</span>(<span style="color:#4ec9b0">string</span> <span style="color:#9cdcfe">msg</span>, <span style="color:#569cd6">int</span> <span style="color:#9cdcfe">id</span>)</div><div>        {</div><div><span style="color:#6a9955">            // lock_guard:</span></div><div><span style="color:#6a9955">            // std::lock_guard&lt;std::mutex&gt; locker1(_mu1); // RAII</span></div><div><span style="color:#6a9955">            // f &lt;&lt; msg &lt;&lt; id &lt;&lt; endl;</span></div><br /><div><span style="color:#6a9955">            // unique_lock:</span></div><div><span style="color:#6a9955">            // Method 1: RAII way of usage</span></div><div>            <span style="color:#4ec9b0">std</span>::unique_lock&lt;<span style="color:#4ec9b0">std</span>::mutex&gt; <span style="color:#dcdcaa">locker1</span>(<span style="color:#9cdcfe">_mu1</span>);</div><div>            <span style="color:#9cdcfe">f</span> <span style="color:#dcdcaa">&lt;&lt;</span> <span style="color:#9cdcfe">msg</span> &lt;&lt; <span style="color:#9cdcfe">id</span> &lt;&lt; <span style="color:#dcdcaa">endl</span>;</div><br /><div><span style="color:#6a9955">            // Method 2: Fine grained lock and unlock</span></div><div>            <span style="color:#4ec9b0">std</span>::unique_lock&lt;<span style="color:#4ec9b0">std</span>::mutex&gt; <span style="color:#dcdcaa">locker1</span>(<span style="color:#9cdcfe">_mu1</span>);</div><div>            <span style="color:#9cdcfe">f</span> <span style="color:#dcdcaa">&lt;&lt;</span> <span style="color:#9cdcfe">msg</span> &lt;&lt; <span style="color:#9cdcfe">id</span> &lt;&lt; <span style="color:#dcdcaa">endl</span>;</div><div>            <span style="color:#9cdcfe">locker1</span>.<span style="color:#dcdcaa">unlock</span>();</div><br /><div><span style="color:#6a9955">            // Method 3: Lock / Unlock arbitrarily number of times</span></div><div><span style="color:#6a9955">            // locker1 is the owner of mutex _mu1. But mutex haven't locked anything yet bcos 'defer_lock'.</span></div><div>            <span style="color:#4ec9b0">std</span>::unique_lock&lt;<span style="color:#4ec9b0">std</span>::mutex&gt; <span style="color:#dcdcaa">locker1</span>(<span style="color:#9cdcfe">_mu1</span>, <span style="color:#4ec9b0">std</span>::defer_lock);</div><div><span style="color:#6a9955">            // ......do some operations before doing lock ..........</span></div><div>            <span style="color:#9cdcfe">locker1</span>.<span style="color:#dcdcaa">lock</span>();<span style="color:#6a9955"> // Now mutex locked the resource</span></div><div>            <span style="color:#9cdcfe">f</span> <span style="color:#dcdcaa">&lt;&lt;</span> <span style="color:#9cdcfe">msg</span> &lt;&lt; <span style="color:#9cdcfe">id</span> &lt;&lt; <span style="color:#dcdcaa">endl</span>;</div><div>            <span style="color:#9cdcfe">locker1</span>.<span style="color:#dcdcaa">unlock</span>();</div><div><span style="color:#6a9955">            // ......do some operations before doing next time lock ..........</span></div><div>            <span style="color:#9cdcfe">locker1</span>.<span style="color:#dcdcaa">lock</span>();<span style="color:#6a9955"> // Now mutex locked the resource</span></div><div>            <span style="color:#9cdcfe">cout</span> &lt;&lt; <span style="color:#9cdcfe">msg</span> &lt;&lt; <span style="color:#9cdcfe">id</span> &lt;&lt; <span style="color:#dcdcaa">endl</span>;</div><div>            <span style="color:#9cdcfe">locker1</span>.<span style="color:#dcdcaa">unlock</span>();</div><br /><div><span style="color:#6a9955">            // Method 4: Both 'lock_guard' &amp; 'unique_lock' can't be copied. But unique_lock can be moved and </span></div><div><span style="color:#6a9955">            // 'lock_guard' </span><span style="color:rgb(106,153,85)">cann't move the ownership of mutex(_mu1) from locker1 to locker2</span></div><div>            <span style="color:#4ec9b0">std</span>::unique_lock&lt;<span style="color:#4ec9b0">std</span>::mutex&gt; locker2 = <span style="color:#4ec9b0">std</span>::<span style="color:#dcdcaa">move</span>(locker1);<span style="color:#6a9955"> // useful for passing lock to another function</span></div><div>        }</div><br /><div>        <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">shared_print_log_2</span>(<span style="color:#4ec9b0">string</span> <span style="color:#9cdcfe">msg</span>, <span style="color:#569cd6">int</span> <span style="color:#9cdcfe">id</span>)</div><div>        {</div><div><span style="color:#6a9955">            // Method 1:</span></div><div><span style="color:#6a9955">            // Lock the mutuxes in the same other like others, otherwise classical DEADLOCK will happen.</span></div><div><span style="color:#6a9955">            // Problem: DEADLOCK - by Unordered way of Locking the mutuxes</span></div><div><span style="color:#6a9955">            // std::lock_guard&lt;std::mutex&gt; locker2(_mu2);</span></div><div><span style="color:#6a9955">            // std::lock_guard&lt;std::mutex&gt; locker1(_mu1);</span></div><br /><div><span style="color:#6a9955">            // Solution: NO DEADLOCK - locked the mutuxes in the same order like others</span></div><div><span style="color:#6a9955">            // std::lock_guard&lt;std::mutex&gt; locker1(_mu1);</span></div><div><span style="color:#6a9955">            // std::lock_guard&lt;std::mutex&gt; locker2(_mu2);</span></div><br /><div><span style="color:#6a9955">            // Method 2:</span></div><div>            <span style="color:#4ec9b0">std</span>::<span style="color:#dcdcaa">lock</span>(<span style="color:#9cdcfe">_mu1</span>, <span style="color:#9cdcfe">_mu2</span>);</div><div>            <span style="color:#4ec9b0">std</span>::lock_guard&lt;<span style="color:#4ec9b0">std</span>::mutex&gt; <span style="color:#dcdcaa">locker1</span>(<span style="color:#9cdcfe">_mu1</span>, <span style="color:#4ec9b0">std</span>::adopt_lock);</div><div>            <span style="color:#4ec9b0">std</span>::lock_guard&lt;<span style="color:#4ec9b0">std</span>::mutex&gt; <span style="color:#dcdcaa">locker2</span>(<span style="color:#9cdcfe">_mu2</span>, <span style="color:#4ec9b0">std</span>::adopt_lock);</div><br /><div><span style="color:#6a9955">            // f &lt;&lt; msg &lt;&lt; id &lt;&lt; endl;</span></div><div>            <span style="color:#9cdcfe">cout</span> &lt;&lt; <span style="color:#9cdcfe">msg</span> &lt;&lt; <span style="color:#9cdcfe">id</span> &lt;&lt; <span style="color:#dcdcaa">endl</span>;</div><div>        }</div><div>    };</div><br /><div><span style="color:#6a9955">    // Racing for 'file' access !!</span></div><div>    <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">function_log</span>(<span style="color:#4ec9b0">LogFile</span> <span style="color:#569cd6">&amp;</span><span style="color:#9cdcfe">log</span>)</div><div>    {</div><div><span style="color:#6a9955">        // file access is synchronous</span></div><div>        <span style="color:#c586c0">for</span> (<span style="color:#569cd6">int</span> <span style="color:#9cdcfe">i</span> = <span style="color:#b5cea8">0</span>; <span style="color:#9cdcfe">i</span> &gt; -<span style="color:#b5cea8">100</span>; --<span style="color:#9cdcfe">i</span>)</div><div>            <span style="color:#9cdcfe">log</span>.<span style="color:#dcdcaa">shared_print_log_1</span>(<span style="color:#4ec9b0">string</span>(<span style="color:#ce9178">"From t1: "</span>), <span style="color:#9cdcfe">i</span>);<span style="color:#6a9955"> // shared_print_log_1</span></div><div>    }</div><br /><div>    <span style="color:#569cd6">int</span> <span style="color:#dcdcaa">main</span>()</div><div>    {</div><div><span style="color:#6a9955">        // file shared access</span></div><div>        <span style="color:#4ec9b0">LogFile</span> <span style="color:#9cdcfe">log</span>;</div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">thread</span> <span style="color:#9cdcfe">t1</span>(<span style="color:#dcdcaa">function_log</span>, <span style="color:#4ec9b0">std</span>::<span style="color:#dcdcaa">ref</span>(<span style="color:#9cdcfe">log</span>));<span style="color:#6a9955"> // passing 'log' by reference</span></div><br /><div>        <span style="color:#c586c0">for</span> (<span style="color:#569cd6">int</span> <span style="color:#9cdcfe">i</span> = <span style="color:#b5cea8">0</span>; <span style="color:#9cdcfe">i</span> &lt; <span style="color:#b5cea8">100</span>; ++<span style="color:#9cdcfe">i</span>)</div><div>            <span style="color:#9cdcfe">log</span>.<span style="color:#dcdcaa">shared_print_log_2</span>(<span style="color:#4ec9b0">string</span>(<span style="color:#ce9178">"From main: "</span>), <span style="color:#9cdcfe">i</span>);<span style="color:#6a9955"> // shared_print_log_2</span></div><div>        <span style="color:#9cdcfe">t1</span>.<span style="color:#dcdcaa">join</span>();</div><div>    }</div></div></div></div><div><br /></div><div><b>37. Lazy Initialization:</b></div><div><div style="color:rgb(248,248,242);background-color:rgb(39,40,34);font-family:Consolas,Courier New,monospace;font-size:15px;line-height:20px;white-space:pre"><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-size:16px;line-height:22px"><div><span style="color:#6a9955">    // Ref: C++ Threading #5: Lazy Initialization</span></div><div><span style="color:#6a9955">    // https://www.youtube.com/watch?v=IBu5ka1MQ7w&amp;list=PL5jc9xFGsL8E12so1wlMS0r0hTQoJL74M&amp;index=5</span></div><div><span style="color:#569cd6">    </span><span style="color:#c586c0">#include</span><span style="color:#569cd6"> </span><span style="color:#ce9178">&lt;iostream&gt;</span></div><div><span style="color:#569cd6">    </span><span style="color:#c586c0">#include</span><span style="color:#569cd6"> </span><span style="color:#ce9178">&lt;string&gt;</span></div><div><span style="color:#569cd6">    </span><span style="color:#c586c0">#include</span><span style="color:#569cd6"> </span><span style="color:#ce9178">&lt;fstream&gt;</span><span style="color:#569cd6"> </span><span style="color:#6a9955">// ofstream f;</span></div><br /><div><span style="color:#569cd6">    </span><span style="color:#c586c0">#include</span><span style="color:#569cd6"> </span><span style="color:#ce9178">&lt;thread&gt;</span></div><div><span style="color:#569cd6">    </span><span style="color:#c586c0">#include</span><span style="color:#569cd6"> </span><span style="color:#ce9178">&lt;mutex&gt;</span></div><div>    <span style="color:#c586c0">using</span> <span style="color:#569cd6">namespace</span> <span style="color:#4ec9b0">std</span>;</div><br /><div>    <span style="color:#4ec9b0">ofstream</span> <span style="color:#9cdcfe">f</span>;</div><div>    <span style="color:#4ec9b0">std</span>::mutex <span style="color:#9cdcfe">mu_file</span>;</div><div>    <span style="color:#4ec9b0">std</span>::mutex <span style="color:#9cdcfe">_mu1</span>;</div></div></div></div><div><br /></div><div><div style="color:rgb(248,248,242);background-color:rgb(39,40,34);font-family:Consolas,Courier New,monospace;font-size:15px;line-height:20px;white-space:pre"><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-size:16px;line-height:22px"><div><span style="color:#6a9955">    // Option 1 - Wrong</span></div><div>    <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">openFileOnce</span>() {</div><div><span style="color:#6a9955">            // Initialization Upon First Use Idiom / Lazy Initialization</span></div><div>            <span style="color:#c586c0">if</span>(<span style="color:#9cdcfe">f</span>.<span style="color:#dcdcaa">is_open</span>())</div><div>            {</div><div>                <span style="color:#9cdcfe">f</span>.<span style="color:#dcdcaa">open</span>(<span style="color:#ce9178">"log.txt"</span>);<span style="color:#6a9955"> // NOT thread safe so FILE will be opened twice</span></div><div>            }</div><div>    }</div></div></div></div><div><br /></div><div><div style="color:rgb(248,248,242);background-color:rgb(39,40,34);font-family:Consolas,Courier New,monospace;font-size:15px;line-height:20px;white-space:pre"><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-size:16px;line-height:22px"><div><span style="color:#6a9955">    // Option 2 - Wrong</span></div><div>    <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">openFileOnce</span>() {</div><div>            <span style="color:#c586c0">if</span>(<span style="color:#9cdcfe">f</span>.<span style="color:#dcdcaa">is_open</span>())<span style="color:#6a9955"> // This line is NOT thread safe so still FILE will be opened twice</span></div><div>            {</div><div>                <span style="color:#4ec9b0">std</span>::unique_lock&lt;mutex&gt; <span style="color:#dcdcaa">locker</span>(mu_file);</div><div>                <span style="color:#9cdcfe">f</span>.<span style="color:#dcdcaa">open</span>(<span style="color:#ce9178">"log.txt"</span>);</div><div>            }</div><div>    }</div></div></div></div><div><br /></div><div><div style="color:rgb(248,248,242);background-color:rgb(39,40,34);font-family:Consolas,Courier New,monospace;font-size:15px;line-height:20px;white-space:pre"><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-size:16px;line-height:22px"><div><span style="color:#6a9955">    // Option 3 - Wrong</span></div><div>    <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">openFileOnce</span>() {</div><div>        <span style="color:#4ec9b0">std</span>::unique_lock&lt;mutex&gt; <span style="color:#dcdcaa">locker</span>(mu_file);</div><div>        <span style="color:#c586c0">if</span>(<span style="color:#9cdcfe">f</span>.<span style="color:#dcdcaa">is_open</span>())<span style="color:#6a9955"> // File opened once. But every time it locks before doing the file open check(time consuming)</span></div><div>        {</div><div>            <span style="color:#9cdcfe">f</span>.<span style="color:#dcdcaa">open</span>(<span style="color:#ce9178">"log.txt"</span>);</div><div>        }</div><div>    }</div></div></div></div><div><br /></div><div><div style="color:rgb(248,248,242);background-color:rgb(39,40,34);font-family:Consolas,Courier New,monospace;font-size:15px;line-height:20px;white-space:pre"><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-size:16px;line-height:22px"><div><span style="color:#6a9955">    // Option 4 - Correct - C++ specifically provided for the above common problem</span></div><div>    <span style="color:#4ec9b0">std</span>::once_flag oFlag;<span style="color:#6a9955"> // instead of mutux use the standard library support of 'std::once_flag' &amp; 'std::call_once' flag</span></div><div>    <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">openFileOnce</span>() {</div><div><span style="color:#6a9955">        // File will be opened ONLY ONCE by ONE THREAD</span></div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#dcdcaa">call_once</span>(oFlag, [&amp;]() { <span style="color:#9cdcfe">f</span>.<span style="color:#dcdcaa">open</span>(<span style="color:#ce9178">"log.txt"</span>); }); <span style="color:rgb(106,153,85)">// lambda function called only once by one thread</span></div><div>    }</div></div></div></div><div><br /></div><div><div style="color:rgb(248,248,242);background-color:rgb(39,40,34);font-family:Consolas,Courier New,monospace;font-size:15px;line-height:20px;white-space:pre"><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-size:16px;line-height:22px"><div>    <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">shared_print</span>(<span style="color:#4ec9b0">string</span> <span style="color:#9cdcfe">msg</span>, <span style="color:#569cd6">int</span> <span style="color:#9cdcfe">id</span>) {</div><div>        <span style="color:#dcdcaa">openFileOnce</span>();<span style="color:#6a9955"> // OPEN file once - common file for all threads </span></div><div>        </div><div>        <span style="color:#4ec9b0">std</span>::unique_lock&lt;<span style="color:#4ec9b0">std</span>::mutex&gt; <span style="color:#dcdcaa">locker1</span>(_mu1); </div><div>        f &lt;&lt; msg &lt;&lt; id &lt;&lt; endl;</div><div>        <span style="color:#9cdcfe">locker1</span>.<span style="color:#dcdcaa">unlock</span>();</div><div><span style="color:#6a9955">        // do something</span></div><div>    }</div></div></div></div><div><br /></div><div><div style="color:rgb(248,248,242);background-color:rgb(39,40,34);font-family:Consolas,Courier New,monospace;font-size:15px;line-height:20px;white-space:pre"><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-size:16px;line-height:22px"><div><span style="color:#6a9955">    // Racing for 'cout' access!!</span></div><div>    <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">function_1</span>() {</div><div>        <span style="color:#c586c0">for</span>(<span style="color:#569cd6">int</span> i = <span style="color:#b5cea8">0</span>; i &gt; -<span style="color:#b5cea8">100</span>; --i) {</div><div><span style="color:#6a9955">            // cout&lt;&lt; "Fromt t1: " &lt;&lt; i &lt;&lt; endl;  // cout in asynchronous access</span></div><div>            <span style="color:#dcdcaa">shared_print</span>(<span style="color:#dcdcaa">string</span>(<span style="color:#ce9178">"From t1: "</span>), i);<span style="color:#6a9955"> // cout in synchronous access</span></div><div>        }</div><div>    }</div></div></div></div><div><br /></div><div><div style="color:rgb(248,248,242);background-color:rgb(39,40,34);font-family:Consolas,Courier New,monospace;font-size:15px;line-height:20px;white-space:pre"><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-size:16px;line-height:22px"><div>    <span style="color:#569cd6">int</span> <span style="color:#dcdcaa">main</span>() {</div><div><span style="color:#6a9955">        // cout shared access</span></div><div>        <span style="color:#4ec9b0">std</span>::thread <span style="color:#dcdcaa">t1</span>(function_1);<span style="color:#6a9955"> // t1 starts running</span></div><br /><div>        <span style="color:#c586c0">for</span>(<span style="color:#569cd6">int</span> i = <span style="color:#b5cea8">0</span>; i &lt; <span style="color:#b5cea8">100</span>; ++i) {</div><div><span style="color:#6a9955">            // cout&lt;&lt; "Fromt main: " &lt;&lt; i &lt;&lt; endl;  // cout in asynchronous access</span></div><div>            <span style="color:#dcdcaa">shared_print</span>(<span style="color:#dcdcaa">string</span>(<span style="color:#ce9178">"From main: "</span>), i);<span style="color:#6a9955"> // cout in synchronous access</span></div><div>        }</div><div>        <span style="color:#9cdcfe">t1</span>.<span style="color:#dcdcaa">join</span>();</div><div>    }</div></div></div></div><div><br /></div><div><b>38. Condition Variable:</b></div><div><div style="color:rgb(248,248,242);background-color:rgb(39,40,34);font-family:Consolas,Courier New,monospace;font-size:15px;line-height:20px;white-space:pre"><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-size:16px;line-height:22px"><div><span style="color:#6a9955">    // Ref: C++ Threading #6: Condition Variable</span></div><div><span style="color:#6a9955">    // https://www.youtube.com/watch?v=13dFggo4t_I&amp;list=PL5jc9xFGsL8E12so1wlMS0r0hTQoJL74M&amp;index=7&amp;t=0s</span></div><div><span style="color:#569cd6">    </span><span style="color:#c586c0">#include</span><span style="color:#569cd6"> </span><span style="color:#ce9178">&lt;iostream&gt;</span></div><div><span style="color:#569cd6">    </span><span style="color:#c586c0">#include</span><span style="color:#569cd6"> </span><span style="color:#ce9178">&lt;string&gt;</span></div><div><span style="color:#569cd6">    </span><span style="color:#c586c0">#include</span><span style="color:#569cd6"> </span><span style="color:#ce9178">&lt;deque&gt;</span></div><div><span style="color:#569cd6">    </span><span style="color:#c586c0">#include</span><span style="color:#569cd6"> </span><span style="color:#ce9178">&lt;fstream&gt;</span><span style="color:#569cd6"> </span><span style="color:#6a9955">// ofstream f;</span></div><br /><div><span style="color:#569cd6">    </span><span style="color:#c586c0">#include</span><span style="color:#569cd6"> </span><span style="color:#ce9178">&lt;thread&gt;</span></div><div><span style="color:#569cd6">    </span><span style="color:#c586c0">#include</span><span style="color:#569cd6"> </span><span style="color:#ce9178">&lt;mutex&gt;</span></div><div><span style="color:#569cd6">    </span><span style="color:#c586c0">#include</span><span style="color:#569cd6"> </span><span style="color:#ce9178">&lt;condition_variable&gt;</span></div><div>    <span style="color:#c586c0">using</span> <span style="color:#569cd6">namespace</span> <span style="color:#4ec9b0">std</span>;</div><br /><div>    <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">deque</span>&lt;<span style="color:#569cd6">int</span>&gt; <span style="color:#9cdcfe">q</span>;</div><div>    <span style="color:#4ec9b0">std</span>::mutex <span style="color:#9cdcfe">mu</span>;</div></div></div></div><div><br /></div><div><div style="color:rgb(248,248,242);background-color:rgb(39,40,34);font-family:Consolas,Courier New,monospace;font-size:15px;line-height:20px;white-space:pre"><span style="color:rgb(117,113,94)"><span>    </span>// Producer &amp; Consumer - Option 1 - WRONG (without CV - uses only mutexes)</span></div></div><div><br /></div><div><div style="color:rgb(248,248,242);background-color:rgb(39,40,34);font-family:Consolas,Courier New,monospace;font-size:15px;line-height:20px;white-space:pre"><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-size:16px;line-height:22px"><div>    <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">producer</span>() {<span style="color:#6a9955"> // Producer Thread</span></div><div>        <span style="color:#569cd6">int</span> count = <span style="color:#b5cea8">10</span>;</div><div>        <span style="color:#c586c0">while</span> (count &gt; <span style="color:#b5cea8">0</span>) {</div><div>            <span style="color:#4ec9b0">std</span>::unique_lock&lt;mutex&gt; <span style="color:#dcdcaa">locker</span>(mu);</div><div>            <span style="color:#9cdcfe">q</span>.<span style="color:#dcdcaa">push_front</span>(count); </div><div>            <span style="color:#9cdcfe">locker</span>.<span style="color:#dcdcaa">unlock</span>();</div><div>            <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">this_thread</span>::<span style="color:#dcdcaa">sleep_for</span>(<span style="color:#4ec9b0">chrono</span>::<span style="color:#dcdcaa">seconds</span>(<span style="color:#b5cea8">1</span>));</div><div>            count--;</div><div>        }</div><div>    }</div></div></div></div><div><br /></div><div><div style="color:rgb(248,248,242);background-color:rgb(39,40,34);font-family:Consolas,Courier New,monospace;font-size:15px;line-height:20px;white-space:pre"><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-size:16px;line-height:22px"><div>    <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">consumer</span>() {<span style="color:#6a9955"> // Consumer Thread</span></div><div>        <span style="color:#569cd6">int</span> data = <span style="color:#b5cea8">0</span>;</div><div>        <span style="color:#c586c0">while</span> (data != <span style="color:#b5cea8">1</span>)<span style="color:#6a9955"> // BUSY WAITING  and sleep_for(9ms) - NOT GOOD!</span></div><div>        {</div><div>            <span style="color:#4ec9b0">std</span>::unique_lock&lt;mutex&gt; <span style="color:#dcdcaa">locker</span>(mu);</div><div>            <span style="color:#c586c0">if</span> (!<span style="color:#9cdcfe">q</span>.<span style="color:#dcdcaa">empty</span>()) {</div><div>                data = <span style="color:#9cdcfe">q</span>.<span style="color:#dcdcaa">back</span>();</div><div>                <span style="color:#9cdcfe">q</span>.<span style="color:#dcdcaa">pop_back</span>();</div><div>                <span style="color:#9cdcfe">locker</span>.<span style="color:#dcdcaa">unlock</span>();</div><div>                cout &lt;&lt; <span style="color:#ce9178">"t2 got a value from t1: "</span> &lt;&lt; data &lt;&lt; endl;</div><div>            }</div><div>            <span style="color:#c586c0">else</span> {</div><div>                <span style="color:#9cdcfe">locker</span>.<span style="color:#dcdcaa">unlock</span>();</div><div>            }</div><div><span style="color:#6a9955">            // sleep for some seconds will reduce the BUSY WAIT.</span></div><div><span style="color:#6a9955">            // But it is hard to find how many sec to sleep(may become over-sleep / short-sleep)</span></div><div>            <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">this_thread</span>::<span style="color:#dcdcaa">sleep_for</span>(<span style="color:#4ec9b0">chrono</span>::<span style="color:#dcdcaa">milliseconds</span>(<span style="color:#b5cea8">9</span>));</div><div>        }</div><div>    }</div></div></div></div><div><br /></div><div><div style="color:rgb(248,248,242);background-color:rgb(39,40,34);font-family:Consolas,Courier New,monospace;font-size:15px;line-height:20px;white-space:pre"><span style="color:rgb(117,113,94)"><span>    </span>// Producer &amp; Consumer - Option 2 - CORRECT (with CV)</span></div></div><div><br /></div><div><div style="color:rgb(248,248,242);background-color:rgb(39,40,34);font-family:Consolas,Courier New,monospace;font-size:15px;line-height:20px;white-space:pre"><span style="color:rgb(166,226,46)"><span>    </span>std</span>::condition_variable cond; <span style="color:rgb(117,113,94)">// synchronize the excution sequence of the threads</span></div></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div>    <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">producer</span>() {<span style="color:#6a9955"> // Producer Thread</span></div><div>        <span style="color:#569cd6">int</span> count = <span style="color:#b5cea8">10</span>;</div><div>        <span style="color:#c586c0">while</span> (count &gt; <span style="color:#b5cea8">0</span>) {</div><div>            <span style="color:#4ec9b0">std</span>::unique_lock&lt;mutex&gt; <span style="color:#dcdcaa">locker</span>(mu);</div><div>            <span style="color:#9cdcfe">q</span>.<span style="color:#dcdcaa">push_front</span>(count);</div><div>            <span style="color:#9cdcfe">locker</span>.<span style="color:#dcdcaa">unlock</span>();</div><div>            <span style="color:#9cdcfe">cond</span>.<span style="color:#dcdcaa">notify_one</span>();<span style="color:#6a9955">    // NOTIFY/WAKE-UP one waiting thread, if there is one.</span></div><div><span style="color:#6a9955">            // cond.notify_all(); // If you want to NOTIFY/WAKE-UP all the waiting threads</span></div><div>            <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">this_thread</span>::<span style="color:#dcdcaa">sleep_for</span>(<span style="color:#4ec9b0">chrono</span>::<span style="color:#dcdcaa">seconds</span>(<span style="color:#b5cea8">1</span>));</div><div>            count--;</div><div>        }</div><div>    }</div></div></div><div><br /></div><div><div style="color:rgb(248,248,242);background-color:rgb(39,40,34);font-family:Consolas,Courier New,monospace;font-size:15px;line-height:20px;white-space:pre"><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-size:16px;line-height:22px"><div>    <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">consumer</span>() {<span style="color:#6a9955"> // Consumer Thread</span></div><div>        <span style="color:#569cd6">int</span> data = <span style="color:#b5cea8">0</span>;</div><div>        <span style="color:#c586c0">while</span> (data != <span style="color:#b5cea8">1</span>)<span style="color:#6a9955"> // It is NOT busy wait bcos CV usage and also there is NO need for sleep_for(9ms)</span></div><div>        {</div><div><span style="color:rgb(106,153,85)">            // we need to explicitly lock/unlock many times so do NOT use lock_gurad </span></div><div>            <span style="color:#4ec9b0">std</span>::unique_lock&lt;mutex&gt; <span style="color:#dcdcaa">locker</span>(mu); </div><br /><div><span style="color:#6a9955">            // Wait until it gets notification / wake up call.</span></div><div><span style="color:#6a9955">            // Before goes to wait, mutex is unlocked internally and then locked again once it </span></div><div><span style="color:#6a9955">            // gets the notification (internal lock/unlock). We can't use 'lock_guard' in this case.</span></div><div>            </div><div><span style="color:#6a9955">            // cond.wait(locker); // possibilities for SPURIOUS WAKE UP(thread wakeup itself) so need some extra </span></div><div><span style="color:#6a9955">                                  // conditon by lamda function.</span></div><div>            <span style="color:#9cdcfe">cond</span>.<span style="color:#dcdcaa">wait</span>(locker, []() { <span style="color:#c586c0">return</span> !<span style="color:#9cdcfe">q</span>.<span style="color:#dcdcaa">empty</span>(); });<span style="color:#6a9955"> // NO need to wait if lamda condition returns true</span></div><br /><div><span style="color:#6a9955">            // if (!q.empty()) {   // use it in a lambda function instead</span></div><div>                data = <span style="color:#9cdcfe">q</span>.<span style="color:#dcdcaa">back</span>();</div><div>                <span style="color:#9cdcfe">q</span>.<span style="color:#dcdcaa">pop_back</span>();</div><div>                <span style="color:#9cdcfe">locker</span>.<span style="color:#dcdcaa">unlock</span>();</div><div>                cout &lt;&lt; <span style="color:#ce9178">"t2 got a value from t1: "</span> &lt;&lt; data &lt;&lt; endl;</div><div><span style="color:#6a9955">            /*</span></div><div><span style="color:#6a9955">            }</span></div><div><span style="color:#6a9955">            else {</span></div><div><span style="color:#6a9955">                locker.unlock();</span></div><div><span style="color:#6a9955">            }</span></div><div><span style="color:#6a9955"><br /></span></div><div><span style="color:#6a9955">            // No need to sleep for reducing the busy-wait like below.</span></div><div><span style="color:#6a9955"><br /></span></div><div><span style="color:#6a9955">            // sleep for some seconds will reduce the BUSY WAIT.</span></div><div><span style="color:#6a9955">            // But it is hard to find how many sec to sleep(may become over-sleep / short-sleep)</span></div><div><span style="color:#6a9955">            std::this_thread::sleep_for(chrono::milliseconds(9));</span></div><div><span style="color:#6a9955">            */</span></div><div>        }</div><div>    }</div></div></div></div><div><br /></div><div><div style="color:rgb(248,248,242);background-color:rgb(39,40,34);font-family:Consolas,Courier New,monospace;font-size:15px;line-height:20px;white-space:pre"><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-size:16px;line-height:22px"><div>    <span style="color:#569cd6">int</span> <span style="color:#dcdcaa">main</span>() {</div><div>        <span style="color:#4ec9b0">std</span>::thread <span style="color:#dcdcaa">t1</span>(producer);</div><div>        <span style="color:#4ec9b0">std</span>::thread <span style="color:#dcdcaa">t2</span>(consumer);</div><div>        <span style="color:#9cdcfe">t1</span>.<span style="color:#dcdcaa">join</span>();</div><div>        <span style="color:#9cdcfe">t2</span>.<span style="color:#dcdcaa">join</span>();</div><div>        <span style="color:#c586c0">return</span> <span style="color:#b5cea8">0</span>;</div><div>    }</div></div></div></div><div><br /></div><div><b>39. Future, Promise and async():</b></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div>    <span style="color:#569cd6">int</span> <span style="color:#dcdcaa">squareThread</span>(<span style="color:#569cd6">int</span> <span style="color:#9cdcfe">N</span>) {</div><div>        <span style="color:#c586c0">return</span> N * N;<span style="color:#6a9955">    // child =&gt; parent</span></div><div>    }</div><br /><div>    <span style="color:#569cd6">int</span> <span style="color:#dcdcaa">multiplyThread</span>(<span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">future</span>&lt;<span style="color:#569cd6">int</span>&gt;<span style="color:#569cd6">&amp;</span> <span style="color:#9cdcfe">f</span>, <span style="color:#569cd6">int</span> <span style="color:#9cdcfe">M</span>) {</div><div>        <span style="color:#569cd6">int</span> N = <span style="color:#9cdcfe">f</span>.<span style="color:#dcdcaa">get</span>();<span style="color:#6a9955"> // child &lt;= parent</span></div><div>        <span style="color:#c586c0">return</span> M * N;<span style="color:#6a9955">    // child =&gt; parent</span></div><div>    }</div><br /><div>    <span style="color:#569cd6">int</span> <span style="color:#dcdcaa">main</span>() {</div><div><span style="color:#6a9955">        // 1. future result value from child =&gt; parent</span></div><div>        <span style="color:#4ec9b0">std</span>::future&lt;<span style="color:#569cd6">int</span>&gt; fu = <span style="color:#4ec9b0">std</span>::<span style="color:#dcdcaa">async</span>(<span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">launch</span>::async, squareThread, <span style="color:#b5cea8">5</span>);<span style="color:#6a9955"> //f is MOVED not copied</span></div><div>        <span style="color:#569cd6">int</span> result = <span style="color:#9cdcfe">fu</span>.<span style="color:#dcdcaa">get</span>();<span style="color:#6a9955"> // child =&gt; parent. get future result from </span></div><div>        cout &lt;&lt; <span style="color:#ce9178">"Get from Child: "</span> &lt;&lt; result &lt;&lt; endl;<span style="color:#6a9955"> // 25</span></div><br /><div><span style="color:#6a9955">        // 1. future argument value from parent =&gt; child  (Need explicit promise in pararent)</span></div><div><span style="color:#6a9955">        // 2. future return value from child =&gt; parent</span></div><div>        <span style="color:#4ec9b0">std</span>::promise&lt;<span style="color:#569cd6">int</span>&gt; p;</div><div>        <span style="color:#4ec9b0">std</span>::future&lt;<span style="color:#569cd6">int</span>&gt; f = <span style="color:#9cdcfe">p</span>.<span style="color:#dcdcaa">get_future</span>();<span style="color:#6a9955"> // need it for sending future arg from parent =&gt; child</span></div><div>        <span style="color:#4ec9b0">std</span>::future&lt;<span style="color:#569cd6">int</span>&gt; fu = <span style="color:#4ec9b0">std</span>::<span style="color:#dcdcaa">async</span>(<span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">launch</span>::async, multiplyThread, <span style="color:#4ec9b0">std</span>::<span style="color:#dcdcaa">ref</span>(f), <span style="color:#b5cea8">5</span>);<span style="color:#6a9955"> //f is MOVED not copied</span></div><br /><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">this_thread</span>::<span style="color:#dcdcaa">sleep_for</span>(<span style="color:#4ec9b0">chrono</span>::<span style="color:#dcdcaa">milliseconds</span>(<span style="color:#b5cea8">20</span>));<span style="color:#6a9955">   // do something else for some time</span></div><div>        <span style="color:#9cdcfe">p</span>.<span style="color:#dcdcaa">set_value</span>(<span style="color:#b5cea8">4</span>);<span style="color:#6a9955"> // sending future arg from parent =&gt; child</span></div><br /><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">this_thread</span>::<span style="color:#dcdcaa">sleep_for</span>(<span style="color:#4ec9b0">chrono</span>::<span style="color:#dcdcaa">milliseconds</span>(<span style="color:#b5cea8">20</span>));<span style="color:#6a9955"> // do something else for some time</span></div><div>        <span style="color:#569cd6">int</span> result = <span style="color:#9cdcfe">fu</span>.<span style="color:#dcdcaa">get</span>();<span style="color:#6a9955"> // get future result from child =&gt; parent</span></div><br /><div>        cout &lt;&lt; <span style="color:#ce9178">"Get from Child: "</span> &lt;&lt; result &lt;&lt; endl;<span style="color:#6a9955"> // 20</span></div><div>    }</div></div></div><div><br /></div><div><b>More examples:</b></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div style="line-height:22px"><div><span style="color:#6a9955">    // Ref: C++ Threading #7: Future, Promise and async()</span></div><div><span style="color:#6a9955">    // https://www.youtube.com/watch?v=SZQ6-pf-5Us&amp;list=PL5jc9xFGsL8E12so1wlMS0r0hTQoJL74M&amp;index=7</span></div><div><span style="color:#569cd6">    </span><span style="color:#c586c0">#include</span><span style="color:#569cd6"> </span><span style="color:#ce9178">&lt;iostream&gt;</span></div><div><span style="color:#569cd6">    </span><span style="color:#c586c0">#include</span><span style="color:#569cd6"> </span><span style="color:#ce9178">&lt;future&gt;</span><span style="color:#569cd6"> </span><span style="color:#6a9955">// thread, promise, future, async, call_once</span></div><div>    <span style="color:#c586c0">using</span> <span style="color:#569cd6">namespace</span> <span style="color:#4ec9b0">std</span>;</div><br /><div><span style="color:#6a9955">    // Old method: Return value - by Thread function: INDIRECTLY put the result in the shared memory location</span></div><div>    <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">squareReference</span>(<span style="color:#569cd6">int</span> <span style="color:#9cdcfe">N</span>, <span style="color:#569cd6">int&amp;</span> <span style="color:#9cdcfe">r</span>) {</div><div>        <span style="color:#569cd6">int</span> <span style="color:#9cdcfe">res</span> = <span style="color:#9cdcfe">N</span> * <span style="color:#9cdcfe">N</span>;</div><div>        <span style="color:#9cdcfe">r</span> = <span style="color:#9cdcfe">res</span>;</div><div>    }</div></div></div></div><div><br /></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div style="line-height:22px"><div><span style="color:#6a9955">    // async method: Return value - by Thread function: DIRECTLY returns value</span></div><div>    <span style="color:#569cd6">int</span> <span style="color:#dcdcaa">squareFuture</span>(<span style="color:#569cd6">int</span> <span style="color:#9cdcfe">N</span>) {</div><div>        <span style="color:#569cd6">int</span> res = N * N;</div><div>        <span style="color:#c586c0">return</span> res; <span style="color:rgb(106,153,85)">// child =&gt; parent</span></div><div>    }</div></div></div></div><div><br /></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div style="line-height:22px"><div><span style="color:#6a9955">    // Thread function get the input param from the parent thread through FUTURE and returns the calculated value.</span></div><div><span style="color:#6a9955">    // Again parent thread capture the result returned by a child thread through FUTURE.</span></div><div>    <span style="color:#569cd6">int</span> <span style="color:#dcdcaa">squareFuturePromise</span>(<span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">future</span>&lt;<span style="color:#569cd6">int</span>&gt;<span style="color:#569cd6">&amp;</span> <span style="color:#9cdcfe">f</span>) {</div><div>        <span style="color:#569cd6">int</span> N = <span style="color:#9cdcfe">f</span>.<span style="color:#dcdcaa">get</span>();<span style="color:#6a9955"> // child &lt;= parent. Wait until you get a value from the parent thread </span></div><div><span style="color:#6a9955">        // if parent broke the promise by not sending any value then throw EXCEPTION: std::future_errc::broken_promise</span></div><br /><div>        <span style="color:#569cd6">int</span> res = N * N;</div><div>        <span style="color:#c586c0">return</span> res; <span style="color:rgb(106,153,85)">// child =&gt; parent</span></div><div>    }</div></div></div></div><div><br /></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div style="line-height:22px"><div><span style="color:#6a9955">    // Thread function get the input param through SHARED FUTURE and returns the calculated value</span></div><div>    <span style="color:#569cd6">int</span> <span style="color:#dcdcaa">squareSharedFuturePromise</span>(<span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">shared_future</span>&lt;<span style="color:#569cd6">int</span>&gt; <span style="color:#9cdcfe">f</span>) { <span style="color:rgb(106,153,85)">// &amp; NOT needed bcos it is NOT movable</span></div><div>        <span style="color:#569cd6">int</span> N = <span style="color:#9cdcfe">f</span>.<span style="color:#dcdcaa">get</span>();</div><br /><div>        <span style="color:#569cd6">int</span> res = N * N;</div><div>        <span style="color:#c586c0">return</span> res;</div><div>    }</div></div></div></div><div><br /></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div style="line-height:22px"><div>    <span style="color:#569cd6">int</span> <span style="color:#dcdcaa">main</span>() {</div><div>        <span style="color:#569cd6">int</span> num = <span style="color:#b5cea8">4</span>;</div><div>        <span style="color:#569cd6">int</span> result;</div><br /><div><span style="color:#6a9955">        // Method: 1</span></div><div>        <span style="color:#4ec9b0">std</span>::thread <span style="color:#dcdcaa">t1</span>(squareReference, num, <span style="color:#4ec9b0">std</span>::<span style="color:#dcdcaa">ref</span>(result));<span style="color:#6a9955"> // result variable is shared b/w parent and child threads</span></div><div>        <span style="color:#9cdcfe">t1</span>.<span style="color:#dcdcaa">join</span>();</div><div>        cout&lt;&lt; <span style="color:#ce9178">"Calculated result and stored in shared location by a Child thread: "</span> &lt;&lt; result &lt;&lt; endl;</div><br /><div><span style="color:#6a9955">        // Method 2:</span></div><div><span style="color:#6a9955">        // Use std::async 'function' to create a thread.</span></div><div><span style="color:#6a9955">        // async is a 'function', not a class that creates and launch a thread and then it returns the 'future' object</span></div><div><span style="color:#6a9955">        // from the launched thread. NOTE: std::thread and std::future are class not a function.</span></div><div>        <span style="color:#4ec9b0">std</span>::future&lt;<span style="color:#569cd6">int</span>&gt; fu = <span style="color:#4ec9b0">std</span>::<span style="color:#dcdcaa">async</span>(squareFuture, num); <span style="color:rgb(106,153,85)">// C++ may/not create a new thread</span></div><div><span style="color:#6a9955">//std::future&lt;int&gt; fu = std::async(std::launch::deferred | std::launch::async, squareFuture, num);//SAME as above.</span></div><div><span style="color:#6a9955">                                // std::launch::deferred | std::launch::async - is a DEFAULT value.</span></div><div><span style="color:rgb(106,153,85)">// std::launch::deferred =&gt; NOT create a new thread; </span><span style="color:rgb(106,153,85)">std::launch::async =&gt; Creates a new thread.</span></div><br /><div><span style="color:#6a9955">        // wait until the child finish it's execution and get the returned value from the child thread</span></div><div>        result = <span style="color:#9cdcfe">fu</span>.<span style="color:#dcdcaa">get</span>();<span style="color:#6a9955"> // parent &lt;= child. NOTE: It should be called only once.</span></div><div><span style="color:#6a9955">        // fu.get();       // CRASH</span></div><div>        cout&lt;&lt; <span style="color:#ce9178">"Get from Child: "</span> &lt;&lt; result &lt;&lt; endl;</div><br /><div><span style="color:#6a9955">        // Method 3: std::launch::deferred - will NOT create a thread. Call the thread function using the </span></div><div><span style="color:#6a9955">        // current thread when there is an explicit request by fu.get().</span></div><div>        <span style="color:#4ec9b0">std</span>::future&lt;<span style="color:#569cd6">int</span>&gt; fu = <span style="color:#4ec9b0">std</span>::<span style="color:#dcdcaa">async</span>(<span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">launch</span>::deferred, squareFuture, num);<span style="color:#6a9955"> // Thread will NOT be created.</span></div><div>        <span style="color:#9cdcfe">result</span> = <span style="color:#9cdcfe">fu</span>.<span style="color:#dcdcaa">get</span>();<span style="color:#6a9955"> // 'squareFuture' will be called by the current thread (not by a new thread)</span></div><div>        <span style="color:#9cdcfe">cout</span>&lt;&lt; <span style="color:#ce9178">"Get from Child: "</span> &lt;&lt; result &lt;&lt; endl;</div><br /><div><span style="color:#6a9955">        // Method 4:std::launch::async - Thread will be created.</span></div><div>        <span style="color:#9cdcfe">std</span><span style="color:#9cdcfe">::f</span>uture&lt;<span style="color:#569cd6">int</span>&gt; fu = <span style="color:#4ec9b0">std</span>::<span style="color:#dcdcaa">async</span>(<span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">launch</span>::async, squareFuture, num);<span style="color:#6a9955"> // Thread will be created.</span></div><div>        <span style="color:#9cdcfe">result</span> = <span style="color:#9cdcfe">fu</span>.<span style="color:#dcdcaa">get</span>();</div><div>        <span style="color:#9cdcfe">cout</span>&lt;&lt; <span style="color:#ce9178">"Get from Child: "</span> &lt;&lt; result &lt;&lt; endl;</div><br /><div><span style="color:#6a9955">        // Method 5:</span></div><div><span style="color:#6a9955">std::async =&gt; OK to retun value from child to parent threads. But you can NOT pass a value from parent to child </span></div><div><span style="color:#6a9955">thread after asyn </span><span style="color:rgb(106,153,85)">creation. i.e, Sending future value from parent to child thread is NOT allowed after std::async.</span></div><div><span style="color:rgb(106,153,85)">solution:</span></div><div><span style="color:#6a9955">std::promise =&gt; is Needed to pass the future value from parent to child thread after std::async creation.</span></div><div><span style="color:#6a9955"><br /></span></div><div><span style="color:#6a9955">        //   a). PASS input parameter to child thread sometimes after the child thread creation by PROMISE and FUTURE.</span></div><div><span style="color:#6a9955">        //   b). GET the result from the child thread using FUTURE.</span></div><div>        <span style="color:#9cdcfe">std</span><span style="color:#9cdcfe">::pr</span>omise&lt;<span style="color:#569cd6">int</span>&gt; p;<span style="color:#6a9955"> // NOTE: both future &amp; promise are only MOVED 'not' COPIED.</span></div><div>        <span style="color:#9cdcfe">std</span><span style="color:#9cdcfe">::f</span>uture&lt;<span style="color:#569cd6">int</span>&gt; f = <span style="color:#9cdcfe">p</span>.<span style="color:#dcdcaa">get_future</span>();</div><div><span style="color:#6a9955">        // do a promise to the child thread that the parent thread will send the input param sometime later.</span></div><div>        <span style="color:#9cdcfe">std</span><span style="color:#9cdcfe">::f</span>uture&lt;<span style="color:#569cd6">int</span>&gt; fu = <span style="color:#4ec9b0">std</span>::<span style="color:#dcdcaa">async</span>(<span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">launch</span>::async, squareFuturePromise, <span style="color:#4ec9b0">std</span>::<span style="color:#dcdcaa">ref</span>(f));<span style="color:#6a9955">//f is MOVED not copied</span></div><div>        </div><div><span style="color:#6a9955">        // do something else for some time</span></div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">this_thread</span>::<span style="color:#9cdcfe">sleep_for</span>(<span style="color:#4ec9b0">chrono</span>::<span style="color:#4ec9b0">milliseconds</span>(<span style="color:#b5cea8">20</span>));</div><br /><div>        <span style="color:#9cdcfe">p</span>.<span style="color:#dcdcaa">set_value</span>(<span style="color:#b5cea8">4</span>);<span style="color:#6a9955"> // parent =&gt; child. NOW pass a value to already created thread</span></div><div><span style="color:#6a9955">        // In case you can't have a value to send to an already created and already promised thread. </span></div><div><span style="color:#6a9955">        // Notify your situation and catch the EXCEPTION.</span></div><div><span style="color:#6a9955">        // p.set_exception(std::make_exception_ptr(std::runtime_error("Sorry, I cann't send any input - I'm breaking </span></div><div><span style="color:#6a9955">        // my promise")));</span></div><br /><div><span style="color:#6a9955">        // do something else for some time</span></div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">this_thread</span>::<span style="color:#9cdcfe">sleep_for</span>(<span style="color:#4ec9b0">chrono</span>::<span style="color:#4ec9b0">milliseconds</span>(<span style="color:#b5cea8">20</span>));</div><br /><div>        <span style="color:#9cdcfe">result</span> = <span style="color:#9cdcfe">fu</span>.<span style="color:#dcdcaa">get</span>();</div><div>        <span style="color:#9cdcfe">cout</span>&lt;&lt; <span style="color:#ce9178">"Get from Child: "</span> &lt;&lt; result &lt;&lt; endl;</div><br /><div><span style="color:#6a9955">        // Method 6: pass the SAME input parameter to MULTIPLE THREADS using A SHARED FUTURE instead of creating </span></div><div><span style="color:#6a9955">        //           multiple FUTURE. FUTURE - Can NOT be copied but MOVED. SHARED FUTURE - CAN be copied (shared).</span></div><div>        <span style="color:#9cdcfe">std</span><span style="color:#9cdcfe">::pr</span>omise&lt;<span style="color:#569cd6">int</span>&gt; p;<span style="color:#6a9955"> // NOTE: both future &amp; promise are only MOVED 'not' COPIED.</span></div><div>        <span style="color:#9cdcfe">std</span><span style="color:#9cdcfe">::shared_f</span>uture&lt;<span style="color:#569cd6">int</span>&gt; sf = <span style="color:#9cdcfe">p</span>.<span style="color:#dcdcaa">get_future</span>();<span style="color:#6a9955"> // shared among different threads</span></div><div>        </div><div>        <span style="color:#9cdcfe">std</span><span style="color:#9cdcfe">::f</span>uture&lt;<span style="color:#569cd6">int</span>&gt; fu1 = <span style="color:#4ec9b0">std</span>::<span style="color:#dcdcaa">async</span>(<span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">launch</span>::async, squareSharedFuturePromise, sf);<span style="color:#6a9955">// f is COPIED not moved</span></div><div>        <span style="color:#9cdcfe">std</span><span style="color:#9cdcfe">::f</span>uture&lt;<span style="color:#569cd6">int</span>&gt; fu2 = <span style="color:#4ec9b0">std</span>::<span style="color:#dcdcaa">async</span>(<span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">launch</span>::async, squareSharedFuturePromise, sf); </div><div>        <span style="color:#9cdcfe">std</span><span style="color:#9cdcfe">::f</span>uture&lt;<span style="color:#569cd6">int</span>&gt; fu3 = <span style="color:#4ec9b0">std</span>::<span style="color:#dcdcaa">async</span>(<span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">launch</span>::async, squareSharedFuturePromise, sf); </div><div>        </div><div><span style="color:#6a9955">        // do something else for some time</span></div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">this_thread</span>::<span style="color:#9cdcfe">sleep_for</span>(<span style="color:#4ec9b0">chrono</span>::<span style="color:#4ec9b0">milliseconds</span>(<span style="color:#b5cea8">20</span>));</div><br /><div>        <span style="color:#9cdcfe">p</span>.<span style="color:#dcdcaa">set_value</span>(<span style="color:#b5cea8">4</span>);<span style="color:#6a9955"> // NOW BROADCAST a value to ALL already created thread</span></div><div><span style="color:#6a9955">        // p.set_exception(std::make_exception_ptr(std::runtime_error("Sorry, I cann't send any input - I'm breaking </span></div><div><span style="color:#6a9955">        // my promise")));</span></div><br /><div><span style="color:#6a9955">        // do something else for some time</span></div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">this_thread</span>::<span style="color:#9cdcfe">sleep_for</span>(<span style="color:#4ec9b0">chrono</span>::<span style="color:#4ec9b0">milliseconds</span>(<span style="color:#b5cea8">20</span>));</div><br /><div>        <span style="color:#9cdcfe">result</span> = <span style="color:#9cdcfe">fu2</span>.<span style="color:#dcdcaa">get</span>();</div><div>        <span style="color:#9cdcfe">cout</span>&lt;&lt; <span style="color:#ce9178">"Get from Child: "</span> &lt;&lt; result &lt;&lt; endl;</div><div>    }</div></div></div></div><div><br /></div><div><b>40. Callable Object and Callable Function:</b></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div><div style="line-height:22px"><div><span style="color:#6a9955">    // Ref: C++ Threading #8: Using Callable Objects</span></div><div><span style="color:#6a9955">    // https://www.youtube.com/watch?v=nU18p75u1oQ&amp;list=PL5jc9xFGsL8E12so1wlMS0r0hTQoJL74M&amp;index=8</span></div><div><span style="color:#569cd6">    </span><span style="color:#c586c0">#include</span><span style="color:#569cd6"> </span><span style="color:#ce9178">&lt;iostream&gt;</span></div><div><span style="color:#569cd6">    </span><span style="color:#c586c0">#include</span><span style="color:#569cd6"> </span><span style="color:#ce9178">&lt;future&gt;</span><span style="color:#569cd6">       </span><span style="color:#6a9955">// thread, async, call_once</span></div><div><span style="color:#569cd6">    </span><span style="color:#c586c0">#include</span><span style="color:#569cd6"> </span><span style="color:#ce9178">&lt;functional&gt;</span><span style="color:#569cd6">   </span><span style="color:#6a9955">// bind</span></div><div>    <span style="color:#c586c0">using</span> <span style="color:#569cd6">namespace</span> <span style="color:#4ec9b0">std</span>;</div><br /><div><span style="color:#6a9955">    // Callable Object and Callable Member Function</span></div><div>    <span style="color:#569cd6">class</span> <span style="color:#4ec9b0">A</span> {</div><div>    <span style="color:#569cd6">public:</span></div><div>        <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">f</span>(<span style="color:#569cd6">int</span> <span style="color:#9cdcfe">x</span>, <span style="color:#569cd6">char</span> <span style="color:#9cdcfe">c</span>) { }</div><div>        <span style="color:#569cd6">int</span> <span style="color:#dcdcaa">operator()</span>(<span style="color:#569cd6">int</span> <span style="color:#9cdcfe">N</span>) { <span style="color:#c586c0">return</span> <span style="color:#b5cea8">0</span>;}<span style="color:#6a9955"> // functor</span></div><div>    };</div><div style="line-height:22px"><br /></div><span style="color:rgb(106,153,85)">    // Callable Global Function</span><br /><div>    <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">foo</span>(<span style="color:#569cd6">int</span> <span style="color:#9cdcfe">x</span>) { }</div></div></div></div></div><div><br /></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div style="line-height:22px"><div>    <span style="color:#569cd6">int</span> <span style="color:#dcdcaa">main</span>() {</div><div>        A a;<span style="color:#6a9955"> // a - is a CALLABLE object</span></div><br /><div><span style="color:#6a9955">        // Different ways of using the "callable object followed by variable number of arguments"</span></div><div>        <span style="color:#4ec9b0">std</span>::thread <span style="color:#dcdcaa">t</span>(a, <span style="color:#b5cea8">6</span>);</div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#dcdcaa">async</span>(a, <span style="color:#b5cea8">6</span>);</div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#dcdcaa">bind</span>(a, <span style="color:#b5cea8">6</span>);</div><div>        <span style="color:#4ec9b0">std</span>::once_flag oFlag;</div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#dcdcaa">call_once</span>(oFlag, a, <span style="color:#b5cea8">6</span>);</div><br /><div><span style="color:#6a9955">        // Functor</span></div><div>        <span style="color:#4ec9b0">std</span>::thread <span style="color:#dcdcaa">t1</span>(a, <span style="color:#b5cea8">6</span>);<span style="color:#6a9955"> // create a copy of object 'a' and invoke as a functor[a()] in a different thread</span></div><div>        <span style="color:#4ec9b0">std</span>::thread <span style="color:#dcdcaa">t2</span>(<span style="color:#4ec9b0">std</span>::<span style="color:#dcdcaa">ref</span>(a), <span style="color:#b5cea8">6</span>);<span style="color:#6a9955">  // Reuse the existing object 'a' and call the functor[a()] in a different thread</span></div><div>        <span style="color:#4ec9b0">std</span>::thread <span style="color:#dcdcaa">t3</span>(<span style="color:#4ec9b0">std</span>::<span style="color:#dcdcaa">move</span>(a), <span style="color:#b5cea8">6</span>);<span style="color:#6a9955"> // NO copy of 'a' but 'a' is no longer usable in main thread</span></div><div>        <span style="color:#4ec9b0">std</span>::thread <span style="color:#dcdcaa">t4</span>(<span style="color:#dcdcaa">A</span>(), <span style="color:#b5cea8">6</span>);<span style="color:#6a9955">          // create a temp A then temp A move into thread object</span></div><div>        </div><div><span style="color:#6a9955">        // Member Function</span></div><div>        <span style="color:#4ec9b0">std</span>::thread <span style="color:#dcdcaa">t5</span>(&amp;<span style="color:#4ec9b0">A</span>::f, a, <span style="color:#b5cea8">6</span>, <span style="color:#ce9178">'w'</span>);<span style="color:#6a9955">  // copy_of_a.f(6, 'w') in a different thread</span></div><div>        <span style="color:#4ec9b0">std</span>::thread <span style="color:#dcdcaa">t6</span>(&amp;<span style="color:#4ec9b0">A</span>::f, &amp;a, <span style="color:#b5cea8">6</span>, <span style="color:#ce9178">'w'</span>);<span style="color:#6a9955"> // NO copy of a =&gt; a.f(6, 'w') in a different thread</span></div><br /><div><span style="color:#6a9955">        // Can be also a callable global FUNCTION instead of callable object</span></div><div>        <span style="color:#4ec9b0">std</span>::thread <span style="color:#dcdcaa">t7</span>(foo, <span style="color:#b5cea8">6</span>);<span style="color:#6a9955"> // callable function</span></div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">thread</span> <span style="color:#9cdcfe">t8</span>([](<span style="color:#569cd6">float</span> <span style="color:#9cdcfe">x</span>) { <span style="color:#c586c0">return</span> <span style="color:#9cdcfe">x</span> + <span style="color:#b5cea8">20.0f</span>; }, <span style="color:#b5cea8">5.2</span>);<span style="color:#6a9955"> // callable lamda function</span></div><br /><div><span style="color:#6a9955">        // Similliarly you can do the SAME for 'async', 'bind' and 'call_once'</span></div><div>        <span style="color:#c586c0">return</span> <span style="color:#b5cea8">0</span>;</div><div>    }</div></div></div></div><div><br /></div><div><b>41. Packaged Task:</b> Pack/wrap a task(function) and do trasport to different places (to different function, object, thread)</div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div>    <span style="color:#569cd6">int</span> <span style="color:#dcdcaa">square</span>(<span style="color:#569cd6">char</span> <span style="color:#9cdcfe">c</span>) {</div><div>        <span style="color:#c586c0">if</span>(<span style="color:#9cdcfe">c</span> == <span style="color:#ce9178">'a'</span>) <span style="color:#c586c0">return</span> <span style="color:#b5cea8">5</span> * <span style="color:#b5cea8">5</span>;</div><div>        <span style="color:#c586c0">if</span>(<span style="color:#9cdcfe">c</span> == <span style="color:#ce9178">'b'</span>) <span style="color:#c586c0">return</span> <span style="color:#b5cea8">5</span> * <span style="color:#b5cea8">5</span> * <span style="color:#b5cea8">5</span>;  </div><div>    }</div><br /><div>    <span style="color:#569cd6">int</span> <span style="color:#dcdcaa">main</span>() {</div><div>        <span style="color:#4ec9b0">std</span>::packaged_task&lt;<span style="color:#569cd6">int</span>(<span style="color:#569cd6">char</span>)&gt; <span style="color:#dcdcaa">pt</span>(<span style="color:#dcdcaa">square</span>);</div><br /><div><span style="color:#6a9955">        // after sometime execute the task which was packed in a different context/place</span></div><div>        <span style="color:#dcdcaa">pt</span>(<span style="color:#ce9178">'b'</span>);<span style="color:#6a9955"> // packaged task always return void</span></div><div>        <span style="color:#569cd6">int</span> <span style="color:#9cdcfe">x</span> = <span style="color:#9cdcfe">pt</span>.<span style="color:#dcdcaa">get_future</span>().<span style="color:#dcdcaa">get</span>();<span style="color:#6a9955"> // to get the return value</span></div><div>        cout &lt;&lt; <span style="color:#9cdcfe">x</span>;<span style="color:#6a9955"> // 125</span></div><br /><br /><div><span style="color:#6a9955">        // Explicitly bind the input arguments</span></div><div>        <span style="color:#4ec9b0">std</span>::packaged_task&lt;<span style="color:#569cd6">int</span>()&gt; <span style="color:#dcdcaa">ptb</span>(<span style="color:#4ec9b0">std</span>::<span style="color:#dcdcaa">bind</span>(<span style="color:#dcdcaa">square</span>, <span style="color:#ce9178">'a'</span>));<span style="color:#6a9955"> // Remove char from &lt;int(char)&gt; on explicit bind</span></div><div><span style="color:#6a9955">        // after sometime execute the packaged task in a different context/place    </span></div><div>        <span style="color:#dcdcaa">ptb</span>();<span style="color:#6a9955">// Execute it but NOT pt('b') =&gt; you can NOT send another new argument after above explicit bind</span></div><div>        <span style="color:#569cd6">int</span> <span style="color:#9cdcfe">y</span> = <span style="color:#9cdcfe">ptb</span>.<span style="color:#dcdcaa">get_future</span>().<span style="color:#dcdcaa">get</span>();<span style="color:#6a9955"> // to get the return value</span></div><div>        cout &lt;&lt; <span style="color:#9cdcfe">y</span>;<span style="color:#6a9955"> // 125</span></div><br /><br /><div><span style="color:#6a9955">        // without packaged task - using functional object</span></div><div>        <span style="color:#569cd6">auto</span> <span style="color:#9cdcfe">fo</span> = <span style="color:#4ec9b0">std</span>::<span style="color:#dcdcaa">bind</span>(<span style="color:#dcdcaa">square</span>, <span style="color:#ce9178">'b'</span>);<span style="color:#6a9955"> // create a function object fo</span></div><div>        <span style="color:#569cd6">int</span> <span style="color:#9cdcfe">x</span> = <span style="color:#9cdcfe">fo</span>();<span style="color:#6a9955"> // execute the function object with binded argument </span></div><div>        cout &lt;&lt; <span style="color:#9cdcfe">x</span>;<span style="color:#6a9955"> // 125</span></div><br /><div><span style="color:#6a9955">        // We can do the same in functional object then why we need the packaged task ?</span></div><div><span style="color:#6a9955">        // Using functional object you can NOT return a future value from a thread but you can in packaged task</span></div><div>    }</div></div></div><div><br /></div><div>Returning future value from thread using packaged task:</div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div style="line-height:22px"><div><span style="color:#6a9955">    // Ref: C++ Threading #9: packaged_task</span></div><div><span style="color:#6a9955">    // https://www.youtube.com/watch?v=FfbZfBk-3rI&amp;list=PL5jc9xFGsL8E12so1wlMS0r0hTQoJL74M&amp;index=9</span></div><div><span style="color:#569cd6">    </span><span style="color:#c586c0">#include</span><span style="color:#569cd6"> </span><span style="color:#ce9178">&lt;iostream&gt;</span></div><div><span style="color:#569cd6">    </span><span style="color:#c586c0">#include</span><span style="color:#569cd6"> </span><span style="color:#ce9178">&lt;future&gt;</span><span style="color:#569cd6">       </span><span style="color:#6a9955">// thread, async, call_once</span></div><div><span style="color:#569cd6">    </span><span style="color:#c586c0">#include</span><span style="color:#569cd6"> </span><span style="color:#ce9178">&lt;functional&gt;</span><span style="color:#569cd6">   </span><span style="color:#6a9955">// bind</span></div><div><span style="color:#569cd6">    </span><span style="color:#c586c0">#include</span><span style="color:#569cd6"> </span><span style="color:#ce9178">&lt;deque&gt;</span></div><div><span style="color:#569cd6">    </span><span style="color:#c586c0">#include</span><span style="color:#569cd6"> </span><span style="color:#ce9178">&lt;thread&gt;</span></div><div><span style="color:#569cd6">    </span><span style="color:#c586c0">#include</span><span style="color:#569cd6"> </span><span style="color:#ce9178">&lt;mutex&gt;</span></div><div><span style="color:#569cd6">    </span><span style="color:#c586c0">#include</span><span style="color:#569cd6"> </span><span style="color:#ce9178">&lt;condition_variable&gt;</span></div><div>    <span style="color:#c586c0">using</span> <span style="color:#569cd6">namespace</span> <span style="color:#4ec9b0">std</span>;</div><br /><div>    <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">deque</span>&lt;<span style="color:#569cd6">int</span>&gt; <span style="color:#9cdcfe">q</span>;</div><div>    <span style="color:#4ec9b0">std</span>::mutex <span style="color:#9cdcfe">mu</span>;</div><div>    <span style="color:#4ec9b0">std</span>::condition_variable <span style="color:#9cdcfe">cond</span>;<span style="color:#6a9955"> // synchronize the excution sequence of the threads</span></div><div>    <span style="color:#4ec9b0">std</span>::deque&lt;<span style="color:#4ec9b0">std</span>::packaged_task&lt;<span style="color:#569cd6">int</span>()&gt;&gt; task_q;</div></div></div></div><div><br /></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div style="line-height:22px"><div style="line-height:22px"><div>    <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">consumerThread</span>() {</div><div>        <span style="color:#4ec9b0">std</span>::packaged_task&lt;<span style="color:#569cd6">int</span>()&gt; t;</div><br /><div>        <span style="color:#4ec9b0">std</span>::unique_lock&lt;<span style="color:#4ec9b0">std</span>::mutex&gt; <span style="color:#dcdcaa">locker</span>(<span style="color:#9cdcfe">mu</span>);</div><div>        <span style="color:#9cdcfe">cond</span>.<span style="color:#dcdcaa">wait</span>(locker, []() { <span style="color:#c586c0">return</span> !<span style="color:#9cdcfe">task_q</span>.<span style="color:#dcdcaa">empty</span>(); });</div><br /><div>        t = <span style="color:#4ec9b0">std</span>::<span style="color:#dcdcaa">move</span>(<span style="color:#9cdcfe">task_q</span>.<span style="color:#dcdcaa">front</span>());<span style="color:#6a9955"> // should be called after push back in the main thread</span></div><div>        <span style="color:#9cdcfe">task_q</span>.<span style="color:#dcdcaa">pop_front</span>();</div><div>        <span style="color:#9cdcfe">locker</span>.<span style="color:#dcdcaa">unlock</span>();</div><br /><div>        <span style="color:#dcdcaa">t</span>(); <span style="color:rgb(106,153,85)">// execute the packaged task</span></div><div>    }</div></div></div></div></div><div><br /></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div style="line-height:22px"><div><span style="color:#6a9955">    // Thread function returns value</span></div><div>    <span style="color:#569cd6">int</span> <span style="color:#dcdcaa">squareFuture</span>(<span style="color:#569cd6">int</span> <span style="color:#9cdcfe">N</span>) {</div><div>        <span style="color:#569cd6">int</span> res = N * N;</div><div>        <span style="color:#c586c0">return</span> res;</div><div>    }</div></div></div></div><div><br /></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div style="line-height:22px"><div>    <span style="color:#569cd6">int</span> <span style="color:#dcdcaa">main</span>()</div><div>    {</div><div><span style="color:#6a9955">        // packaged_task&lt;int(int)&gt;  - Template class which takes a function which takes integer and return integer.</span></div><div><span style="color:#6a9955">        // It returns future by 'get_future()'</span></div><div>        <span style="color:#4ec9b0">std</span>::packaged_task&lt;<span style="color:#569cd6">int</span>(<span style="color:#569cd6">int</span>)&gt; <span style="color:#dcdcaa">pt</span>(squareFuture);<span style="color:#6a9955"> // pt is a task being packaged up with a package (squareFuture).</span></div><div><span style="color:#6a9955">        // It can be passed along different places such as different function, different object or different threads</span></div><br /><div><span style="color:#6a9955">        // do something else</span></div><div>        <span style="color:#dcdcaa">pt</span>(<span style="color:#b5cea8">6</span>);<span style="color:#6a9955"> // packaged task always return void</span></div><div>        <span style="color:#569cd6">int</span> result = <span style="color:#9cdcfe">pt</span>.<span style="color:#dcdcaa">get_future</span>().<span style="color:#dcdcaa">get</span>();<span style="color:#6a9955"> // to get the return value</span></div><br /><div><span style="color:#6a9955">        // Passing parameters with the help of bind. bind converts the 'function with argument' into 'function object'.</span></div><div><span style="color:#6a9955">        // std::thread t1(squareFuture, 6);</span></div><div>        <span style="color:#4ec9b0">std</span>::packaged_task&lt;<span style="color:#569cd6">int</span>()&gt; <span style="color:#dcdcaa">pt</span>(<span style="color:#4ec9b0">std</span>::<span style="color:#dcdcaa">bind</span>(squareFuture,<span style="color:#b5cea8">6</span>));<span style="color:#6a9955"> // internally links the callable object with FUTURE</span></div><div><span style="color:#6a9955">        // do something else</span></div><div>        <span style="color:#dcdcaa">pt</span>();<span style="color:#6a9955"> // always return void</span></div><br /><div><span style="color:#6a9955">        // Function object</span></div><div>        <span style="color:#569cd6">auto</span> fo = <span style="color:#4ec9b0">std</span>::<span style="color:#dcdcaa">bind</span>(squareFuture,<span style="color:#b5cea8">6</span>);<span style="color:#6a9955"> // NO FUTURE linkage here</span></div><div><span style="color:#6a9955">        // do something else</span></div><div>        <span style="color:#dcdcaa">fo</span>();<span style="color:#6a9955"> // always return void</span></div><br /><div>        <span style="color:#4ec9b0">std</span>::thread <span style="color:#dcdcaa">t1</span>(consumerThread);</div><div>        <span style="color:#9cdcfe">std</span><span style="color:#9cdcfe">::packaged</span>_task&lt;<span style="color:#569cd6">int</span>()&gt; <span style="color:#dcdcaa">pt</span>(<span style="color:#4ec9b0">std</span>::<span style="color:#dcdcaa">bind</span>(squareFuture,<span style="color:#b5cea8">6</span>));<span style="color:#6a9955"> // internally links the callable object with FUTURE</span></div><div>        <span style="color:#9cdcfe">std</span><span style="color:#9cdcfe">::f</span>uture&lt;<span style="color:#569cd6">int</span>&gt; fut = <span style="color:#9cdcfe">pt</span>.<span style="color:#dcdcaa">get_future</span>();</div><div><br /></div><div>        <span style="color:#4ec9b0">std</span>::unique_lock&lt;mutex&gt; <span style="color:#dcdcaa">locker</span>(mu);</div><div>        <span style="color:#9cdcfe">task_q</span>.<span style="color:#dcdcaa">push_back</span>(<span style="color:#4ec9b0">std</span>::<span style="color:#dcdcaa">move</span>(pt));<span style="color:#6a9955"> // NOTE: move</span></div><div><br /></div><div>        <span style="color:#9cdcfe">cond</span>.<span style="color:#dcdcaa">notify_one</span>();</div><div>        </div><div><span style="color:#6a9955">        // do something else</span></div><div><span style="color:#6a9955">        // int result = pt.get_future().get();</span></div><div>        <span style="color:#569cd6">int</span> <span style="color:#9cdcfe">result</span> = <span style="color:#9cdcfe">fut</span>.<span style="color:#dcdcaa">get</span>();</div><br /><div>        <span style="color:#9cdcfe">t1</span>.<span style="color:#dcdcaa">join</span>();</div><div>    }</div></div></div></div><div><br /></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div style="line-height:22px"><div>    <span style="color:#b5cea8">3</span> ways to get a future:</div><div>        - <span style="color:#4ec9b0">promise</span>::<span style="color:#dcdcaa">get_future</span>()</div><div>        - <span style="color:#4ec9b0">packaged_task</span>::<span style="color:#dcdcaa">get_future</span>()</div><div>        - <span style="color:#dcdcaa">async</span>() returns a future</div></div></div></div><div><b><br /></b></div><div><b>42. Review the topics and Adding Time Constraints to thread:</b></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div style="line-height:22px"><div><span style="color:#6a9955">    // Ref: C++ Threading #10: Review and Time Constraint</span></div><div><span style="color:#6a9955">    // https://www.youtube.com/watch?v=3wpBk5Y3gfk&amp;list=PL5jc9xFGsL8E12so1wlMS0r0hTQoJL74M&amp;index=10</span></div><div><span style="color:#569cd6">    </span><span style="color:#c586c0">#include</span><span style="color:#ce9178">&lt;iostream&gt;</span></div><div><span style="color:#569cd6">    </span><span style="color:#c586c0">#include</span><span style="color:#ce9178">&lt;thread&gt;</span></div><div><span style="color:#569cd6">    </span><span style="color:#c586c0">#include</span><span style="color:#ce9178">&lt;mutex&gt;</span></div><div><span style="color:#569cd6">    </span><span style="color:#c586c0">#include</span><span style="color:#ce9178">&lt;condition_variable&gt;</span></div><div><span style="color:#569cd6">    </span><span style="color:#c586c0">#include</span><span style="color:#ce9178">&lt;future&gt;</span></div><div>    <span style="color:#c586c0">using</span> <span style="color:#569cd6">namespace</span> <span style="color:#4ec9b0">std</span>;</div><br /><div><span style="color:#6a9955">    /* threads with time constrains */</span></div><div>    <span style="color:#569cd6">int</span> <span style="color:#dcdcaa">square</span>(<span style="color:#569cd6">int</span> <span style="color:#9cdcfe">N</span>) {</div><div>        <span style="color:#569cd6">int</span> <span style="color:#9cdcfe">res</span> = <span style="color:#9cdcfe">N</span> * <span style="color:#9cdcfe">N</span>;</div><div>        <span style="color:#c586c0">return</span> <span style="color:#9cdcfe">res</span>;</div><div>    }</div></div></div></div><div><br /></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div style="line-height:22px"><div>    <span style="color:#569cd6">int</span> <span style="color:#dcdcaa">main</span>() {</div><div><span style="color:#6a9955">        /* thread */</span></div><div>        <span style="color:#4ec9b0">std</span>::thread <span style="color:#dcdcaa">t1</span>(square, <span style="color:#b5cea8">6</span>);<span style="color:#6a9955"> // create a thread object and spawn the thread</span></div><div><span style="color:#6a9955"><br /></span></div><div><span style="color:#6a9955">        // Add time/sleep constraints. 1: sleep, 2: time point</span></div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">this_thread</span>::<span style="color:#dcdcaa">sleep_for</span>(<span style="color:#4ec9b0">chrono</span>::<span style="color:#dcdcaa">milliseconds</span>(<span style="color:#b5cea8">3</span>));</div><div><br /></div><div>        <span style="color:#4ec9b0">chrono</span>::<span style="color:#4ec9b0">steady_clock</span>::time_point tp = <span style="color:#4ec9b0">chrono</span>::<span style="color:#4ec9b0">steady_clock</span>::<span style="color:#dcdcaa">now</span>() + <span style="color:#4ec9b0">chrono</span>::<span style="color:#dcdcaa">microseconds</span>(<span style="color:#b5cea8">4</span>);</div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">this_thread</span>::<span style="color:#dcdcaa">sleep_until</span>(tp);</div><br /><div><span style="color:#6a9955">        /* Mutex */</span></div><div>        <span style="color:#4ec9b0">std</span>::mutex mu;<span style="color:#6a9955"> // mutux for synchronize the data access</span></div><div>        <span style="color:#9cdcfe">mu</span>.<span style="color:#dcdcaa">lock</span>();<span style="color:#6a9955">   // DONN'T use this mutux own method. It is NOT recommended.</span></div><div>        <span style="color:#9cdcfe">mu</span>.<span style="color:#dcdcaa">unlock</span>();<span style="color:#6a9955"> // DONN'T use this mutux own method. It is NOT recommended.</span></div><div>        <span style="color:#4ec9b0">std</span>::lock_guard&lt;mutex&gt; <span style="color:#dcdcaa">locker</span>(mu);<span style="color:#6a9955">   // lock/unlock single time. For simple usage.</span></div><div>        <span style="color:#4ec9b0">std</span>::unique_lock&lt;mutex&gt; <span style="color:#dcdcaa">ulocker</span>(mu);<span style="color:#6a9955"> // extra flexibility - lock/unlock multiple times. Also transfter </span></div><div><span style="color:#6a9955">                                             // the ownership to another </span><span style="color:rgb(106,153,85)">unique_lock</span></div><div><span style="color:#6a9955">        // Add time constraint</span></div><div>        <span style="color:#9cdcfe">ulocker</span>.<span style="color:#dcdcaa">try_lock</span>();<span style="color:#6a9955"> // In this method you cann't add time constraint. Immediately return true/false.</span></div><div>        <span style="color:#9cdcfe">ulocker</span>.<span style="color:#dcdcaa">try_lock_for</span>(<span style="color:#4ec9b0">chrono</span>::<span style="color:#dcdcaa">nanoseconds</span>(<span style="color:#b5cea8">500</span>));<span style="color:#6a9955"> // If 500 has past and mutux still can not be locked then </span></div><div><span style="color:#6a9955">                                                        // function will return</span></div><div>        <span style="color:#9cdcfe">ulocker</span>.<span style="color:#dcdcaa">try_lock_until</span>(tp); <span style="color:rgb(106,153,85)">// timePoint</span></div><br /><div><span style="color:#6a9955">        /* Condition Variable */</span></div><div>        <span style="color:#c8c8c8">std</span>:condition_variable cond;<span style="color:#6a9955"> // To synchronize the execution ORDER of the threads</span></div><div><span style="color:#6a9955"><br /></span></div><div><span style="color:#6a9955">        // Add time constraint</span></div><div>        <span style="color:#9cdcfe">cond</span>.<span style="color:#dcdcaa">wait_for</span>(ulocker, <span style="color:#4ec9b0">chrono</span>::<span style="color:#dcdcaa">microseconds</span>(<span style="color:#b5cea8">2</span>));<span style="color:#6a9955"> // NOTE: ulocker as a first parameter</span></div><div>        <span style="color:#9cdcfe">cond</span>.<span style="color:#dcdcaa">wait_until</span>(ulocker, tp);</div><br /><div><span style="color:#6a9955">        /* Future and Promise */</span></div><div>        <span style="color:#9cdcfe">std</span><span style="color:#9cdcfe">::pr</span>omise&lt;<span style="color:#569cd6">int</span>&gt; p;<span style="color:#6a9955">// p is promised to send an integer variable</span></div><div>        <span style="color:#9cdcfe">std</span><span style="color:#9cdcfe">::f</span>uture&lt;<span style="color:#569cd6">int</span>&gt; f = <span style="color:#9cdcfe">p</span>.<span style="color:#dcdcaa">get_future</span>();<span style="color:#6a9955"> // f is a future which can fetch integer variable which was send over </span></div><div><span style="color:#6a9955">                                            // by p in the past.</span></div><div><span style="color:#6a9955">        // Add time constraint</span></div><div>        <span style="color:#9cdcfe">f</span>.<span style="color:#dcdcaa">get</span>();<span style="color:#6a9955"> // get() internally call wait()</span></div><div>        <span style="color:#9cdcfe">f</span>.<span style="color:#dcdcaa">wait</span>();<span style="color:#6a9955"> // Not take time constraint</span></div><div>        <span style="color:#9cdcfe">f</span>.<span style="color:#dcdcaa">wait_for</span>(<span style="color:#4ec9b0">chrono</span>::<span style="color:#dcdcaa">milliseconds</span>(<span style="color:#b5cea8">2</span>)); <span style="color:rgb(106,153,85)">// Takes time constraint</span></div><div>        <span style="color:#9cdcfe">f</span>.<span style="color:#dcdcaa">wait_until</span>(tp);</div><br /><div><span style="color:#6a9955">        /* async() - for excuting the 'square' function by EITHER spawn a new 'child thread' OR execute in </span></div><div><span style="color:#6a9955">        the 'current thread'. */</span></div><div>        <span style="color:#9cdcfe">std</span><span style="color:#9cdcfe">::f</span>uture&lt;<span style="color:#569cd6">int</span>&gt; fu = <span style="color:#dcdcaa">async</span>(square, <span style="color:#b5cea8">6</span>);<span style="color:#6a9955"> // std::async returns future.</span></div><div><span style="color:#6a9955">        // NO direct time constraint support</span></div><br /><div><span style="color:#6a9955">        /* Packaged Task */</span></div><div>        <span style="color:#9cdcfe">std</span><span style="color:#9cdcfe">::packaged</span>_task&lt;<span style="color:#569cd6">int</span>(<span style="color:#569cd6">int</span>)&gt; <span style="color:#dcdcaa">t</span>(square);</div><div>        <span style="color:#9cdcfe">std</span><span style="color:#9cdcfe">::f</span>uture&lt;<span style="color:#569cd6">int</span>&gt; fu2 = <span style="color:#9cdcfe">t</span>.<span style="color:#dcdcaa">get_future</span>();<span style="color:#6a9955"> // packaged task can return  future.</span></div><div>        <span style="color:#9cdcfe">t</span>(<span style="color:#b5cea8">6</span>);</div><div><span style="color:#6a9955">        // NO direct time constraint support</span></div><div>    }</div></div></div></div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><div><br /></div></div></div></td></tr></tbody></table><div class="sites-layout-tile sites-tile-name-footer sites-layout-empty-tile"><div dir="ltr"><br /></div></div></div>
</div> 
</div> 
<div id="sites-canvas-bottom-panel">
<div xmlns="http://www.w3.org/1999/xhtml" id="COMP_page-subpages"> </div>
<div id="sites-attachments-container">
</div>
<a xmlns="http://www.w3.org/1999/xhtml" name="page-comments"></a>
<div xmlns="http://www.w3.org/1999/xhtml" id="COMP_page-comments"><div class="sites-comment-docos-wrapper"><div class="sites-comment-docos"><div class="sites-comment-docos-background"></div><div class="sites-comment-docos-header"><div class="sites-comment-docos-header-title">Comments</div></div><div id="sites-comment-docos-pane" class="sites-comment-docos-pane"></div></div></div></div>
</div>
</div> 
</td> 
</tr>
</table> 
</div> 
</div> 
<div id="sites-chrome-footer-wrapper">
<div id="sites-chrome-footer-wrapper-inside">
<div id="sites-chrome-footer">
</div>
</div>
</div>
</div> 
</div> 
<div id="sites-chrome-adminfooter-container">
<div xmlns="http://www.w3.org/1999/xhtml" class="sites-adminfooter" role="navigation"><p><a class="sites-system-link" href="https://accounts.google.com/ServiceLogin?continue=https://sites.google.com/site/sridharkritha/handyconcepts/c-11/threads&amp;service=jotspot">Sign in</a><span aria-hidden="true">|</span><a class="sites-system-link" href="../../system/app/pages/recentChanges.html">Recent Site Activity</a><span aria-hidden="true">|</span><a class="sites-system-link" href="../../system/app/pages/reportAbuse.html" target="_blank">Report Abuse</a><span aria-hidden="true">|</span><a class="sites-system-link" href="javascript:;" onclick="window.open(webspace.printUrl)">Print Page</a><span aria-hidden="true">|</span><span class="sites-system-link">Powered By</span> <b class="powered-by"><a href="http://sites.google.com/site">Google Sites</a></b></p></div>
</div>
</div> 
</div> 
<script xmlns="http://www.w3.org/1999/xhtml" type="text/javascript">
    window.jstiming.load.tick('sjl');
  </script>
<script xmlns="http://www.w3.org/1999/xhtml" src="../../../../../ssl.gstatic.com/sites/p/a71eef/system/js/jot_min_view__en.js"></script>
<script xmlns="http://www.w3.org/1999/xhtml" type="text/javascript">
    window.jstiming.load.tick('jl');
  </script>
<script xmlns="http://www.w3.org/1999/xhtml" type="text/javascript">
      gsites.HoverPopupMenu.createSiteDropdownMenus('sites-header-nav-dropdown', false);
    </script>
<script xmlns="http://www.w3.org/1999/xhtml" type="text/javascript">
              new sites.CommentPane('//docs.google.com/comments/d/AAHRpnXt_Mp5R2w3D84n3sOb0JtfMMa9cndH9OLEe4lwHur3KV6_3wzXFCEvaV3pAPmNWDMOXJ50K0sXPDTCIUAOklmbAhjCpT-oUfpqOOD7nWD_E60IfkD-a9LyC-WAp3kiKjz4uhj-P/api/js?anon=true',
                  false, false);
            </script>
<script xmlns="http://www.w3.org/1999/xhtml" type="text/javascript">
  setTimeout(function() {
    var fingerprint = gsites.date.TimeZone.getFingerprint([1109635200000, 1128902400000, 1130657000000, 1143333000000, 1143806400000, 1145000000000, 1146380000000, 1152489600000, 1159800000000, 1159500000000, 1162095000000, 1162075000000, 1162105500000]);
    gsites.Xhr.send('../../_/tz.html', null, null, 'GET', null, null, { afjstz: fingerprint });
  }, 500);
</script>
<script xmlns="http://www.w3.org/1999/xhtml">
                    window.onload = function() {
                      if (false) {
                        JOT_setMobilePreview();
                      }
                      var loadTimer = window.jstiming.load;
                      loadTimer.tick("ol");
                      loadTimer["name"] = "load," + webspace.page.type + ",user_page";
                      window.jstiming.report(loadTimer, {}, '../../../../../gg.google.com/csi.gif');
                    }
                  </script>
<script xmlns="http://www.w3.org/1999/xhtml" type="text/javascript">
        JOT_insertAnalyticsCode(false,
            false);
      </script>
<script xmlns="http://www.w3.org/1999/xhtml" type="text/javascript">
    var maestroRunner = new gsites.pages.view.SitesMaestroRunner(
        webspace, "en");
    maestroRunner.initListeners();
    maestroRunner.installEditRender();
  </script>
<script xmlns="http://www.w3.org/1999/xhtml" type="text/javascript" defer="true">
  //<![CDATA[
    // Decorate any fastUI buttons on the page with a class of 'goog-button'.
    if (webspace.user.hasWriteAccess) {
      JOT_decorateButtons();
    }

    // Fires delayed events.
    (function() {
      JOT_fullyLoaded = true;
      var delayedEvents = JOT_delayedEvents;
      for (var x = 0; x < delayedEvents.length; x++) {
        var event = delayedEvents[x];
        JOT_postEvent(event.eventName, event.eventSrc, event.payload);
      }
      JOT_delayedEvents = null;
      JOT_postEvent('pageLoaded');
    })();
  //]]>
</script>
<script xmlns="http://www.w3.org/1999/xhtml" type="text/javascript">
    JOT_postEvent('decorateGvizCharts');
  </script>
<script type="text/javascript">
          JOT_setupPostRenderingManager();
        </script>
<script type="text/javascript">
          JOT_postEvent('renderPlus', null, 'sites-chrome-main');
        </script>
<script type="text/javascript">
          sites.codeembed.init();
        </script>
<div id="server-timer-div" style="display:none"> </div>
<script type="text/javascript">
          window.jstiming.load.tick('render');
          JOT_postEvent('usercontentrendered', this);
        </script>
</body>

<!-- Mirrored from sites.google.com/site/sridharkritha/handyconcepts/c-11/threads by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 09 Jul 2021 10:31:35 GMT -->
</html>
