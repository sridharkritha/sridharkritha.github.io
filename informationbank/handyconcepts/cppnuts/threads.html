<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" itemscope="" itemtype="../../../../../schema.org/WebPage.html">

<!-- Mirrored from sites.google.com/site/sridharkritha/handyconcepts/cppnuts/threads by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 09 Jul 2021 10:31:35 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta http-equiv="X-UA-Compatible" content="chrome=1" />
<script type="text/javascript">/* Copyright 2008 Google. */ (function() { /*

Copyright The Closure Library Authors.
SPDX-License-Identifier: Apache-2.0
*/
(function(){function e(g){this.t={};this.tick=function(h,k,f){this.t[h]=[void 0!=f?f:(new Date).getTime(),k];if(void 0==f)try{window.console.timeStamp("CSI/"+h)}catch(m){}};this.getStartTickTime=function(){return this.t.start[0]};this.tick("start",null,g)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var l=0<d?new e(d):new e;window.jstiming={Timer:e,load:l};if(a){var b=a.navigationStart;0<b&&d>=b&&(window.jstiming.srt=d-b)}if(a){var c=window.jstiming.load;0<b&&d>=
b&&(c.tick("_wtsrt",void 0,b),c.tick("wtsrt_","_wtsrt",d),c.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),c&&0<b&&(c.tick("_tbnd",void 0,window.chrome.csi().startE),c.tick("tbnd_","_tbnd",b))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,c&&0<b&&(c.tick("_tbnd",void 0,window.external.startE),c.tick("tbnd_","_tbnd",b))),a&&(window.jstiming.pt=a)}catch(g){}})(); })()
</script>
<link rel="shortcut icon" type="image/x-icon" href="../../../../../www.google.com/images/icons/product/sites-16.ico" />
<link rel="apple-touch-icon" href="../../../../../ssl.gstatic.com/sites/p/a71eef/system/app/images/apple-touch-icon.png" type="image/png" />
<script type="text/javascript">/* Copyright 2008 Google. */ (function() { function d(a){return document.getElementById(a)}window.byId=d;function g(a){return a.replace(/^\s+|\s+$/g,"")}window.trim=g;var h=[],k=0;window.JOT_addListener=function(a,b,c){var f=new String(k++);a={eventName:a,handler:b,compId:c,key:f};h.push(a);return f};window.JOT_removeListenerByKey=function(a){for(var b=0;b<h.length;b++)if(h[b].key==a){h.splice(b,1);break}};window.JOT_removeAllListenersForName=function(a){for(var b=0;b<h.length;b++)h[b].eventName==a&&h.splice(b,1)};
window.JOT_postEvent=function(a,b,c){var f={eventName:a,eventSrc:b||{},payload:c||{}};if(window.JOT_fullyLoaded)for(b=h.length,c=0;c<b&&c<h.length;c++){var e=h[c];e&&e.eventName==a&&(f.listenerCompId=e.compId||"",(e="function"==typeof e.handler?e.handler:window[e.handler])&&e(f))}else window.JOT_delayedEvents.push({eventName:a,eventSrc:b,payload:c})};window.JOT_delayedEvents=[];window.JOT_fullyLoaded=!1;
window.JOT_formatRelativeToNow=function(a,b){a=((new Date).getTime()-a)/6E4;if(1440<=a||0>a)return null;var c=0;60<=a&&(a/=60,c=2);2<=a&&c++;return b?window.JOT_siteRelTimeStrs[c].replace("__duration__",Math.floor(a)):window.JOT_userRelTimeStrs[c].replace("__duration__",Math.floor(a))}; })()
</script>
<script>

  

  var breadcrumbs = [{"path":"/site/sridharkritha/handyconcepts","deleted":false,"title":"handyconcepts","dir":"ltr"},{"path":"/site/sridharkritha/handyconcepts/cppnuts","deleted":false,"title":"CppNuts","dir":"ltr"},{"path":"/site/sridharkritha/handyconcepts/cppnuts/threads","deleted":false,"title":"Threads","dir":"ltr"}];
  var JOT_clearDotPath = '../../../../../ssl.gstatic.com/sites/p/a71eef/system/app/images/cleardot.gif';

  
  var JOT_userRelTimeStrs = ["a minute ago","__duration__ minutes ago","an hour ago","__duration__ hours ago"];

  
  

  

  var webspace = {"gvizGstaticVersion":"current","enableAnalytics":false,"pageSharingId":"jotspot_page","codeembeds":{"outerIframeSrc":"https://www.gstatic.com/jotspot/embeds/code/0f08d42392f2000e7e3f3daf5b427a43/outer_iframe.html","innerIframeSrc":"https://331832557-jotspot-embeds.googleusercontent.com/code/8d87fa64604b2a11fae2ed06104c58d3/inner_iframe.html"},"enableUniversalAnalytics":false,"sharingPolicy":"OPENED","siteTitle":"sridharkritha","experiments":{"enableSubpagesGadgetInTakeout":true,"DisableSiteEditingFeature__disable_site_editing":true,"disableDomainEditing":false},"jot2atari":{"eligibility":"INELIGIBLE"},"onepickUrl":"https://docs.google.com/picker","adsensePublisherId":null,"features":{"moreMobileStyleImprovements":null,"subscriptionDataMigrationInProgress":null,"plusBadge":false},"configProperties":{"disableSiteEditing":null},"isPublic":true,"newSitesBaseUrl":"https://sites.google.com","isConsumer":true,"serverFlags":{"jot2AtariLearnMoreUrl":"https://support.google.com/sites/answer/7035197"},"domainAnalyticsAccountId":"","plusPageId":"","signInUrl":"https://accounts.google.com/AccountChooser?continue\u003dhttps://sites.google.com/site/sridharkritha/handyconcepts/cppnuts/threads\u0026service\u003djotspot","analyticsAccountId":"","scottyUrl":"/_/upload","homePath":"/","siteNoticeUrlEnabled":null,"plusPageUrl":"","adsensePromoClickedOrSiteIneligible":true,"csiReportUri":"https://gg.google.com/csi","sharingId":"jotspot","termsUrl":"//www.google.com/intl/en/policies/terms/","gvizVersion":1,"editorResources":{"sitelayout":["https://ssl.gstatic.com/sites/p/a71eef/system/app/css/sitelayouteditor.css"],"text":["https://ssl.gstatic.com/sites/p/a71eef/system/js/codemirror.js","../../../../../ssl.gstatic.com/sites/p/a71eef/system/app/css/codemirror_css.css","../../../../../ssl.gstatic.com/sites/p/a71eef/system/js/trog_edit__en.js","../../../../../ssl.gstatic.com/sites/p/a71eef/system/app/css/trogedit.css","../../_/rsrc/1624520311000/system/app/css/editor.css","../../../../../ssl.gstatic.com/sites/p/a71eef/system/app/css/codeeditor.css","/site/sridharkritha/_/rsrc/1624520311000/system/app/css/camelot/editor-jfk.css"]},"sharingUrlPrefix":"/_/sharing","isAdsenseEnabled":true,"domain":"defaultdomain","baseUri":"/site/sridharkritha","name":"sridharkritha","siteTemplateId":false,"siteNoticeRevision":null,"siteNoticeUrlAddress":null,"siteNoticeMessage":null,"page":{"isRtlLocale":false,"canDeleteWebspace":null,"isPageDraft":null,"parentPath":"/handyconcepts/cppnuts","parentWuid":"wuid:gx:7829b045d8bd715f","siteLocale":"en","timeZone":"America/Los_Angeles","type":"text","title":"Threads","locale":"en","wuid":"wuid:gx:58672c9059d4a6f9","revision":23,"path":"/handyconcepts/cppnuts/threads","isSiteRtlLocale":false,"pageInheritsPermissions":null,"name":"threads","canChangePath":true,"state":"","properties":{},"bidiEnabled":false,"currentTemplate":{"path":"/system/app/pagetemplates/text","title":"Web Page"}},"canPublishScriptToAnyone":true,"user":{"keyboardShortcuts":true,"sessionIndex":"","guest_":true,"displayNameOrEmail":"guest","userName":"guest","uid":"","renderMobile":false,"domain":"","namespace":"","hasWriteAccess":false,"namespaceUser":false,"primaryEmail":"guest","hasAdminAccess":false},"gadgets":{"baseUri":"/site/sridharkritha/system/app/pages/gadgets"}};
  webspace.page.breadcrumbs = breadcrumbs;

  
  var JOT_siteRelTimeStrs = ["a minute ago","__duration__ minutes ago","an hour ago","__duration__ hours ago"];

</script>
<script type="text/javascript">
                window.jstiming.load.tick('scl');
              </script>
<meta name="title" content="Threads - sridharkritha" />
<meta itemprop="name" content="Threads - sridharkritha" />
<meta property="og:title" content="Threads - sridharkritha" />
<meta name="description" content="Information Bank - Computer Science" />
<meta itemprop="description" content="Information Bank - Computer Science" />
<meta id="meta-tag-description" property="og:description" content="Information Bank - Computer Science" />
<style type="text/css">
</style>
<link rel="stylesheet" type="text/css" href="../../../../../ssl.gstatic.com/sites/p/a71eef/system/app/themes/ember/standard-css-ember-ltr-ltr.css" />
<link rel="stylesheet" type="text/css" href="../../_/rsrc/1624520311000/system/app/css/overlaydd2a.css?cb=ember150goog-ws-noside" />
<link rel="stylesheet" type="text/css" href="../../_/rsrc/1624520311000/system/app/css/camelot/allthemes-view.css" />
<!--[if IE]>
          <link rel="stylesheet" type="text/css" href="/site/sridharkritha/system/app/css/camelot/allthemes%2die.css" />
        <![endif]-->
<title>Threads - sridharkritha</title>
<script type="text/javascript">
                window.jstiming.load.tick('cl');
              </script>
</head>
<body xmlns="http://www.google.com/ns/jotspot" id="body" class=" en            ">
<div id="sites-page-toolbar" class="sites-header-divider">
<div xmlns="http://www.w3.org/1999/xhtml" id="sites-status" class="sites-status" style="display:none;"><div id="sites-notice" class="sites-notice" role="status" aria-live="assertive"> </div></div>
</div>
<div id="sites-chrome-everything-scrollbar">
<div id="sites-chrome-everything" class="">
<div id="sites-chrome-page-wrapper" style="direction: ltr">
<div id="sites-chrome-page-wrapper-inside">
<div xmlns="http://www.w3.org/1999/xhtml" id="sites-chrome-header-wrapper" style="">
<table id="sites-chrome-header" class="sites-layout-hbox" cellspacing="0" style="">
<tr class="sites-header-primary-row" id="sites-chrome-userheader">
<td id="sites-header-title" class="" role="banner"><div class="sites-header-cell-buffer-wrapper"><h2></h2></div></td><td class="sites-layout-searchbox  "></td>
</tr>
<tr class="sites-header-secondary-row" id="sites-chrome-horizontal-nav">
<td colspan="2" id="sites-chrome-header-horizontal-nav-container" role="navigation">
</td>
</tr>
</table>
</div>
<div id="sites-chrome-main-wrapper">
<div id="sites-chrome-main-wrapper-inside">
<table id="sites-chrome-main" class="sites-layout-hbox" cellspacing="0" cellpadding="{scmCellpadding}" border="0">
<tr>
<td id="sites-chrome-sidebar-left" class="sites-layout-sidebar-left" style="display: none; width: 150px">
</td>
<td id="sites-canvas-wrapper">
<div id="sites-canvas" role="main">
<div id="goog-ws-editor-toolbar-container"> </div>
<div xmlns="http://www.w3.org/1999/xhtml" id="title-crumbs" style="">
<A href="../../handyconcepts.html" dir="ltr">handyconcepts</A>‎ &gt; ‎<A href="../cppnuts.html" dir="ltr">CppNuts</A>‎ &gt; ‎
  </div>
<h3 xmlns="http://www.w3.org/1999/xhtml" id="sites-page-title-header" style="" align="left">
<span id="sites-page-title" dir="ltr" tabindex="-1" style="outline: none">Threads</span>
</h3>
<div id="sites-canvas-main" class="sites-canvas-main">
<div id="sites-canvas-main-content">
<div xmlns="http://www.w3.org/1999/xhtml" class="sites-layout-name-left-sidebar-hf sites-layout-vbox"><div class="sites-layout-tile sites-tile-name-header sites-layout-empty-tile"><div dir="ltr"><br /></div></div><table cellspacing="0" class="sites-layout-hbox"><tbody><tr><td class="sites-layout-tile sites-tile-name-content-1 sites-canvas-sidebar sites-layout-empty-tile"><div dir="ltr"><br /></div></td><td class="sites-layout-tile sites-tile-name-content-2"><div dir="ltr"><div><span style="font-size:13.3333px">///////////////////////////////////////////////////////////////////////////////////////////////////</span></div><div><span style="font-size:13.3333px">Ref: https://www.youtube.com/watch?v=zUy66Bats5c&amp;list=PLk6CEY9XxSIAeK-EAh3hB4fgNvYkYmghp&amp;index=20</span></div><div><span style="font-size:13.3333px">Title: All Threading Concepts In C++ OR C++11 With Code Example</span></div><div><span style="font-size:13.3333px">Channels: CppNuts</span></div><div><span style="font-size:13.3333px">///////////////////////////////////////////////////////////////////////////////////////////////////</span></div><div><span style="font-size:13.3333px"><b>Thread:</b> A lightweight process. To achieve parallelism, <b>divide a process into multiple threads.</b></span></div><div><span style="font-size:13.3333px"><b>main() :</b> Every application there is a default thread called<b> main() thread/process. </b>Inside this, we </span><span style="background-color:transparent">create other threads.</span></div><div><span style="font-size:13.3333px">Ex: 1. <b>Browser </b>has multiple tabs as different threads.</span></div><div><span style="font-size:13.3333px">      2. <b>MS Word,</b> one thread format the text while typing, and another thread will do the spell check.</span></div><div><span style="font-size:13.3333px">      3. <b>Code editor,</b> one thread will do the auto-completion and another will do the syntax check.</span></div><div><span style="font-size:13.3333px">///////////////////////////////////////////////////////////////////////////////////////////////////</span></div><div><span style="font-size:13.3333px">How to <b>find the execution time </b>of a thread? use <b>&lt;chrono&gt;</b></span></div><div>///////////////////////////////////////////////////////////////////////////////////////////////////</div><div><span style="font-size:13.3333px">Which clock should I use from <b>"system_clock"</b> Vs <b>"steady_clock"</b> Vs<b> "high_resolution_clock"</b> ?</span></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div>    Current <span style="color:#9cdcfe">time</span> =&gt;     <span style="color:#4ec9b0">high_resolution_clock</span>::<span style="color:#dcdcaa">now</span>()</div><div>                        <span style="color:#4ec9b0">steady_clock</span>::<span style="color:#dcdcaa">now</span>()</div><div>                        <span style="color:#4ec9b0">system_clock</span>::<span style="color:#dcdcaa">now</span>()</div></div></div><div><span style="font-size:13.3333px"><br /></span></div><div><span style="font-size:13.3333px">Do <b>NOT </b>use <b>high_resolution_clock,</b> as it is an <b>alias </b>for one of these :</span></div><div><span style="font-size:13.3333px">    <b>system_clock:</b>  It is like a <b>regular mobile phone clock</b> - which changes by Day Light Saving</span></div><div><span style="font-size:13.3333px"> <b>   steady_clock : </b>It is like a <b>stopwatch</b>, use it for timing things - <b>You can NOT adjust</b> after it has started.</span></div><div><span style="font-size:13.3333px">///////////////////////////////////////////////////////////////////////////////////////////////////</span></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div><span style="color:#569cd6">    </span><span style="color:#c586c0">#include</span><span style="color:#569cd6"> </span><span style="color:#ce9178">&lt;chrono&gt;</span></div><br /><div>    <span style="color:#569cd6">auto</span> startTime = <span style="color:#4ec9b0">steady_clock</span>::<span style="color:#dcdcaa">now</span>();</div><div><span style="color:#6a9955">    ////////////////////////////////</span></div><div><span style="color:#6a9955">    // Some high intense calculation</span></div><div><span style="color:#6a9955">    /////////////////////////////////</span></div><div>    <span style="color:#569cd6">auto</span> <span style="color:#9cdcfe">endTime</span> = <span style="color:#4ec9b0">steady_clock</span>::<span style="color:#dcdcaa">now</span>();</div><br /><div>    <span style="color:#569cd6">auto</span> <span style="color:#9cdcfe">diff_microSec</span> = <span style="color:#dcdcaa">duration_cast</span>&lt;<span style="color:#4ec9b0">microseconds</span>&gt;(<span style="color:rgb(156,220,254)">endTime</span> - <span style="color:#9cdcfe">startTime</span>).<span style="color:#dcdcaa">count</span>();</div><div>    <span style="color:#569cd6">auto</span> <span style="color:#9cdcfe">diff_sec</span> = <span style="color:#9cdcfe">diff_microSec</span> / <span style="color:#b5cea8">1e6</span>;</div></div></div><div>///////////////////////////////////////////////////////////////////////////////////////////////////</div><div><span style="font-size:13.3333px">How to represent <b>second </b>in &lt;chrono&gt; ?</span></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div><span style="color:rgb(78,201,176)"><span>    </span>std</span>::<span style="color:rgb(78,201,176)">chrono</span>::<span style="color:rgb(220,220,170)">seconds</span>(<span style="color:rgb(181,206,168)">1</span>);<span style="color:rgb(106,153,85)"> // reperesent 1 second using chrono</span><span style="color:rgb(78,201,176)">  </span><span style="color:rgb(78,201,176)">    </span></div></div></div><div><span style="font-size:13.3333px"><br /></span></div><div><span style="font-size:13.3333px">Usage:</span></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div><span style="color:rgb(78,201,176)"><span>    </span>std</span>::<span style="color:rgb(78,201,176)">this_thread</span>::<span style="color:rgb(220,220,170)">sleep_for</span>(<span style="color:rgb(78,201,176)">chrono</span>::<span style="color:rgb(220,220,170)">seconds</span>(<span style="color:rgb(181,206,168)">2</span>));<span style="color:rgb(106,153,85)"> // current thread wait 2 sec before going to next line.</span><span style="color:rgb(78,201,176)"> </span></div></div></div><div><span style="background-color:transparent">///////////////////////////////////////////////////////////////////////////////////////////////////</span></div><div><span style="font-size:13.3333px"><b>Find odd and even sum using threads ( Function pointers approach):</b></span></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div><span style="color:#569cd6">    </span><span style="color:#c586c0">#include</span><span style="color:#ce9178">&lt;chrono&gt;</span></div><div><span style="color:#569cd6">    </span><span style="color:#c586c0">#include</span><span style="color:#ce9178">&lt;thread&gt;</span></div><br /><div>    <span style="color:#c586c0">using</span> <span style="color:#4ec9b0">ull</span> = <span style="color:#569cd6">unsigned</span> <span style="color:#569cd6">long</span> <span style="color:#569cd6">long</span>;</div><div>    <span style="color:#4ec9b0">ull</span> <span style="color:#9cdcfe">n</span> = <span style="color:#b5cea8">19e8</span>;<span style="color:#6a9955"> </span></div><div>    <span style="color:#4ec9b0">ull</span> <span style="color:#9cdcfe">sumO</span> = <span style="color:#b5cea8">0</span>;</div><div>    <span style="color:#4ec9b0">ull</span> <span style="color:#9cdcfe">sumE</span> = <span style="color:#b5cea8">0</span>;</div><br /><div>    <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">oddSum</span>(<span style="color:#4ec9b0">ull</span> <span style="color:#9cdcfe">n</span>) {</div><div>        <span style="color:#9cdcfe">n</span> = <span style="color:#9cdcfe">n</span> + <span style="color:#b5cea8">1</span>;<span style="color:#6a9955">         // MUST bcos while starts with "n--"</span></div><div>        <span style="color:#c586c0">while</span> (<span style="color:#9cdcfe">n</span>-- &gt; <span style="color:#b5cea8">0</span>) {  <span style="color:rgb(106,153,85)">// n--&gt;0 pattern</span></div><div>            <span style="color:#c586c0">if</span> (<span style="color:#9cdcfe">n</span> &amp; <span style="color:#b5cea8">1</span>) <span style="color:#9cdcfe">sumO</span> += <span style="color:#9cdcfe">n</span>;</div><div>        }</div><div>    }</div><br /><div>    <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">evernSum</span>(<span style="color:#4ec9b0">ull</span> <span style="color:#9cdcfe">n</span>) {</div><div>        <span style="color:#9cdcfe">n</span> = <span style="color:#9cdcfe">n</span> + <span style="color:#b5cea8">1</span>;</div><div>        <span style="color:#c586c0">while</span> (<span style="color:#9cdcfe">n</span>-- &gt; <span style="color:#b5cea8">0</span>) {</div><div>            <span style="color:#c586c0">if</span> ((<span style="color:#9cdcfe">n</span> &amp; <span style="color:#b5cea8">1</span>) == <span style="color:#b5cea8">0</span>) <span style="color:#9cdcfe">sumE</span> += <span style="color:#9cdcfe">n</span>;<span style="color:#6a9955"> // bracket (&amp;) is MUST</span></div><div>        }</div><div>    }</div><br /><div><span style="color:#6a9955">    </span></div><div>    <span style="color:#569cd6">int</span> <span style="color:#dcdcaa">main</span>() {</div><div>        <span style="color:#569cd6">auto</span> <span style="color:#9cdcfe">startTime</span> = <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">chrono</span>::<span style="color:#4ec9b0">steady_clock</span>::<span style="color:#dcdcaa">now</span>();</div><br /><div><span style="color:#6a9955">        // 1. Without threads</span></div><div><div style="line-height:22px"><div>        <span style="color:#dcdcaa">oddSum</span>(n);</div><div>        <span style="color:#dcdcaa">evernSum</span>(n);</div></div></div><br /><div><span style="color:#6a9955">        // 2. With threads - 1. using function pointer</span></div><div><span style="color:rgb(106,153,85)">// Note: If you create multiple threads one after another then C++ does NOT guarantee which one will </span><span style="color:rgb(106,153,85)">start first.</span></div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">thread</span> <span style="color:#9cdcfe">t1</span>(<span style="color:rgb(220,220,170)">oddSum</span>,<span style="color:#9cdcfe">n</span>);<span style="color:#6a9955"> // functionPointer, functionParams...</span></div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">thread</span> <span style="color:#9cdcfe">t2</span>(<span style="color:#dcdcaa">evernSum</span>,<span style="color:#9cdcfe">n</span>);</div><div>        <span style="color:#9cdcfe">t1</span>.<span style="color:#dcdcaa">join</span>();<span style="color:#6a9955">                // ask main() thread to wait until 't1' finish its task.</span></div><div>        <span style="color:#9cdcfe">t2</span>.<span style="color:#dcdcaa">join</span>();<span style="color:#6a9955">                // ask main() thread to wait until 't2' finish its task.</span></div><br /><div>        cout &lt;&lt; <span style="color:#9cdcfe">sumO</span> &lt;&lt; endl;</div><div>        cout &lt;&lt; <span style="color:#9cdcfe">sumE</span> &lt;&lt; endl;</div><br /><div>        <span style="color:#569cd6">auto</span> <span style="color:#9cdcfe">EndTime</span> = <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">chrono</span>::<span style="color:#4ec9b0">steady_clock</span>::<span style="color:#dcdcaa">now</span>();</div><div>        <span style="color:#569cd6">auto</span> <span style="color:#9cdcfe">durationMSec</span> = <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">chrono</span>::<span style="color:#dcdcaa">duration_cast</span>&lt;<span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">chrono</span>::<span style="color:#4ec9b0">microseconds</span>&gt;(<span style="color:#9cdcfe">EndTime</span> <span style="color:#dcdcaa">-</span> <span style="color:#9cdcfe">startTime</span>).<span style="color:#dcdcaa">count</span>();</div><div>        <span style="color:#569cd6">auto</span> <span style="color:#9cdcfe">durationSec</span> = <span style="color:#9cdcfe">durationMSec</span> / <span style="color:#b5cea8">1000000.0</span>;<span style="color:#6a9955"> // microseconds(1e6) =&gt; seconds(1)</span></div><div>        cout &lt;&lt; <span style="color:#9cdcfe">durationSec</span> &lt;&lt; <span style="color:#ce9178">" seconds"</span>;</div><div>    }</div></div></div><div><span style="font-size:13.3333px">///////////////////////////////////////////////////////////////////////////////////////////////////</span></div><div><span style="font-size:13.3333px"><b>promise &amp; future</b> Application:</span></div><div><span style="font-size:13.3333px">1. Using these, <b>a thread can return a value.</b></span></div><div><span style="font-size:13.3333px"><br /></span></div><div><span style="font-size:13.3333px"><b>std::promise </b>- Like a container <b>having std::futute in it.</b></span></div><div><span style="font-size:13.3333px"><span style="white-space:pre"> </span>1. Used to '<b>set' values </b>or exceptions.</span></div><div><span style="font-size:13.3333px"><br /></span></div><div><span style="font-size:13.3333px"><b>std::future</b></span></div><div><span style="font-size:13.3333px"><span style="white-space:pre"> </span>1. Used to <b>'get' </b>values <b>from </b>the <b>promise.</b></span></div><div><span style="font-size:13.3333px"><span style="white-space:pre"> </span>2. Ask promise if the value is available.</span></div><div><span style="font-size:13.3333px"><span style="white-space:pre"> </span>3. Wait for the promise</span></div><div><span style="font-size:13.3333px">///////////////////////////////////////////////////////////////////////////////////////////////////</span></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div><span style="color:#569cd6">    </span><span style="color:#c586c0">#include</span><span style="color:#569cd6"> </span><span style="color:#ce9178">&lt;future&gt;</span><span style="color:#569cd6">   </span><span style="color:#6a9955">// there is NO &lt;promise&gt; header</span></div><div>    <span style="color:#c586c0">using</span> <span style="color:#4ec9b0">ull</span> = <span style="color:#569cd6">unsigned</span> <span style="color:#569cd6">long</span> <span style="color:#569cd6">long</span>;</div><div>    <span style="color:#4ec9b0">ull</span> <span style="color:#9cdcfe">n</span> = <span style="color:#b5cea8">19e8</span>;</div><br /><div>    <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">oddSum</span>(<span style="color:#4ec9b0">ull</span> <span style="color:#9cdcfe">n</span>, <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">promise</span>&lt;<span style="color:#4ec9b0">ull</span>&gt;<span style="color:#569cd6">&amp;&amp;</span> <span style="color:#9cdcfe">pro</span>) {</div><div>        <span style="color:#9cdcfe">n</span> = <span style="color:#9cdcfe">n</span> + <span style="color:#b5cea8">1</span>;</div><div>        <span style="color:#4ec9b0">ull</span> <span style="color:#9cdcfe">sumO</span> = <span style="color:#b5cea8">0</span>;</div><div>        <span style="color:#c586c0">while</span> (<span style="color:#9cdcfe">n</span>-- &gt; <span style="color:#b5cea8">0</span>) {</div><div>            <span style="color:#c586c0">if</span> (<span style="color:#9cdcfe">n</span> &amp; <span style="color:#b5cea8">1</span>) <span style="color:#9cdcfe">sumO</span> += <span style="color:#9cdcfe">n</span>;</div><div>        }</div><br /><div>        <span style="color:#9cdcfe">pro</span>.<span style="color:#dcdcaa">set_value</span>(<span style="color:#9cdcfe">sumO</span>);  <span style="color:rgb(106,153,85)">// set value using promise</span></div><div>    }</div><div><br /></div><div>    <span style="color:#569cd6">int</span> <span style="color:#dcdcaa">main</span>() {</div><div>        <span style="color:#4ec9b0">std</span>::promise&lt;<span style="color:#4ec9b0">ull</span>&gt; pro;</div><div>        <span style="color:#4ec9b0">std</span>::future&lt;<span style="color:#4ec9b0">ull</span>&gt; fut = <span style="color:#9cdcfe">pro</span>.<span style="color:#dcdcaa">get_future</span>();    <span style="color:rgb(106,153,85)">// get future from the promise</span></div><div>        </div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">thread</span> <span style="color:#9cdcfe">t1</span>(oddSum, <span style="color:#9cdcfe">n</span> , <span style="color:#4ec9b0">std</span>::<span style="color:#dcdcaa">move</span>(pro)); <span style="color:rgb(106,153,85)">// move bcos one ownership NOT shared</span></div><div>        cout &lt;&lt; <span style="color:#ce9178">"Waiting for a return from the already started thread:...</span><span style="color:#d7ba7d">\n</span><span style="color:#ce9178">"</span>;</div><div>        cout &lt;&lt; <span style="color:#9cdcfe">fut</span>.<span style="color:#dcdcaa">get</span>();<span style="color:#6a9955"> // waiting and get value using future</span></div><div>        cout &lt;&lt; <span style="color:#ce9178">"</span><span style="color:#d7ba7d">\n</span><span style="color:#ce9178"> Completed!"</span>;</div><br /><div>        <span style="color:#9cdcfe">t1</span>.<span style="color:#dcdcaa">join</span>();<span style="color:#6a9955">         // MUST eventhough you are waiting using future on previous line</span></div><div>    }</div></div></div><div><span style="font-size:13.3333px">///////////////////////////////////////////////////////////////////////////////////////////////////</span></div><div><span style="font-size:13.3333px"><b>std::async:</b> (<b>ONLY future </b>is needed. <b>NO need</b> for explicit <b>promise </b>and <b>thread</b>)</span></div><div><span style="font-size:13.3333px">Easy to write compare to promise.</span></div><div><span style="font-size:13.3333px"><span style="white-space:pre"> </span>1. It runs a function asynchronously (using <b>internally created thread and promise for you</b>).</span></div><div><span style="font-size:13.3333px"><span style="white-space:pre"> </span>2. It returns std::future that will hold the result.</span></div><div><span style="font-size:13.3333px"><span style="white-space:pre"> </span>3. Types of <b>launch policies</b> used to start the created thread.</span></div><div><span style="font-size:13.3333px"><span style="white-space:pre"> </span>1. <b>std::launch::async</b>      - starts the thread <b>instantly</b></span></div><div><span style="font-size:13.3333px"><span style="white-space:pre"> </span>2. <b>std::launch::deffered  </b>- starts only at <b>fut.gets()</b></span></div><div><span style="font-size:13.3333px"><span style="white-space:pre"> </span>3. <b>std::launch::asynch | std::launch::deffered </b>- leave it </span><span style="background-color:transparent;font-size:10pt">to</span><span style="background-color:transparent;font-size:10pt"> </span><span style="background-color:transparent">system to decided which one is best!</span></div><div><span style="font-size:13.3333px">///////////////////////////////////////////////////////////////////////////////////////////////////</span></div><div><span style="font-size:13.3333px"><b>How does it work?</b></span></div><div><span style="font-size:13.3333px">1. It <b>automatically creates</b> a std::promise object and thread( from internal thread pool) for us.</span></div><div><span style="font-size:13.3333px">2. Then <b>passes </b>the <b>std::promise</b> object to the thread function and <b>return </b>the associated <b>std::future </b>object.</span></div><div><span style="font-size:13.3333px">3. When our passed argument function exists then its value will be set in this promise object, </span></div><div><span style="font-size:13.3333px">    so eventually, return value will be available in std::future object.</span></div><div><span style="font-size:13.3333px"><br /></span></div><div><span style="font-size:13.3333px"><b>Note: </b>We can send <b>functor </b>and <b>lambda function </b>as a callback to std::async. It will work the same.</span></div><div><span style="font-size:13.3333px">///////////////////////////////////////////////////////////////////////////////////////////////////</span></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div style="line-height:22px"><div><span style="color:#c586c0">#include</span><span style="color:#569cd6"> </span><span style="color:#ce9178">&lt;future&gt;</span><span style="color:#569cd6">   </span><span style="color:#6a9955">// async, future, promise</span></div><div><span style="color:#c586c0">using</span> <span style="color:#4ec9b0">ull</span> = <span style="color:#569cd6">unsigned</span> <span style="color:#569cd6">long</span> <span style="color:#569cd6">long</span>;</div><div><span style="color:#4ec9b0">ull</span> <span style="color:#dcdcaa">oddSum</span>(<span style="color:#4ec9b0">ull</span> <span style="color:#9cdcfe">n</span>) {</div><div>    <span style="color:#9cdcfe">n</span> = <span style="color:#9cdcfe">n</span> + <span style="color:#b5cea8">1</span>;<span style="color:#6a9955"> </span></div><div>    <span style="color:#4ec9b0">ull</span> <span style="color:#9cdcfe">sumO</span> = <span style="color:#b5cea8">0</span>;</div><div>    <span style="color:#c586c0">while</span> (<span style="color:#9cdcfe">n</span>-- &gt; <span style="color:#b5cea8">0</span>) {</div><div>        <span style="color:#c586c0">if</span> (<span style="color:#9cdcfe">n</span> &amp; <span style="color:#b5cea8">1</span>) <span style="color:#9cdcfe">sumO</span> += <span style="color:#9cdcfe">n</span>;</div><div>    }</div><br /><div>    <span style="color:#c586c0">return</span> <span style="color:#9cdcfe">sumO</span>; <span style="color:rgb(106,153,85)">// just return like a normal function - NOTHING fancy things !!!</span></div><div>}</div><br /><div><span style="color:#569cd6">int</span> <span style="color:#dcdcaa">main</span>() {</div><div>    <span style="color:#4ec9b0">ull</span> <span style="color:#9cdcfe">n</span> = <span style="color:#b5cea8">19e8</span>;</div><br /><div><span style="color:#6a9955">    //std::promise&lt;ull&gt; pro;</span></div><div><span style="color:#6a9955">    //std::future&lt;ull&gt; fut = pro.get_future();</span></div><br /><div><span style="color:#6a9955">    // async - creates an intenal thread and promise for you so NO need to create those explicitly.</span></div><div>    <span style="color:#4ec9b0">std</span>::future&lt;<span style="color:#4ec9b0">ull</span>&gt; fut = <span style="color:#4ec9b0">std</span>::<span style="color:#dcdcaa">async</span>(<span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">launch</span>::deferred, &amp;oddSum, <span style="color:#9cdcfe">n</span>);<span style="color:#6a9955"> // fut: future, return type is 'ull'</span></div><div><span style="color:#6a9955">    // std::future&lt;ull&gt; fut = std::async(std::launch::async, &amp;oddSum, n); // Unlike deferrred, internal thread </span></div><div><span style="color:#6a9955">                                                                          // starts immediately here </span></div><br /><div>    cout &lt;&lt; <span style="color:#ce9178">"Waiting for a return from the already started thread:...</span><span style="color:#d7ba7d">\n</span><span style="color:#ce9178">"</span>;</div><div>    cout &lt;&lt; <span style="color:#9cdcfe">fut</span>.<span style="color:#dcdcaa">get</span>();<span style="color:#6a9955"> // if deferred -&gt; internal thread </span><span style="color:rgb(106,153,85)">only starts </span><span style="color:rgb(106,153,85)">here and then wait for the return value</span></div><div>    cout &lt;&lt; <span style="color:#ce9178">"</span><span style="color:#d7ba7d">\n</span><span style="color:#ce9178"> Completed!"</span>;</div><div>}</div></div></div></div><div><span style="font-size:13.3333px">///////////////////////////////////////////////////////////////////////////////////////////////////</span></div><div><span style="font-size:13.3333px"><b>5 different ways to create Threads in C++11:</b></span></div><div><span style="font-size:13.3333px">    1. Function Pointers</span></div><div><span style="font-size:13.3333px">    2. Lambda Functions</span></div><div><span style="font-size:13.3333px">    3. Functors</span></div><div><span style="font-size:13.3333px">    4. Member functions</span></div><div><span style="font-size:13.3333px">    5. Static Member functions.</span></div><div><span style="font-size:13.3333px">///////////////////////////////////////////////////////////////////////////////////////////////////</span></div><div><span style="font-size:13.3333px"><b>1. Function Pointer: </b>Very basic form of thread creation</span></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div>    <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">fun</span>(<span style="color:#569cd6">int</span> <span style="color:#9cdcfe">x</span>) {</div><div>        <span style="color:#c586c0">while</span> (x-- &gt; <span style="color:#b5cea8">0</span>) cout &lt;&lt; x;<span style="color:#6a9955">    // 4 3 2 1 0 (#5 times loops)</span></div><div><span style="color:#6a9955">     // while (--x &gt; 0) cout &lt;&lt; x;    // 4 3 2 1   </span><span style="color:rgb(106,153,85)">(#4 times loops)</span></div><div>    }</div><br /><div>    <span style="color:#569cd6">int</span> <span style="color:#dcdcaa">main</span>() {</div><div>        <span style="color:#4ec9b0">std</span>::thread <span style="color:#dcdcaa">t</span>(fun, <span style="color:#b5cea8">5</span>);</div><div>        <span style="color:#9cdcfe">t</span>.<span style="color:#dcdcaa">join</span>();</div><div>    }</div></div></div><div><span style="font-size:13.3333px">///////////////////////////////////////////////////////////////////////////////////////////////////</span></div><div><span style="font-size:13.3333px"><b>2. Lambda Function</b></span></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div>    <span style="color:#569cd6">auto</span> fun = [](<span style="color:#569cd6">int</span> <span style="color:#9cdcfe">x</span>) {<span style="color:#6a9955">         // OK for auto but 'NOT' like =&gt; void fun = [](int x) { } </span></div><div>        <span style="color:#c586c0">while</span> (x-- &gt; <span style="color:#b5cea8">0</span>) cout &lt;&lt; x; <span style="color:#6a9955">// 4 3 2 1 0</span></div><div>    };<span style="color:#6a9955"> // semicolon MUST bcos it is an Expression</span></div><br /><div>    <span style="color:#569cd6">int</span> <span style="color:#dcdcaa">main</span>() {</div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">thread</span> <span style="color:#9cdcfe">t</span>(fun, <span style="color:#b5cea8">5</span>);</div><div>        <span style="color:#9cdcfe">t</span>.<span style="color:#dcdcaa">join</span>();</div><div>    }</div><br /><div><span style="color:#6a9955">    // Method 2: You can directly inject the lambda function at thread creation time.</span></div><div>    <span style="color:#569cd6">int</span> <span style="color:#dcdcaa">main</span>() {</div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">thread</span> <span style="color:#9cdcfe">t</span>([](<span style="color:#569cd6">int</span> <span style="color:#9cdcfe">x</span>) { <span style="color:#c586c0">while</span> (<span style="color:#9cdcfe">x</span>-- &gt; <span style="color:#b5cea8">0</span>) cout &lt;&lt; <span style="color:#9cdcfe">x</span>; }, <span style="color:#b5cea8">5</span>);</div><div>        <span style="color:#9cdcfe">t</span>.<span style="color:#dcdcaa">join</span>();</div><div>    }</div></div></div><div><span style="font-size:13.3333px">///////////////////////////////////////////////////////////////////////////////////////////////////</span></div><div><span style="font-size:13.3333px"><b>3. Functor (Function Object):</b></span></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div>    <span style="color:#569cd6">struct</span> <span style="color:#4ec9b0">Base</span> {</div><div>        <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">operator()</span>(<span style="color:#569cd6">int</span> <span style="color:#9cdcfe">x</span>) {        <span style="color:rgb(106,153,85)">// NO return type - operator overloading</span></div><div>            <span style="color:#c586c0">while</span> (<span style="color:#9cdcfe">x</span>-- &gt; <span style="color:#b5cea8">0</span>) cout &lt;&lt; <span style="color:#9cdcfe">x</span>;</div><div>        }</div><div>    };</div><br /><div>    <span style="color:#569cd6">int</span> <span style="color:#dcdcaa">main</span>() {</div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">thread</span> <span style="color:#9cdcfe">t</span>(<span style="color:#4ec9b0">Base</span>(), <span style="color:#b5cea8">5</span>);</div><div>        <span style="color:#9cdcfe">t</span>.<span style="color:#dcdcaa">join</span>();</div><div>    }</div></div></div><div><span style="font-size:13.3333px">///////////////////////////////////////////////////////////////////////////////////////////////////</span></div><div><span style="font-size:13.3333px"><b>4. Non-static Member function</b></span></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div>    <span style="color:#569cd6">struct</span> <span style="color:#4ec9b0">Base</span> {</div><div>        <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">fun</span>(<span style="color:#569cd6">int</span> <span style="color:#9cdcfe">x</span>) {</div><div>            <span style="color:#c586c0">while</span> (<span style="color:#9cdcfe">x</span>-- &gt; <span style="color:#b5cea8">0</span>) cout &lt;&lt; <span style="color:#9cdcfe">x</span>;</div><div>        }</div><div>    };</div><br /><div>    <span style="color:#569cd6">int</span> <span style="color:#dcdcaa">main</span>() {</div><div>        <span style="color:#4ec9b0">Base</span> <span style="color:#9cdcfe">b</span>; <span style="color:rgb(106,153,85)">// MUST</span></div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">thread</span> <span style="color:#9cdcfe">t</span>(&amp;<span style="color:#4ec9b0">Base</span>::<span style="color:#dcdcaa">fun</span>, &amp;<span style="color:#9cdcfe">b</span>, <span style="color:#b5cea8">5</span>);<span style="color:#6a9955"> // callableObject, object, params</span></div><div>        <span style="color:#9cdcfe">t</span>.<span style="color:#dcdcaa">join</span>();</div><div>    }</div></div></div><div><span style="font-size:13.3333px">///////////////////////////////////////////////////////////////////////////////////////////////////</span></div><div><span style="font-size:13.3333px"><b>5. Static member function</b></span></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div>    <span style="color:#569cd6">struct</span> <span style="color:#4ec9b0">Base</span> {</div><div>        <span style="color:#569cd6">static</span> <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">fun</span>(<span style="color:#569cd6">int</span> <span style="color:#9cdcfe">x</span>) {</div><div>            <span style="color:#c586c0">while</span> (<span style="color:#9cdcfe">x</span>-- &gt; <span style="color:#b5cea8">0</span>) cout &lt;&lt; <span style="color:#9cdcfe">x</span>;</div><div>        }</div><div>    };</div><br /><div>    <span style="color:#569cd6">int</span> <span style="color:#dcdcaa">main</span>() {</div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">thread</span> <span style="color:#9cdcfe">t</span>(&amp;<span style="color:#4ec9b0">Base</span>::<span style="color:#dcdcaa">fun</span>, <span style="color:#b5cea8">5</span>);<span style="color:#6a9955"> // callableObject, params</span></div><div>        <span style="color:#9cdcfe">t</span>.<span style="color:#dcdcaa">join</span>();</div><div>    }</div></div></div><div><span style="font-size:13.3333px">///////////////////////////////////////////////////////////////////////////////////////////////////</span></div><div><span style="font-size:13.3333px"><b>What are join(), detach() and joinable() ?</b></span></div><div><span style="font-size:13.3333px"><b>join:</b></span></div><div><span style="font-size:13.3333px"><span>    </span>1. Once a thread 't' is started we have to wait for the thead 't' to finish by calling a join() function on thread object inside parent/main() thread/process.</span></div><div><span style="font-size:13.3333px"><span>    </span>2. <b>Double join will crash</b> at <b>run time</b> ( <b>NO</b> compile time error ).</span></div><div><span style="font-size:13.3333px"><span>    </span>3. To <b>avoid </b>double join problem. You could <b>check </b>the thread is <b>joinable or not </b>before joining (using joinable() function).</span></div><div><span style="font-size:13.3333px"><br /></span></div><div><span style="font-size:13.3333px"><b>detach:</b></span></div><div><span style="font-size:13.3333px"><span style="white-space:pre"> </span>1. Used to detach newly created thread <b>from the parent thread.</b></span></div><div><span style="font-size:13.3333px"><span style="white-space:pre"> </span>2. Just like double join, <b>double detach will crash</b> at run time(NO compile time error).</span></div><div><span style="font-size:13.3333px"><span style="white-space:pre"> </span>3. To <b>avoid </b>double detach problem. Check using <b>joinable() method </b>and then do detach.</span></div><div><span style="font-size:13.3333px"><span style="white-space:pre"> </span>4. detach thread gets <b>terminated </b>immediatly once the <b>main() is finished. </b></span></div><div><span style="font-size:13.3333px">///////////////////////////////////////////////////////////////////////////////////////////////////</span></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div style="line-height:22px"><div>    <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">run</span>(<span style="color:#569cd6">int</span> <span style="color:#9cdcfe">n</span>) {</div><div>        <span style="color:#c586c0">while</span> (n-- &gt; <span style="color:#b5cea8">0</span>) cout &lt;&lt; n;<span style="color:#6a9955"> // prints values until main()/parent thread is alive</span></div><div>    }</div><br /><div>    <span style="color:#569cd6">int</span> <span style="color:#dcdcaa">main</span>() {</div><div>        <span style="color:#4ec9b0">std</span>::thread <span style="color:#dcdcaa">t</span>(run, <span style="color:#b5cea8">5</span>);</div><div>        cout &lt;&lt; <span style="color:#ce9178">"Main() - Start"</span> &lt;&lt; endl;</div><div>        <span style="color:#9cdcfe">t</span>.<span style="color:#dcdcaa">join</span>();<span style="color:#6a9955">    // main() wait until thread 't' completion</span></div><div><span style="color:#6a9955">        // t.join(); // double join problem - NO compilation Error but Runtime error</span></div><div>        <span style="color:#c586c0">if</span> (<span style="color:#9cdcfe">t</span>.<span style="color:#dcdcaa">joinable</span>()) <span style="color:#9cdcfe">t</span>.<span style="color:#dcdcaa">join</span>();<span style="color:#6a9955"> // safe to have any no. of join</span></div><div>        cout &lt;&lt; <span style="color:#ce9178">"Main() - End"</span>;</div><div>    }</div></div></div></div><div><span style="background-color:transparent">Output:</span></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div><span style="color:#6a9955">    Main() - Start</span></div><div><span style="color:#6a9955">    4 3 2 1 0</span></div><div><span style="color:#6a9955">    Main() - End</span></div></div></div><div><span style="background-color:transparent">///////////////////////////////////////////////////////////////////////////////////////////////////</span></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div style="line-height:22px"><div><span style="color:#6a9955">    // Crashes - if there is NO 'join' and 'detach' after the thread creation</span></div><div>    <span style="color:#569cd6">int</span> <span style="color:#dcdcaa">main</span>() {</div><div>        <span style="color:#4ec9b0">std</span>::thread <span style="color:#dcdcaa">t</span>(run, <span style="color:#b5cea8">100</span>);</div><div><span style="color:#6a9955">        // NO =&gt; t.join(); or t.detach();</span></div><div>        <span style="color:#c586c0">return</span> <span style="color:#b5cea8">0</span>;<span style="color:#6a9955"> // abort() called - crash bcos child thread in operation</span></div><div>    }</div></div></div></div><div><span style="font-size:13.3333px">///////////////////////////////////////////////////////////////////////////////////////////////////</span></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div><span style="color:#6a9955">    // detach()</span></div><div>    <span style="color:#569cd6">int</span> <span style="color:#dcdcaa">main</span>() {</div><div>        <span style="color:#4ec9b0">std</span>::thread <span style="color:#dcdcaa">t</span>(run, <span style="color:#b5cea8">1e4</span>);</div><div>        <span style="color:#9cdcfe">t</span>.<span style="color:#dcdcaa">detach</span>();<span style="color:#6a9955"> // 't' is independent of main() thread but 't' will print value until main() thread is alive.</span></div><div><span style="color:#6a9955">                    // main() thread do NOT care about the tread 't'</span></div><br /><div><span style="color:#6a9955">        // t.detach();  // double detach problem - NO compilation Error but Runtime error</span></div><div>        <span style="color:#c586c0">if</span> (<span style="color:#9cdcfe">t</span>.<span style="color:#dcdcaa">joinable</span>()) <span style="color:#9cdcfe">t</span>.<span style="color:#dcdcaa">detach</span>();<span style="color:#6a9955"> // safe to have any no. of detach</span></div><br /><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">this_thread</span>::<span style="color:#dcdcaa">sleep_for</span>(<span style="color:#4ec9b0">chrono</span>::<span style="color:#dcdcaa">seconds</span>(<span style="color:#b5cea8">1</span>));<span style="color:#6a9955"> // main() thread wait 1 sec before die. </span></div><div>        <span style="color:#c586c0">return</span> <span style="color:#b5cea8">0</span>;<span style="color:#6a9955"> // OK - NO crash </span></div><div>    }</div></div></div><div><span style="font-size:13.3333px">///////////////////////////////////////////////////////////////////////////////////////////////////</span></div><div><span style="font-size:13.3333px"><b>Multi level thread and detach:</b></span></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div>    <span style="color:rgb(86,156,214)">void</span> <span style="color:rgb(220,220,170)">run</span>(<span style="color:rgb(86,156,214)">int</span> <span style="color:rgb(156,220,254)">n</span>) {</div><div>        <span style="color:#c586c0">while</span> (n-- &gt; <span style="color:#b5cea8">0</span>) cout &lt;&lt; n;<span style="color:#6a9955"> // prints values until main() thread is alive (even after the child() </span></div><div>    }                                 <span style="color:rgb(106,153,85)">thread death)</span></div><br /><div>    <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">child</span>() {</div><div>        <span style="color:#4ec9b0">std</span>::thread <span style="color:#dcdcaa">t2</span>(run, <span style="color:#b5cea8">1e4</span>);</div><div>        <span style="color:#9cdcfe">t2</span>.<span style="color:#dcdcaa">detach</span>();<span style="color:#6a9955"> // 't2' still prints even after child() is teminated bcos main() is still alive by sleep_for</span></div><div>    }</div><br /><div>    <span style="color:#569cd6">int</span> <span style="color:#dcdcaa">main</span>() {</div><div>        <span style="color:#4ec9b0">std</span>::thread t1{child};</div><div>        <span style="color:#9cdcfe">t1</span>.<span style="color:#dcdcaa">detach</span>();                 </div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">this_thread</span>::<span style="color:#dcdcaa">sleep_for</span>(<span style="color:#4ec9b0">chrono</span>::<span style="color:#dcdcaa">seconds</span>(<span style="color:#b5cea8">1</span>));<span style="color:#6a9955"> // main() thread wait 1 sec before die. </span></div><div>    }</div></div></div><div><span style="font-size:13.3333px">///////////////////////////////////////////////////////////////////////////////////////////////////</span></div><div><span style="font-size:13.3333px"><b>Race Condition: </b>Situation where 2 or more threads/process happend to change a common data at the same time.</span></div><div><span style="font-size:13.3333px"><b>Critical Section:</b> Section of code is possibly affected by the racing threads. That section is called CS.</span></div><div><span style="font-size:13.3333px">                          You should protect this CS by mutex for exclusive access. </span></div><div><span style="font-size:13.3333px"><b>Mutex: </b>Mutual Exclusion - only one thread at a time can access the critical section.</span></div><div><span style="font-size:13.3333px">    1. Mutex is used to avoid race condition between threads.</span></div><div><span style="font-size:13.3333px">    2. lock() and unlock() on mutex is used to protect the critical section from race condition.</span></div><div><span style="font-size:13.3333px">///////////////////////////////////////////////////////////////////////////////////////////////////</span></div><div><span style="font-size:13.3333px"><b>mu.lock() and mu.unlock():</b></span></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div>    <span style="color:#569cd6">int</span> totalMoney = <span style="color:#b5cea8">0</span>;</div><br /><div><span style="color:#6a9955">    // Problem: Race condition is possible</span></div><div>    <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">addMoney</span>() {</div><div>        ++totalMoney;<span style="color:#6a9955"> // critical section</span></div><div>    }</div><br /><div>    <span style="color:#569cd6">int</span> <span style="color:#dcdcaa">main</span>() {</div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">thread</span> <span style="color:#9cdcfe">t1</span>{ addMoney };</div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">thread</span> <span style="color:#9cdcfe">t2</span>{ addMoney };<span style="color:#6a9955"> // 't2' may start earlier than 't1'</span></div><div>        <span style="color:#9cdcfe">t1</span>.<span style="color:#dcdcaa">join</span>();  </div><div>        <span style="color:#9cdcfe">t2</span>.<span style="color:#dcdcaa">join</span>();</div><div>        cout &lt;&lt; totalMoney;<span style="color:#6a9955"> // without Mutex: prints 1 or 2</span></div><div><span style="color:#6a9955">                            // with Mutex:    prints 2</span></div><div>    }</div></div></div><div><br /></div><div><div><span style="font-size:13.3333px">When the compiler processes ++totalMoney ( <b>totalMoney = totalMoney + 1</b>), <b>reading </b>the current value of totalMoney and <b>setting </b>the updated </span></div><div><span style="font-size:13.3333px">value is <b>NOT an atomic</b> (meaning indivisible) event. </span><span style="background-color:transparent">Let us re-write calculation to capture this:</span></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div>    <span style="color:#569cd6">int</span> temp = totalMoney;</div><div>    temp += <span style="color:#b5cea8">1</span>;</div><div>    totalMoney = temp;</div></div></div><div><span style="font-size:13.3333px"><br /></span></div><div><span style="font-size:13.3333px">Now, let us say the first 2 threads are interleaved over time, giving us something like this (Load-&gt;Process-&gt;Store):</span></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div><span style="color:#6a9955">    // Thread 1                     // Thread 2</span></div><div>    <span style="color:#569cd6">int</span> temp1 = totalMoney;         <span style="color:#569cd6">int</span> temp2 = totalMoney;<span style="color:#6a9955"> // temp1 &amp; temp2 - different but totalMoney is SAME</span></div><div>                                    temp2 += <span style="color:#b5cea8">1</span>;<span style="color:#6a9955">             // temp2 = 1</span></div><div>    temp1 += <span style="color:#b5cea8">1</span>;<span style="color:#6a9955">                                             // temp1 = 1</span></div><div>                                    totalMoney = temp2;<span style="color:#6a9955">     // totalMoney = 1</span></div><div>    totalMoney = temp1;<span style="color:#6a9955">                                     // totalMoney = 1</span></div></div></div><div><span style="font-size:13.3333px">We end up with totalMoney as <b>1, instead of the correct 2.</b></span></div></div><div><span style="font-size:13.3333px">///////////////////////////////////////////////////////////////////////////////////////////////////</span></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div style="line-height:22px"><div><span style="color:#6a9955">    // Solution: mutex</span></div><div><span style="color:#569cd6">    </span><span style="color:#c586c0">#include</span><span style="color:#569cd6"> </span><span style="color:#ce9178">&lt;mutex&gt;</span></div><div>    <span style="color:#4ec9b0">std</span>::mutex <span style="color:#9cdcfe">mu</span>;</div><div>    <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">addMoney</span>() {</div><div>        <span style="color:#9cdcfe">mu</span>.<span style="color:#dcdcaa">lock</span>();<span style="color:#6a9955">    // 1. New thread gets "block" if there is an another already inside the CS.</span></div><div><span style="color:#6a9955">                      // 2. New thread gets "access" if there is NO other thread inside the CS.</span></div><br /><div>        ++totalMoney;<span style="color:#6a9955"> // critical section</span></div><div>        <span style="color:#9cdcfe">mu</span>.<span style="color:#dcdcaa">unlock</span>();</div><div>    }</div></div></div></div><div><span style="font-size:13.3333px">///////////////////////////////////////////////////////////////////////////////////////////////////</span></div><div><span style="font-size:13.3333px">Another Example: <b>Calculate the sum of square?</b></span></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div>    <span style="color:#569cd6">int</span> accum = <span style="color:#b5cea8">0</span>;</div><div>    mutex mu;</div><br /><div>    <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">square</span>(<span style="color:#569cd6">int</span> <span style="color:#9cdcfe">x</span>) {</div><div>        <span style="color:#569cd6">int</span> temp = x * x;<span style="color:#6a9955"> // OK: Bcos different for each thread</span></div><div>        <span style="color:#9cdcfe">mu</span>.<span style="color:#dcdcaa">lock</span>();</div><div>        accum += temp;<span style="color:#6a9955">    // CS: It's common for each thread</span></div><div>        <span style="color:#9cdcfe">mu</span>.<span style="color:#dcdcaa">unlock</span>();</div><div>    }</div><br /><div>    <span style="color:#569cd6">int</span> <span style="color:#dcdcaa">main</span>() {</div><div>        vector&lt;thread&gt; td;</div><div>        <span style="color:#c586c0">for</span> (<span style="color:#569cd6">int</span> i = <span style="color:#b5cea8">1</span>; i &lt;= <span style="color:#b5cea8">5</span>; i++) <span style="color:#9cdcfe">td</span>.<span style="color:#dcdcaa">push_back</span>(<span style="color:#dcdcaa">thread</span>(&amp;square, i));</div><div>    </div><div><span style="color:#6a9955">        // NOT auto const&amp;</span></div><div>        <span style="color:#c586c0">for</span> (<span style="color:#569cd6">auto</span> &amp; t : td) <span style="color:#9cdcfe">t</span>.<span style="color:#dcdcaa">join</span>();</div><br /><div>        cout &lt;&lt; <span style="color:#ce9178">"accum = "</span> &lt;&lt; accum &lt;&lt; endl;<span style="color:#6a9955"> // 55</span></div><div>    }</div><br /></div></div><div>///////////////////////////////////////////////////////////////////////////////////////////////////</div><div><div><span style="font-size:13.3333px"><b>Atomic: </b></span><span style="background-color:transparent">C++11 offers even nicer abstractions to solve this problem. For instance, the atomic container:</span></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div><span style="color:#569cd6">    </span><span style="color:#c586c0">#include</span><span style="color:#569cd6"> </span><span style="color:#ce9178">&lt;atomic&gt;</span></div><br /><div>    <span style="color:#4ec9b0">atomic</span>&lt;<span style="color:#569cd6">int</span>&gt; <span style="color:#dcdcaa">accum</span>(<span style="color:#b5cea8">0</span>);</div><br /><div>    <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">square</span>(<span style="color:#569cd6">int</span> <span style="color:#9cdcfe">x</span>) {</div><div>        accum += x * x;</div><div>    }</div></div></div><div><span style="font-size:13.3333px">We do <b>NOT need </b>to introduce <b>temp </b>here, since x * x will be evaluated before handed off to accum, so it will be outside the atomic event.</span></div></div><div>///////////////////////////////////////////////////////////////////////////////////////////////////</div><div><span style="background-color:transparent"><b>Tasks: </b></span><span style="background-color:transparent">An even higher level of abstraction avoids the concept of threads altogether and talks in terms of tasks instead. Consider the following example:</span></div><div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div><span style="color:#569cd6">    </span><span style="color:#c586c0">#include</span><span style="color:#569cd6"> </span><span style="color:#ce9178">&lt;future&gt;</span></div><br /><div>    <span style="color:#569cd6">int</span> <span style="color:#dcdcaa">square</span>(<span style="color:#569cd6">int</span> <span style="color:#9cdcfe">x</span>) {</div><div>        <span style="color:#c586c0">return</span> x * x;</div><div>    }</div><br /><div>    <span style="color:#569cd6">int</span> <span style="color:#dcdcaa">main</span>() {</div><div>        <span style="color:#569cd6">auto</span> a = <span style="color:#dcdcaa">async</span>(&amp;square, <span style="color:#b5cea8">10</span>);</div><div>        <span style="color:#569cd6">int</span> v = <span style="color:#9cdcfe">a</span>.<span style="color:#dcdcaa">get</span>();</div><div>        cout &lt;&lt; <span style="color:#ce9178">"The thread returned "</span> &lt;&lt; v &lt;&lt; endl;</div><div>    }</div></div></div><div><span style="font-size:13.3333px">The <b>async </b>construct uses an object <b>pair </b>called a <b>promise </b>and a <b>future. </b>The former has made a promise to eventually provide value. The future is linked to the promise and can at any time try to retrieve the value by <b>get().</b> If the promise hasn't been fulfilled yet, it will simply wait until the value is ready. </span></div><div><span style="font-size:13.3333px">The async <b>hides </b>most of this for us, except that it returns in this case a future&lt;int&gt; object. Again, since the <b>compiler knows</b> what this call to async returns, we can use <b>auto </b>to declare the future.</span></div></div><div>///////////////////////////////////////////////////////////////////////////////////////////////////</div><div><span style="font-size:13.3333px"><b>mu.try_lock() and mu.unlock():</b></span></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div>    <span style="color:#9cdcfe">mu</span>.<span style="color:#dcdcaa">lock</span>():     (Blocking):     You will get blocked <span style="color:#c586c0">if</span> you could NOT lock the mutex.</div><div>    <span style="color:#9cdcfe">mu</span>.<span style="color:#dcdcaa">try_lock</span>(): (Non-Blocking): You will NOT get blocked <span style="color:#c586c0">if</span> you could NOT lock the mutex.</div></div></div><div><span style="background-color:transparent"><b>Note:</b> If you do the <b>double lock using try_lock()</b> then the behavior is <b>undefined. </b></span><span style="background-color:transparent;font-size:10pt">For this case use </span><b style="background-color:transparent;font-size:10pt">recursive_mutex.</b></div><div><span style="font-size:13.3333px"><br /></span></div><div><span style="font-size:13.3333px">There are so many <b>try_lock functions</b></span></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div>    <span style="color:#b5cea8">1.</span> <span style="color:#4ec9b0">std</span>::try_lock</div><div>    <span style="color:#b5cea8">2.</span> <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">mutex</span>::try_lock</div><br /><div>    <span style="color:#b5cea8">3.</span> <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">shared_lock</span>::try_lock</div><div>    <span style="color:#b5cea8">4.</span> <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">unique_lock</span>::try_lock</div><br /><div>    <span style="color:#b5cea8">5.</span> <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">timed_mutex</span>::try_lock</div><br /><div>    <span style="color:#b5cea8">6.</span> <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">shared_mutex</span>::try_lock</div><div>    <span style="color:#b5cea8">7.</span> <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">recursive_mutex</span>::try_lock</div><br /><div>    <span style="color:#b5cea8">8.</span> <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">shared_timed_mutex</span>::try_lock</div><div>    <span style="color:#b5cea8">9.</span> <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">recursive_timed_mutex</span>::try_lock</div></div></div><div><span style="font-size:13.3333px">///////////////////////////////////////////////////////////////////////////////////////////////////</span></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div>    <span style="color:#569cd6">int</span> n = <span style="color:#b5cea8">0</span>;</div><div>    <span style="color:#4ec9b0">std</span>::mutex <span style="color:#9cdcfe">mu</span>;</div><div>    <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">counter</span>() {</div><div>        <span style="color:#c586c0">for</span> (<span style="color:#569cd6">int</span> <span style="color:#9cdcfe">i</span> = <span style="color:#b5cea8">0</span>; <span style="color:#9cdcfe">i</span> &lt; <span style="color:#b5cea8">1000</span>; ++<span style="color:#9cdcfe">i</span>) {</div><div>            <span style="color:#c586c0">if</span> (<span style="color:#9cdcfe">mu</span>.<span style="color:#dcdcaa">try_lock</span>())<span style="color:#6a9955"> // Non- blocking</span></div><div>            {</div><div>                ++<span style="color:#9cdcfe">n</span>;</div><div>                <span style="color:#9cdcfe">mu</span>.<span style="color:#dcdcaa">unlock</span>();</div><div>            }</div><br /><div><span style="color:#6a9955">            /*//////////////////////////////////////////////</span></div><div><span style="color:#6a9955">                mu.lock(); // Blocking</span></div><div><span style="color:#6a9955">                ++n;</span></div><div><span style="color:#6a9955">                mu.unlock();</span></div><div><span style="color:#6a9955">            /////////////////////////////////////////////*/</span></div><div>        }</div><div>    }</div><br /><div>    <span style="color:#569cd6">int</span> <span style="color:#dcdcaa">main</span>() {</div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">thread</span> <span style="color:#9cdcfe">t1</span>{ counter };</div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">thread</span> <span style="color:#9cdcfe">t2</span>{ counter };</div><br /><div>        <span style="color:#9cdcfe">t1</span>.<span style="color:#dcdcaa">join</span>();</div><div>        <span style="color:#9cdcfe">t2</span>.<span style="color:#dcdcaa">join</span>();</div><br /><div>        cout &lt;&lt; <span style="color:#9cdcfe">n</span>;<span style="color:#6a9955"> // with try_lock(): 2000 or 1734 (some less value)</span></div><div><span style="color:#6a9955">                   // with     lock(): 2000 (always)</span></div><div>    }</div></div></div><div><span style="font-size:13.3333px">///////////////////////////////////////////////////////////////////////////////////////////////////</span></div><div><span style="font-size:13.3333px"><b>try_lock:</b>       <b>Immediately </b>return false if it could NOT lock.</span></div><div><span style="font-size:13.3333px"><b>try_lock_for:</b> <b>Wait </b>for the given <b>timeout </b>before returning the result of the lock attempt.</span></div><div><span style="font-size:13.3333px">///////////////////////////////////////////////////////////////////////////////////////////////////</span></div><div><span style="font-size:13.3333px"><b>timed_mutex:</b> <b>try_lock_for(timeout) </b> and <b>try_lock_until(timeout)</b></span></div><div><span style="font-size:13.3333px">1. timed_mutex is blocked till timeout or the lock is acquired and return true if success otherwise false.</span></div><div><span style="font-size:13.3333px">2. try_lock_for(timeout):</span></div><div><span style="font-size:13.3333px"><span style="white-space:pre"> </span>Waits until the specified timeout has elapsed or the lock is acquired, whichever comes first.</span></div><div><span style="font-size:13.3333px"><span style="white-space:pre"> </span>On successful lock acquisition return true, otherwise returns false.</span></div><div><span style="font-size:13.3333px">3. try_lock_until(<b>now </b>+ timeout): Same as above but here it takes some<b> reference</b> clock time.</span></div><div><span style="font-size:13.3333px">///////////////////////////////////////////////////////////////////////////////////////////////////</span></div><div><span style="font-size:13.3333px"><b>try_lock_for(timeout)</b></span></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div>    <span style="color:#569cd6">int</span> totalMoney = <span style="color:#b5cea8">0</span>;</div><div>    <span style="color:#4ec9b0">std</span>::timed_mutex <span style="color:#9cdcfe">mu</span>;<span style="color:#6a9955"> // NOT mutex mu</span></div><br /><div>    <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">addMoney</span>(<span style="color:#569cd6">int</span> <span style="color:#9cdcfe">i</span>) {</div><div>        <span style="color:#c586c0">if</span> (<span style="color:#9cdcfe">mu</span>.<span style="color:#dcdcaa">try_lock_for</span>(<span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">chrono</span>::<span style="color:#4ec9b0">seconds</span>(<span style="color:#b5cea8">1</span>)))<span style="color:#6a9955"> // change from 1=&gt;5 and then check again</span></div><div>        {</div><div>            cout &lt;&lt; <span style="color:#ce9178">"Thread "</span> &lt;&lt; <span style="color:#9cdcfe">i</span> &lt;&lt; <span style="color:#ce9178">" Entered"</span> &lt;&lt; endl;</div><div>            ++totalMoney;<span style="color:#6a9955"> // critical section</span></div><div>            <span style="color:#4ec9b0">this_thread</span>::<span style="color:#dcdcaa">sleep_for</span>(<span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">chrono</span>::<span style="color:#4ec9b0">seconds</span>(<span style="color:#b5cea8">3</span>));</div><div>            <span style="color:#9cdcfe">mu</span>.<span style="color:#dcdcaa">lock</span>();</div><div>        }</div><div>        <span style="color:#c586c0">else</span> {</div><div>            cout &lt;&lt; <span style="color:#ce9178">"Thread "</span> &lt;&lt; <span style="color:#9cdcfe">i</span> &lt;&lt; <span style="color:#ce9178">" could NOT enter"</span> &lt;&lt; endl;</div><div>        }</div><div>    }</div><div>    <span style="color:#569cd6">int</span> <span style="color:#dcdcaa">main</span>() {</div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">thread</span> <span style="color:#9cdcfe">t1</span>{ addMoney, <span style="color:#b5cea8">1</span> };</div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">thread</span> <span style="color:#9cdcfe">t2</span>{ addMoney, <span style="color:#b5cea8">2</span> }; </div><div>        <span style="color:#9cdcfe">t1</span>.<span style="color:#dcdcaa">join</span>();</div><div>        <span style="color:#9cdcfe">t2</span>.<span style="color:#dcdcaa">join</span>();</div><div>        cout &lt;&lt; totalMoney;</div><div>    }</div></div></div><div><span style="font-size:13.3333px">///////////////////////////////////////////////////////////////////////////////////////////////////</span></div><div><span style="font-size:13.3333px"><b>try_lock_until(now+timeout)</b></span></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div>    <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">addMoney</span>(<span style="color:#569cd6">int</span> <span style="color:#9cdcfe">i</span>) {</div><div>        <span style="color:#569cd6">auto</span> <span style="color:#9cdcfe">now</span> = <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">chrono</span>::<span style="color:#4ec9b0">steady_clock</span>::<span style="color:#dcdcaa">now</span>();</div><div>        <span style="color:#c586c0">if</span> (<span style="color:#9cdcfe">mu</span>.<span style="color:#dcdcaa">try_lock_until</span>(<span style="color:#9cdcfe">now</span> <span style="color:#dcdcaa">+</span> <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">chrono</span>::<span style="color:#4ec9b0">seconds</span>(<span style="color:#b5cea8">1</span>)))<span style="color:#6a9955"> // change from 1=&gt;5 and then check again</span></div><div>        {</div><div>            cout &lt;&lt; <span style="color:#ce9178">"Thread "</span> &lt;&lt; <span style="color:#9cdcfe">i</span> &lt;&lt; <span style="color:#ce9178">" Entered"</span> &lt;&lt; endl;</div><div>            ++totalMoney;<span style="color:#6a9955"> // critical section</span></div><div>            <span style="color:#4ec9b0">this_thread</span>::<span style="color:#dcdcaa">sleep_for</span>(<span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">chrono</span>::<span style="color:#4ec9b0">seconds</span>(<span style="color:#b5cea8">3</span>));</div><div>            <span style="color:#9cdcfe">mu</span>.<span style="color:#dcdcaa">lock</span>();</div><div>        }</div><div>        <span style="color:#c586c0">else</span> {</div><div>            cout &lt;&lt; <span style="color:#ce9178">"Thread "</span> &lt;&lt; <span style="color:#9cdcfe">i</span> &lt;&lt; <span style="color:#ce9178">" could NOT enter"</span> &lt;&lt; endl;</div><div>        }</div><div>    }</div></div></div><div><span style="font-size:13.3333px">///////////////////////////////////////////////////////////////////////////////////////////////////</span></div><div><span style="font-size:13.3333px"><b>std::try_lock()</b>:(NOT mu.try_lock())</span></div><div><span style="font-size:13.3333px"><span style="white-space:pre"> </span>1. Tries to lock <b>LIST</b> of all the lockable objects(mutexes - mu1, mu2,...) passed in it one by one in the given order.</span></div><div><span style="font-size:13.3333px"><span style="white-space:pre"> </span>std::try_lock(mu1,mu2,mu3,mu4.....);</span></div><div><span style="font-size:13.3333px"><span style="white-space:pre"> </span>2. On success this function returns <b>'-1' </b>otherwise returns <b>0-based</b> mutex index which it could <b>NOT lock.</b></span></div><div><span style="font-size:13.3333px"><span style="white-space:pre"> </span>    <b>  -1 = success</b></span></div><div><span style="font-size:13.3333px"><span style="white-space:pre"> </span><b>2 = zero-based index = mu3 is could NOT lock = mu3 is failed.</b></span></div><div><span style="font-size:13.3333px"><span style="white-space:pre"> </span>3. If it <b>fails </b>to <b>lock </b>any of the mutex then it will <b>release ALL</b> the mutex it locked before.</span></div><div><span style="font-size:13.3333px"><span style="white-space:pre"> </span>4. If a call to<b> try_lock</b> results in an <b>EXPECPTION</b>, unlock is called for any locked objects <b>before </b>throwing.</span></div><div><span style="font-size:13.3333px">///////////////////////////////////////////////////////////////////////////////////////////////////</span></div><div><span style="font-size:13.3333px"><b>WRONG EXAMPLE - FIND BEST ONE SOMEWHERE</b></span></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div>    <span style="color:#569cd6">int</span> x = <span style="color:#b5cea8">0</span>;</div><div>    <span style="color:#569cd6">int</span> y = <span style="color:#b5cea8">0</span>;</div><div>    <span style="color:#4ec9b0">std</span>::mutex mu1, mu2;</div><br /><div>    <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">counter</span>(<span style="color:#569cd6">int&amp;</span> <span style="color:#9cdcfe">xy</span>, <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">mutex</span><span style="color:#569cd6">&amp;</span> <span style="color:#9cdcfe">mu</span>, <span style="color:#569cd6">const</span> <span style="color:#569cd6">char*</span> <span style="color:#9cdcfe">desc</span>) {</div><div>        <span style="color:#c586c0">for</span> (<span style="color:#569cd6">int</span> <span style="color:#9cdcfe">i</span> = <span style="color:#b5cea8">0</span>; <span style="color:#9cdcfe">i</span> &lt; <span style="color:#b5cea8">5</span>; ++<span style="color:#9cdcfe">i</span>) {</div><div>            <span style="color:#9cdcfe">mu</span>.<span style="color:#dcdcaa">lock</span>();<span style="color:#6a9955"> // Blocking</span></div><div>            ++xy;</div><div>            cout &lt;&lt; desc &lt;&lt; xy &lt;&lt; endl;</div><div>            <span style="color:#9cdcfe">mu</span>.<span style="color:#dcdcaa">unlock</span>();</div><br /><div>            <span style="color:#4ec9b0">this_thread</span>::<span style="color:#dcdcaa">sleep_for</span>(<span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">chrono</span>::<span style="color:#4ec9b0">seconds</span>(<span style="color:#b5cea8">2</span>));<span style="color:#6a9955"> // MUST context switch to </span></div><div>        }</div><div>    }</div><br /><div>    <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">adder</span>() {</div><div>        <span style="color:#569cd6">int</span> <span style="color:#9cdcfe">range</span> = <span style="color:#b5cea8">5</span>;</div><div>        <span style="color:#569cd6">int</span> <span style="color:#9cdcfe">sum</span> = <span style="color:#b5cea8">0</span>;</div><div>        <span style="color:#c586c0">while</span> (<span style="color:#b5cea8">1</span>) {</div><div>            <span style="color:#569cd6">int</span> <span style="color:#9cdcfe">res</span> = <span style="color:#4ec9b0">std</span>::<span style="color:#dcdcaa">try_lock</span>(<span style="color:#9cdcfe">mu1</span>, <span style="color:#9cdcfe">mu2</span>);</div><div>            <span style="color:#c586c0">if</span> (<span style="color:#9cdcfe">res</span> == -<span style="color:#b5cea8">1</span>) {</div><div><span style="color:#6a9955">                //if (x != 0 &amp;&amp; y != 0) </span></div><div>                {</div><div>                    --<span style="color:#9cdcfe">range</span>;</div><div>                    <span style="color:#9cdcfe">sum</span> = x + <span style="color:#9cdcfe">y</span>;</div><div><span style="color:#6a9955">                    /*x = 0;</span></div><div><span style="color:#6a9955">                    y = 0;*/</span></div><div>                    cout &lt;&lt; <span style="color:#ce9178">"x + y: "</span>&lt;&lt; <span style="color:#9cdcfe">sum</span> &lt;&lt;endl;</div><div>                }</div><div>                <span style="color:#9cdcfe">mu1</span>.<span style="color:#dcdcaa">unlock</span>();</div><div>                <span style="color:#9cdcfe">mu2</span>.<span style="color:#dcdcaa">unlock</span>();</div><div>                <span style="color:#c586c0">if</span> (<span style="color:#9cdcfe">range</span> == <span style="color:#b5cea8">0</span>) <span style="color:#c586c0">break</span>;</div><div>            }</div><div>        }</div><div>    }</div><br /><div>    <span style="color:#569cd6">int</span> <span style="color:#dcdcaa">main</span>() {</div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">thread</span> <span style="color:#9cdcfe">t1</span>{ counter, <span style="color:#4ec9b0">std</span>::<span style="color:#dcdcaa">ref</span>(x), <span style="color:#4ec9b0">std</span>::<span style="color:#dcdcaa">ref</span>(<span style="color:#9cdcfe">mu1</span>), <span style="color:#ce9178">"x: "</span> };</div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">thread</span> <span style="color:#9cdcfe">t2</span>{ counter, <span style="color:#4ec9b0">std</span>::<span style="color:#dcdcaa">ref</span>(<span style="color:#9cdcfe">y</span>), <span style="color:#4ec9b0">std</span>::<span style="color:#dcdcaa">ref</span>(<span style="color:#9cdcfe">mu2</span>), <span style="color:#ce9178">"y: "</span> };</div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">thread</span> <span style="color:#9cdcfe">t3</span>{ <span style="color:#dcdcaa">adder</span> };</div><br /><div>        <span style="color:#9cdcfe">t1</span>.<span style="color:#dcdcaa">join</span>();</div><div>        <span style="color:#9cdcfe">t2</span>.<span style="color:#dcdcaa">join</span>();</div><div>        <span style="color:#9cdcfe">t3</span>.<span style="color:#dcdcaa">join</span>();</div><div>    }</div></div></div><div>///////////////////////////////////////////////////////////////////////////////////////////////////</div><div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div>    <span style="color:#4ec9b0">std</span>::<span style="color:#dcdcaa">lock</span>(mu1,mu2,mu3...)       = Locks MULTIPLE mutexes at the SAME time.</div><div>    <span style="color:#4ec9b0">std</span>::<span style="color:#dcdcaa">try_lock</span>(mu1,mu2,mu3...)   = ----- <span style="color:#c586c0">do</span> -----</div></div></div><div><span style="background-color:transparent;font-size:10pt">    </span><span style="background-color:transparent;font-size:10pt">1. Order of locking the mutexes is NOT defined but it ensures that there is NO deadlock.</span></div><div><span>    </span>2. It is a BLOCKING call.</div><div>///////////////////////////////////////////////////////////////////////////////////////////////////</div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div>Ex <span style="color:rgb(181,206,168)">1</span>: NO deadlock:</div><div>    Thread <span style="color:rgb(181,206,168)">1</span>                              Thread <span style="color:rgb(181,206,168)">2</span></div><div>    <span style="color:rgb(78,201,176)">std</span>::<span style="color:rgb(220,220,170)">lock</span>(mu1, mu2);                  <span style="color:rgb(156,220,254)">std</span><span style="color:rgb(156,220,254)">:</span>:<span style="color:rgb(220,220,170)">lock</span>(mu2, mu1); </div><br /><div><span style="color:rgb(156,220,254)">Time</span> <span style="color:rgb(181,206,168)">1</span>: mu1 - locked                       mu2 - locked</div><div>Time <span style="color:rgb(181,206,168)">2</span>: mu1 - unlocked bcos mu2 already    mu1 - locked. </div><div>        locked by someone                  Finish computation and unlock both mu2 and mu1</div><div>Time <span style="color:rgb(181,206,168)">3</span>: mu2 - <span style="color:rgb(220,220,170)">lock</span>(bcos last time failed)</div><div>Time <span style="color:rgb(181,206,168)">4</span>: mu1 - lock</div></div></div><div>///////////////////////////////////////////////////////////////////////////////////////////////////</div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div>Ex <span style="color:rgb(181,206,168)">2</span>: NO deadlock:</div><div>    Thread <span style="color:rgb(181,206,168)">1</span>                              Thread <span style="color:rgb(181,206,168)">2</span></div><div>    <span style="color:rgb(78,201,176)">std</span>::<span style="color:rgb(220,220,170)">lock</span>(mu1, mu2);                  <span style="color:rgb(156,220,254)">std</span><span style="color:rgb(156,220,254)">:</span>:<span style="color:rgb(220,220,170)">lock</span>(mu1, mu2);</div><br /><div><span style="color:rgb(156,220,254)">Time</span> <span style="color:rgb(181,206,168)">1</span>: mu1 - locked                      Lock NOTHTING bcos mu1 - is already locked by someone</div><div>Time <span style="color:rgb(181,206,168)">2</span>: mu2 - locked                      Lock NOTHTING</div><div>        Finish computation and </div><div>        unlock both mu1 and mu2</div><div>Time <span style="color:rgb(181,206,168)">3</span>:                                   mu1 - <span style="color:rgb(220,220,170)">lock</span>(bcos last time failed)</div><div>Time <span style="color:rgb(181,206,168)">4</span>:                                   mu2 - lock</div></div></div><div>///////////////////////////////////////////////////////////////////////////////////////////////////</div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div>Ex <span style="color:rgb(181,206,168)">3</span>: NO deadlock:</div><div>    Thread <span style="color:rgb(181,206,168)">1</span>                              Thread <span style="color:rgb(181,206,168)">2</span></div><div>    <span style="color:rgb(78,201,176)">std</span>::<span style="color:rgb(220,220,170)">lock</span>(mu1, mu2, mu3, mu4);        <span style="color:rgb(156,220,254)">std</span><span style="color:rgb(156,220,254)">:</span>:<span style="color:rgb(220,220,170)">lock</span>(mu3, mu4);</div><div>                                          <span style="color:rgb(156,220,254)">std</span><span style="color:rgb(156,220,254)">:</span>:<span style="color:rgb(220,220,170)">lock</span>(mu1, mu2);</div><br /><div><span style="color:rgb(156,220,254)">Time</span> <span style="color:rgb(181,206,168)">1</span>&amp;<span style="color:rgb(181,206,168)">2</span>: mu1 &amp; mu2 locked                mu3 &amp; mu4 locked</div><div>Time <span style="color:rgb(181,206,168)">3</span>&amp;<span style="color:rgb(181,206,168)">4</span>: mu1 &amp; mu2 unlocked bcos         mu1 &amp; mu2 locked</div><div>       mu3 is already locked by <span style="color:rgb(156,220,254)">someone</span>.  <span style="color:rgb(156,220,254)">Finish</span> computation and unlock both mu3,mu4,mu1 and mu2</div><div>Time <span style="color:rgb(181,206,168)">5</span>&amp;<span style="color:rgb(181,206,168)">6</span>: mu3 - <span style="color:rgb(220,220,170)">lock</span>(bcos last time failed)</div><div>          mu1, mu2 and mu4 are locked</div></div></div><div>///////////////////////////////////////////////////////////////////////////////////////////////////</div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div>Ex <span style="color:rgb(181,206,168)">4</span>: DEADLOCK: Wrong order SEPARATED locks</div><div>    Thread <span style="color:rgb(181,206,168)">1</span>                              Thread <span style="color:rgb(181,206,168)">2</span></div><div>    <span style="color:rgb(78,201,176)">std</span>::<span style="color:rgb(220,220,170)">lock</span>(mu1, mu2);                  <span style="color:rgb(156,220,254)">std</span><span style="color:rgb(156,220,254)">:</span>:<span style="color:rgb(220,220,170)">lock</span>(mu3, mu4);</div><div>    <span style="color:rgb(156,220,254)">std</span><span style="color:rgb(156,220,254)">:</span>:<span style="color:rgb(220,220,170)">lock</span>(mu3, mu4);                  <span style="color:rgb(156,220,254)">std</span><span style="color:rgb(156,220,254)">:</span>:<span style="color:rgb(220,220,170)">lock</span>(mu1, mu2);</div><br /><div><span style="color:rgb(156,220,254)">Time</span> <span style="color:rgb(181,206,168)">1</span>&amp;<span style="color:rgb(181,206,168)">2</span>: mu1 &amp; mu2 locked                mu3 &amp; mu4 locked</div><div>Time <span style="color:rgb(181,206,168)">3</span>&amp;<span style="color:rgb(181,206,168)">4</span>: WAIT <span style="color:rgb(197,134,192)">for</span> mu2                    WAIT <span style="color:rgb(197,134,192)">for</span> mu1</div></div></div><div>///////////////////////////////////////////////////////////////////////////////////////////////////</div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div><span style="color:rgb(78,201,176)">std</span>::mutex mu1, mu2;</div><br /><div><span style="color:rgb(86,156,214)">void</span> <span style="color:rgb(220,220,170)">task_A</span>() {</div><div>    <span style="color:rgb(197,134,192)">while</span> (<span style="color:rgb(181,206,168)">1</span>) {<span style="color:rgb(106,153,85)">  // Note: Though loops forever, mu1 &amp; mu2 shared across 'task_A &amp; task_B' WITHOUT deadlock !</span></div><div>        <span style="color:rgb(78,201,176)">std</span>::<span style="color:rgb(220,220,170)">lock</span>(<span style="color:rgb(156,220,254)">mu1</span>, <span style="color:rgb(156,220,254)">mu2</span>);<span style="color:rgb(106,153,85)">       // Method 1: deadlock free</span></div><div><span style="color:rgb(106,153,85)">        // mu1.lock(); mu2.lock(); // Method 2: DEADLOCK</span></div><div>        cout &lt;&lt; <span style="color:rgb(206,145,120)">"task_A"</span> &lt;&lt; endl;</div><div>        <span style="color:rgb(156,220,254)">mu1</span>.<span style="color:rgb(220,220,170)">unlock</span>();<span style="color:rgb(106,153,85)">              // MUST unlock</span></div><div>        <span style="color:rgb(156,220,254)">mu2</span>.<span style="color:rgb(220,220,170)">unlock</span>();</div><div>    }</div><div>}</div><br /><div><span style="color:rgb(86,156,214)">void</span> <span style="color:rgb(220,220,170)">task_B</span>() {</div><div>    <span style="color:rgb(197,134,192)">while</span> (<span style="color:rgb(181,206,168)">1</span>) {</div><div>        <span style="color:rgb(78,201,176)">std</span>::<span style="color:rgb(220,220,170)">lock</span>(<span style="color:rgb(156,220,254)">mu1</span>, <span style="color:rgb(156,220,254)">mu2</span>);<span style="color:rgb(106,153,85)">       // Method 1: deadlock free (Note: lock the mutexes in the SAME order like previous)</span></div><div><span style="color:rgb(106,153,85)">        // mu2.lock(); mu1.lock(); // Method 2: DEADLOCK</span></div><div>        cout &lt;&lt; <span style="color:rgb(206,145,120)">"task_B"</span> &lt;&lt; endl;</div><div>        <span style="color:rgb(156,220,254)">mu1</span>.<span style="color:rgb(220,220,170)">unlock</span>();</div><div>        <span style="color:rgb(156,220,254)">mu2</span>.<span style="color:rgb(220,220,170)">unlock</span>();</div><div>    }</div><div>}</div><br /><div><span style="color:rgb(86,156,214)">int</span> <span style="color:rgb(220,220,170)">main</span>() {</div><div>    thread t1{ task_A };</div><div>    thread t2{ task_B };</div><div>    <span style="color:rgb(156,220,254)">t1</span>.<span style="color:rgb(220,220,170)">join</span>();</div><div>    <span style="color:rgb(156,220,254)">t2</span>.<span style="color:rgb(220,220,170)">join</span>();</div><div>}</div></div></div><div>///////////////////////////////////////////////////////////////////////////////////////////////////</div><div><b>mutex:</b> order of lock is very important across the threads.</div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div><span style="color:rgb(78,201,176)">NO</span> <span style="color:rgb(220,220,170)">deadlock</span> (<span style="color:rgb(78,201,176)">Good</span>): Across threads you should follow the same order of mutexes lock/unlock</div><div>    <span style="color:rgb(197,134,192)">case</span> <span style="color:rgb(181,206,168)">1</span>: Thread <span style="color:rgb(181,206,168)">1</span>: <span style="color:rgb(156,220,254)">mu1</span>.<span style="color:rgb(220,220,170)">lock</span>(); <span style="color:rgb(156,220,254)">mu2</span>.<span style="color:rgb(220,220,170)">lock</span>();  =&gt; CS &lt;= <span style="color:rgb(156,220,254)">mu1</span>.<span style="color:rgb(220,220,170)">unlock</span>(); <span style="color:rgb(156,220,254)">mu2</span>.<span style="color:rgb(220,220,170)">unlock</span>();</div><div>            Thread <span style="color:rgb(181,206,168)">2</span>: <span style="color:rgb(156,220,254)">mu1</span>.<span style="color:rgb(220,220,170)">lock</span>(); <span style="color:rgb(156,220,254)">mu2</span>.<span style="color:rgb(220,220,170)">lock</span>();  =&gt; CS &lt;= <span style="color:rgb(156,220,254)">mu1</span>.<span style="color:rgb(220,220,170)">unlock</span>(); <span style="color:rgb(156,220,254)">mu2</span>.<span style="color:rgb(220,220,170)">unlock</span>();</div><br /><div>Deadlock - <span style="color:rgb(220,220,170)">Possible</span>(Bad):</div><div>    <span style="color:rgb(197,134,192)">case</span> <span style="color:rgb(181,206,168)">2</span>: Thread <span style="color:rgb(181,206,168)">1</span>: <span style="color:rgb(156,220,254)">mu1</span>.<span style="color:rgb(220,220,170)">lock</span>(); <span style="color:rgb(156,220,254)">mu2</span>.<span style="color:rgb(220,220,170)">lock</span>();  =&gt; CS &lt;= <span style="color:rgb(156,220,254)">mu1</span>.<span style="color:rgb(220,220,170)">unlock</span>(); <span style="color:rgb(156,220,254)">mu2</span>.<span style="color:rgb(220,220,170)">unlock</span>();</div><div>            Thread <span style="color:rgb(181,206,168)">2</span>: <span style="color:rgb(156,220,254)">mu2</span>.<span style="color:rgb(220,220,170)">lock</span>(); <span style="color:rgb(156,220,254)">mu1</span>.<span style="color:rgb(220,220,170)">lock</span>();  =&gt; CS &lt;= <span style="color:rgb(156,220,254)">mu2</span>.<span style="color:rgb(220,220,170)">unlock</span>(); <span style="color:rgb(156,220,254)">mu1</span>.<span style="color:rgb(220,220,170)">unlock</span>();</div></div></div><div>///////////////////////////////////////////////////////////////////////////////////////////////////</div><div><b>Deadlock example:</b></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div>    <span style="color:rgb(78,201,176)">std</span>::mutex mu1, mu2;</div><div>    <span style="color:rgb(86,156,214)">void</span> <span style="color:rgb(220,220,170)">runOne</span>() {</div><div>        <span style="color:rgb(156,220,254)">mu1</span>.<span style="color:rgb(220,220,170)">lock</span>(); </div><div>        <span style="color:rgb(78,201,176)">std</span>::<span style="color:rgb(78,201,176)">this_thread</span>::<span style="color:rgb(220,220,170)">sleep_for</span>(<span style="color:rgb(78,201,176)">std</span>::<span style="color:rgb(78,201,176)">chrono</span>::<span style="color:rgb(78,201,176)">seconds</span>(<span style="color:rgb(181,206,168)">1</span>));</div><div>        <span style="color:rgb(156,220,254)">mu2</span>.<span style="color:rgb(220,220,170)">lock</span>();</div><div>        cout &lt;&lt; <span style="color:rgb(206,145,120)">"CS: runOne"</span> &lt;&lt; endl;</div><div>        <span style="color:rgb(156,220,254)">mu1</span>.<span style="color:rgb(220,220,170)">unlock</span>(); <span style="color:rgb(156,220,254)">mu2</span>.<span style="color:rgb(220,220,170)">unlock</span>();</div><div>    }</div><br /><div>    <span style="color:rgb(86,156,214)">void</span> <span style="color:rgb(220,220,170)">runTwo</span>() {</div><div>        <span style="color:rgb(156,220,254)">mu2</span>.<span style="color:rgb(220,220,170)">lock</span>();<span style="color:rgb(106,153,85)"> // DeadLock - bcos of different order</span></div><div>        <span style="color:rgb(78,201,176)">std</span>::<span style="color:rgb(78,201,176)">this_thread</span>::<span style="color:rgb(220,220,170)">sleep_for</span>(<span style="color:rgb(78,201,176)">std</span>::<span style="color:rgb(78,201,176)">chrono</span>::<span style="color:rgb(78,201,176)">seconds</span>(<span style="color:rgb(181,206,168)">1</span>));</div><div>        <span style="color:rgb(156,220,254)">mu1</span>.<span style="color:rgb(220,220,170)">lock</span>();</div><div><span style="color:rgb(106,153,85)">        // mu1.lock(); mu2.lock(); // NO DeadLock - correct order</span></div><div>        cout &lt;&lt; <span style="color:rgb(206,145,120)">"CS: runTwo"</span> &lt;&lt; endl;</div><div><span style="color:rgb(106,153,85)">        //mu1.unlock(); mu2.unlock(); // NO DeadLock - correct order</span></div><div>        <span style="color:rgb(156,220,254)">mu2</span>.<span style="color:rgb(220,220,170)">unlock</span>(); <span style="color:rgb(156,220,254)">mu1</span>.<span style="color:rgb(220,220,170)">unlock</span>();<span style="color:rgb(106,153,85)"> // DeadLock - bcos of different order</span></div><div>    }</div><br /><div>    <span style="color:rgb(86,156,214)">int</span> <span style="color:rgb(220,220,170)">main</span>() {</div><div>        thread t1{ runOne };</div><div>        thread t2{ runTwo };</div><div>        <span style="color:rgb(156,220,254)">t1</span>.<span style="color:rgb(220,220,170)">join</span>();</div><div>        <span style="color:rgb(156,220,254)">t2</span>.<span style="color:rgb(220,220,170)">join</span>();</div><div>    }</div></div></div><div>///////////////////////////////////////////////////////////////////////////////////////////////////</div></div><div><span style="font-size:13.3333px"><b>std::recursive_mutex: </b></span></div><div><span style="font-size:13.3333px">1. <b>Same thread</b> can <b>lock </b>one <b>mutex</b>(std::recursive_mutex) <b>multiple times </b>using <b>recursion/loop.</b></span></div><div><span style="font-size:13.3333px">2. If thread 't1' is successfully lock/try_lock on recursive_mutex mu, then mu <b>can be</b> locked by the SAME thread 't1' any number of times.</span></div><div><span style="font-size:13.3333px">3. If 't1' is locked the mu by 10 times then it must unlock mu by the SAME 10 times. <b>NO other threads allowed in between.</b></span></div><div><span style="font-size:13.3333px">4. You can lock any number of times until stack overflow. If you reach the max count then if you used</span></div><div><span style="font-size:13.3333px"><span style="white-space:pre"> </span><b>lock()   </b>    =&gt; will return std::system_error <b>exception </b>(You much catch it) or</span></div><div><span style="font-size:13.3333px"><span style="white-space:pre"> </span><b>try_lock()</b> =&gt; will return <b>false</b></span></div><div><span style="font-size:13.3333px">5. It is a bit heavy mutex so<b> better to avoid it.</b></span></div><div><span style="font-size:13.3333px">///////////////////////////////////////////////////////////////////////////////////////////////////</span></div><div><span style="font-size:13.3333px"><b>Recurrsion:</b></span></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div>    <span style="color:#4ec9b0">std</span>::recursive_mutex mu;</div><div>    <span style="color:#569cd6">int</span> <span style="color:#9cdcfe">gCounter</span> = <span style="color:#b5cea8">0</span>;</div><div>    <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">recurr</span>(<span style="color:#569cd6">char</span> <span style="color:#9cdcfe">tid</span>, <span style="color:#569cd6">int</span> <span style="color:#9cdcfe">loopFor</span>) {</div><div>        <span style="color:#c586c0">if</span> (!<span style="color:#9cdcfe">loopFor</span>) <span style="color:#c586c0">return</span>;</div><br /><div>        <span style="color:#9cdcfe">mu</span>.<span style="color:#dcdcaa">lock</span>();</div><div>        cout &lt;&lt; <span style="color:#ce9178">"Locked by ThreadId:"</span> &lt;&lt; <span style="color:#9cdcfe">tid</span> &lt;&lt;<span style="color:#ce9178">" - "</span>&lt;&lt; <span style="color:#9cdcfe">gCounter</span>++ &lt;&lt; endl;</div><div>        <span style="color:#dcdcaa">recurr</span>(<span style="color:#9cdcfe">tid</span>, --<span style="color:#9cdcfe">loopFor</span>);<span style="color:#6a9955"> // recurrsive lock will happen</span></div><br /><div>        <span style="color:#9cdcfe">mu</span>.<span style="color:#dcdcaa">unlock</span>();<span style="color:#6a9955"> // reverse order recurrsive unlock will happen</span></div><div>    }</div><br /><div>    <span style="color:#569cd6">int</span> <span style="color:#dcdcaa">main</span>() {</div><div>        thread t1{ recurr, <span style="color:#ce9178">'1'</span>, <span style="color:#b5cea8">5</span> };</div><div>        thread t2{ recurr, <span style="color:#ce9178">'2'</span>, <span style="color:#b5cea8">7</span> };</div><div>        <span style="color:#9cdcfe">t1</span>.<span style="color:#dcdcaa">join</span>();</div><div>        <span style="color:#9cdcfe">t2</span>.<span style="color:#dcdcaa">join</span>();</div><div>    }</div></div></div><div><span style="font-size:13.3333px">///////////////////////////////////////////////////////////////////////////////////////////////////</span></div><div><span style="font-size:13.3333px"><b>Loop:</b></span></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div>    <span style="color:#569cd6">int</span> <span style="color:#dcdcaa">main</span>() {</div><div>        <span style="color:#c586c0">for</span> (<span style="color:#569cd6">int</span> <span style="color:#9cdcfe">i</span> = <span style="color:#b5cea8">0</span>; <span style="color:#9cdcfe">i</span> &lt; <span style="color:#b5cea8">5</span>; ++<span style="color:#9cdcfe">i</span>) {</div><div>            <span style="color:#9cdcfe">mu</span>.<span style="color:#dcdcaa">lock</span>();</div><div>            cout &lt;&lt; <span style="color:#ce9178">"Locked: "</span> &lt;&lt; <span style="color:#9cdcfe">i</span> &lt;&lt; endl;</div><div>        }</div><br /><div><span style="color:#6a9955">        // Must unlock how many times you locked before</span></div><div>        <span style="color:#c586c0">for</span> (<span style="color:#569cd6">int</span> <span style="color:#9cdcfe">i</span> = <span style="color:#b5cea8">0</span>; <span style="color:#9cdcfe">i</span> &lt; <span style="color:#b5cea8">5</span>; ++<span style="color:#9cdcfe">i</span>) {</div><div>            <span style="color:#9cdcfe">mu</span>.<span style="color:#dcdcaa">unlock</span>();</div><div>            cout &lt;&lt; <span style="color:#ce9178">"Unlocked: "</span> &lt;&lt; <span style="color:#9cdcfe">i</span> &lt;&lt; endl;</div><div>        }</div><div>    }</div></div></div><div><span style="font-size:13.3333px">///////////////////////////////////////////////////////////////////////////////////////////////////</span></div><div><span style="font-size:13.3333px"><b>std::lock_guard:</b></span></div><div><span style="font-size:13.3333px"><span>    </span>1. It is a light weight wrapper for owning mutex on <b>SCOPE basis</b>(function / { }).</span></div><div><span style="font-size:13.3333px"><span>    </span>2. You should explicitly lock the mutex using lock_guard inside any scope.</span></div><div><span style="font-size:13.3333px"><span>    </span>3. But you can <b>NOT</b> explicitly <b>unlock </b>the mutex. Mutex will automatically unlock itself when you go out of the scope(calls destructor).</span></div><div><span style="font-size:13.3333px"><span>    </span>4. You can <b>NOT copy lock_guard</b> (passing to another function / </span><span style="background-color:transparent;font-size:10pt"><b>copy </b></span><span style="background-color:transparent">/ </span><b><span style="background-color:transparent;font-size:10pt">move</span><span style="background-color:transparent;font-size:10pt"> </span></b><span style="background-color:transparent;font-size:10pt"><b> </b>)</span></div><div><span style="font-size:13.3333px">///////////////////////////////////////////////////////////////////////////////////////////////////</span></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div>    <span style="color:#4ec9b0">std</span>::mutex mu;<span style="color:#6a9955"> // Normal mutex</span></div><div>    <span style="color:#569cd6">int</span> <span style="color:#9cdcfe">gCounter</span> = <span style="color:#b5cea8">0</span>;</div><br /><div>    <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">run</span>(<span style="color:#569cd6">const</span> <span style="color:#569cd6">char*</span> <span style="color:#9cdcfe">tid</span>, <span style="color:#569cd6">int</span> <span style="color:#9cdcfe">loopFor</span>) {</div><div>        <span style="color:#4ec9b0">std</span>::lock_guard&lt;<span style="color:#4ec9b0">mutex</span>&gt; <span style="color:#dcdcaa">lock</span>(<span style="color:#9cdcfe">mu</span>);<span style="color:#6a9955"> // NOT normal lock</span></div><div>        <span style="color:#c586c0">for</span> (<span style="color:#569cd6">int</span> <span style="color:#9cdcfe">i</span> = <span style="color:#b5cea8">0</span>; <span style="color:#9cdcfe">i</span> &lt; <span style="color:#9cdcfe">loopFor</span>; ++<span style="color:#9cdcfe">i</span>) {</div><div>            <span style="color:#9cdcfe">gCounter</span>++;</div><div>            cout &lt;&lt; <span style="color:#9cdcfe">tid</span> &lt;&lt; <span style="color:#ce9178">" - "</span> &lt;&lt; <span style="color:#9cdcfe">gCounter</span> &lt;&lt; endl;</div><div>        }</div><div>    }<span style="color:#6a9955"> // automatically mutex unlocked here by the destructor</span></div><br /><div>    <span style="color:#569cd6">int</span> <span style="color:#dcdcaa">main</span>() {</div><div>        thread t1{ run, <span style="color:#ce9178">"ThreadId: 1"</span>, <span style="color:#b5cea8">5</span> };</div><div>        thread t2{ run, <span style="color:#ce9178">"ThreadId: 2"</span>, <span style="color:#b5cea8">7</span> };</div><div>        <span style="color:#9cdcfe">t1</span>.<span style="color:#dcdcaa">join</span>();</div><div>        <span style="color:#9cdcfe">t2</span>.<span style="color:#dcdcaa">join</span>();</div><div>    }</div></div></div><div><span style="font-size:13.3333px">///////////////////////////////////////////////////////////////////////////////////////////////////</span></div><div><span style="font-size:13.3333px"><b>unique_lock: </b></span></div><div><span style="font-size:13.3333px"><span style="white-space:pre"> </span>1. Can support different <b>lock types</b> (lock, try_lock_for, try_lock_until).</span></div><div><span style="font-size:13.3333px"><span style="white-space:pre"> </span>2. Can support different <b>locking strategies</b> (defer_lock, try_to_lock, adopt_lock, recursive locking etc.,).</span></div><div><span style="font-size:13.3333px"><span style="white-space:pre"> </span>3. <b>Transfer </b>of lock ownership(<b>move allowed </b>but <b>copy NOT allowed.</b> i.e., No two objects can own the ownership).</span></div><div><span style="font-size:13.3333px"><span style="white-space:pre"> </span>4. Can be used for <b>condition variables.</b></span></div><div><span style="font-size:13.3333px">///////////////////////////////////////////////////////////////////////////////////////////////////</span></div><div><span style="font-size:13.3333px"><b>unique_lock:</b> simillar to lock_guard</span></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div>    <span style="color:#4ec9b0">std</span>::mutex mu;<span style="color:#6a9955"> // Normal mutex</span></div><div>    <span style="color:#569cd6">int</span> gCounter = <span style="color:#b5cea8">0</span>;</div><br /><div>    <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">run</span>(<span style="color:#569cd6">const</span> <span style="color:#569cd6">char*</span> <span style="color:#9cdcfe">tid</span>, <span style="color:#569cd6">int</span> <span style="color:#9cdcfe">loopFor</span>) {</div><div><span style="color:#6a9955">        // mu.lock(); // mu.unlock() is MUST at the end</span></div><div>        <span style="color:#4ec9b0">std</span>::unique_lock&lt;<span style="color:#4ec9b0">mutex</span>&gt; <span style="color:#dcdcaa">lock</span>(<span style="color:#9cdcfe">mu</span>);<span style="color:#6a9955"> // NOT normal lock and unlock() is NOT needed</span></div><div>        <span style="color:#c586c0">for</span> (<span style="color:#569cd6">int</span> <span style="color:#9cdcfe">i</span> = <span style="color:#b5cea8">0</span>; <span style="color:#9cdcfe">i</span> &lt; loopFor; ++<span style="color:#9cdcfe">i</span>) {</div><div>            <span style="color:#9cdcfe">gCounter</span>++;</div><div>            cout &lt;&lt; tid &lt;&lt; <span style="color:#ce9178">" - "</span> &lt;&lt; <span style="color:#9cdcfe">gCounter</span> &lt;&lt; endl;</div><div>        }</div><div><span style="color:#6a9955">        // mu.unlock(); // MUST for noraml lock but NOT needed for both unique_lock and lock_guard</span></div><div>    }<span style="color:#6a9955"> // automatically mutex unlocked here by the destructor on the stack</span></div><br /><div>    <span style="color:#569cd6">int</span> <span style="color:#dcdcaa">main</span>() {</div><div>        thread t1{ run, <span style="color:#ce9178">"ThreadId: 1"</span>, <span style="color:#b5cea8">5</span> };</div><div>        thread t2{ run, <span style="color:#ce9178">"ThreadId: 2"</span>, <span style="color:#b5cea8">7</span> };</div><div>        <span style="color:#9cdcfe">t1</span>.<span style="color:#dcdcaa">join</span>();</div><div>        <span style="color:#9cdcfe">t2</span>.<span style="color:#dcdcaa">join</span>();</div><div>    }</div></div></div><div><span style="font-size:13.3333px">///////////////////////////////////////////////////////////////////////////////////////////////////</span></div><div><span style="font-size:13.3333px"><b>unique_lock</b> <b>with defer_lock option:</b></span></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div>    <span style="color:#4ec9b0">std</span>::mutex <span style="color:#9cdcfe">mu</span>;<span style="color:#6a9955"> // Normal mutex</span></div><div>    <span style="color:#569cd6">int</span> <span style="color:#9cdcfe">gCounter</span> = <span style="color:#b5cea8">0</span>;</div><br /><div>    <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">run</span>(<span style="color:#569cd6">const</span> <span style="color:#569cd6">char*</span> <span style="color:#9cdcfe">tid</span>, <span style="color:#569cd6">int</span> <span style="color:#9cdcfe">loopFor</span>) {</div><div><span style="color:#6a9955">        // mu.lock(); // mu.unlock() is MUST at the end</span></div><div>        <span style="color:#4ec9b0">std</span>::unique_lock&lt;<span style="color:#4ec9b0">mutex</span>&gt; <span style="color:#dcdcaa">uLock</span>(<span style="color:#9cdcfe">mu</span>, <span style="color:#4ec9b0">std</span>::defer_lock);<span style="color:#6a9955"> // lock created but NOT locked here bcos of defer option</span></div><div><span style="color:#6a9955">        // after some line of code/operation you start using the locking action by explicit lock() call</span></div><div>        <span style="color:#9cdcfe">uLock</span>.<span style="color:#dcdcaa">lock</span>();<span style="color:#6a9955"> // now it is locked after deferred some line of code</span></div><div>        <span style="color:#c586c0">for</span> (<span style="color:#569cd6">int</span> <span style="color:#9cdcfe">i</span> = <span style="color:#b5cea8">0</span>; <span style="color:#9cdcfe">i</span> &lt; <span style="color:#9cdcfe">loopFor</span>; ++<span style="color:#9cdcfe">i</span>) {</div><div>            <span style="color:#9cdcfe">gCounter</span>++;</div><div>            cout &lt;&lt; <span style="color:#9cdcfe">tid</span> &lt;&lt; <span style="color:#ce9178">" - "</span> &lt;&lt; <span style="color:#9cdcfe">gCounter</span> &lt;&lt; endl;</div><div>        }</div><div><span style="color:#6a9955">        // uLock.unlock(); // NOT need it will unlock automatically by the destructor</span></div><div><span style="color:#6a9955">        // mu.unlock();    // MUST for noraml lock but NOT needed for both unique_lock and lock_guard</span></div><div>    }<span style="color:#6a9955"> // automatically mutex unlocked here by the destructor on the stack</span></div><br /><div>    <span style="color:#569cd6">int</span> <span style="color:#dcdcaa">main</span>() {</div><div>        thread t1{ run, <span style="color:#ce9178">"ThreadId: 1"</span>, <span style="color:#b5cea8">5</span> };</div><div>        thread t2{ run, <span style="color:#ce9178">"ThreadId: 2"</span>, <span style="color:#b5cea8">7</span> };</div><div>        <span style="color:#9cdcfe">t1</span>.<span style="color:#dcdcaa">join</span>();</div><div>        <span style="color:#9cdcfe">t2</span>.<span style="color:#dcdcaa">join</span>();</div><div>    }</div></div></div><div><span style="font-size:13.3333px">///////////////////////////////////////////////////////////////////////////////////////////////////</span></div><div><span style="font-size:13.3333px"><b>Condition Variables(CV):</b> Useful for <b>synchronize 2 or more threads.</b> Best Application: Producer - Consumer problem.</span></div><div>Even you could write the Producer-Consumer solution ONLY using mutex but it will be very complex compare to CV solution.</div><div><span style="font-size:13.3333px">2 Purpose:</span></div><div><span style="font-size:13.3333px"><span style="white-space:pre"> </span>1. Notify other threads.</span></div><div><span style="font-size:13.3333px"><span style="white-space:pre"> </span>2. Waiting on some conditions.</span></div><div><span style="font-size:13.3333px">         CV---------&gt; T1 running</span></div><div><span style="font-size:13.3333px">          |---------&gt; T2, T3,....remaining threads waiting for notification</span></div><div><span style="font-size:13.3333px"><br /></span></div><div><span style="font-size:13.3333px">1. CV allows <b>ONE </b>thread to <b>'run'</b> and <b>remaining MULTIPLE threads</b> to <b>'wait'</b> on some conditions and once those conditions are met the waiting thread </span></div><div><span style="font-size:13.3333px">   is notified using:</span></div><div><span style="font-size:13.3333px"><span style="white-space:pre"> </span><b>a. notify_one()</b></span></div><div><span style="font-size:13.3333px"><b><span style="white-space:pre"> </span>b. notify_all()</b></span></div><div><span style="font-size:13.3333px">2. You need <b>mutex lock </b>to use <b>condition variables.</b></span></div><div><span style="font-size:13.3333px">3. If some thread want to wait on some condition then it has to do these things:</span></div><div><span style="font-size:13.3333px"><span style="white-space:pre"> </span>a. Acquire the mutex lock using std::unique_lock&lt;std::mutex&gt; lock(m);</span></div><div><span style="font-size:13.3333px"><span style="white-space:pre"> </span>b. Execute '<b>wait, wait_for, </b>or<b> wait_util'. </b>The wait operations <b>atomically release the mutex</b> and </span><span style="background-color:transparent">suspend the execution of the thread.</span></div><div><span style="font-size:13.3333px"><span style="white-space:pre"> </span>c. When the condition variable is notified, the thread is awakened, and the mutex is atomically reacquired.</span></div><div><span style="font-size:13.3333px"><span style="white-space:pre"> </span>   The thread should then check the condition and resume waiting if the wake up was spurious(got a wakeup call but still condition check give false).</span></div><div><br /></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div><span style="color:#6a9955">// common to both 'deposit' and 'withdraw' threads</span></div><div><span style="color:#4ec9b0">std</span>::condition_variable cv;</div><div><span style="color:#4ec9b0">std</span>::mutex <span style="color:#9cdcfe">mu</span>;</div><br /><div><span style="color:#569cd6">int</span> <span style="color:#9cdcfe">balance</span> = <span style="color:#b5cea8">0</span>;</div><br /><div><span style="color:#569cd6">void</span> <span style="color:#dcdcaa">deposit</span>(<span style="color:#569cd6">int</span> <span style="color:#9cdcfe">money</span>) {</div><div>    <span style="color:#4ec9b0">std</span>::lock_guard&lt;<span style="color:#4ec9b0">mutex</span>&gt; <span style="color:#dcdcaa">gLock</span>(<span style="color:#9cdcfe">mu</span>);<span style="color:#6a9955"> // no need for unique lock here bcos we are NOT using CV</span></div><div>    <span style="color:#9cdcfe">balance</span> += <span style="color:#9cdcfe">money</span>;</div><div>    cout &lt;&lt; <span style="color:#ce9178">"Balance after deposit: "</span> &lt;&lt; <span style="color:#9cdcfe">balance</span> &lt;&lt;endl;</div><div>    <span style="color:#9cdcfe">cv</span>.<span style="color:#dcdcaa">notify_one</span>();</div><div>}</div><br /><div><span style="color:#569cd6">void</span> <span style="color:#dcdcaa">withdraw</span>(<span style="color:#569cd6">int</span> <span style="color:#9cdcfe">money</span>) {</div><div>    <span style="color:#4ec9b0">std</span>::unique_lock&lt;<span style="color:#4ec9b0">mutex</span>&gt; <span style="color:#dcdcaa">uLock</span>(<span style="color:#9cdcfe">mu</span>);<span style="color:#6a9955"> // lock the mutex</span></div><div>    <span style="color:#9cdcfe">cv</span>.<span style="color:#dcdcaa">wait</span>(uLock, [] {<span style="color:#c586c0">return</span> <span style="color:#9cdcfe">balance</span> != <span style="color:#b5cea8">0</span> ? <span style="color:#569cd6">true</span> : <span style="color:#569cd6">false</span>; });<span style="color:#6a9955"> // false =&gt; unlock the prev.locked mutex and </span></div><div><span style="color:#6a9955">    // wait for the notify. </span><span style="color:rgb(106,153,85)">Once get the notify, then lock the mutex again and check the predicate and </span></div><div><span style="color:rgb(106,153,85)">    // do the same if it fails otherwise goto next line.</span></div><br /><div>    <span style="color:#c586c0">if</span> (<span style="color:#9cdcfe">balance</span> &gt;= <span style="color:#9cdcfe">money</span>) {                                   </div><div>        <span style="color:#9cdcfe">balance</span> -= <span style="color:#9cdcfe">money</span>;</div><div>        cout &lt;&lt; <span style="color:#ce9178">"Balance after withdraw: "</span> &lt;&lt; <span style="color:#9cdcfe">balance</span> &lt;&lt; endl;</div><div>    }</div><div>    <span style="color:#c586c0">else</span> cout &lt;&lt; <span style="color:#ce9178">"Balance is Less for withdrawal"</span>;</div><div>}</div><br /><div><span style="color:#569cd6">int</span> <span style="color:#dcdcaa">main</span>() {</div><div>    thread t1{ withdraw, <span style="color:#b5cea8">100</span> };</div><div>    <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">this_thread</span>::<span style="color:#dcdcaa">sleep_for</span>(<span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">chrono</span>::<span style="color:#4ec9b0">seconds</span>(<span style="color:#b5cea8">2</span>));</div><div>    thread t2{ deposit, <span style="color:#b5cea8">500</span> };</div><div>    <span style="color:#9cdcfe">t1</span>.<span style="color:#dcdcaa">join</span>();</div><div>    <span style="color:#9cdcfe">t2</span>.<span style="color:#dcdcaa">join</span>();</div><div>}</div></div></div><div><span style="font-size:13.3333px">///////////////////////////////////////////////////////////////////////////////////////////////////</span></div><div><span style="font-size:13.3333px"><b>Producer-Consumer Problem</b> (or) <b>Bounded Buffer Problem:</b></span></div><div><span style="font-size:13.3333px"><br /></span></div><div><span style="font-size:13.3333px"><b>Problem Statement:</b></span></div><div><span style="font-size:13.3333px"><span>    </span>1. Producer will produce and consumer will consume <b>with synchronization of a common buffer.</b></span></div><div><span style="font-size:13.3333px"><span>    </span>2. Until producer thread produces any data consumer thread can NOT consume.</span></div><div><span style="font-size:13.3333px"><span>    </span>3. Threads will use condition_variable to notify each other.</span></div><div><span style="font-size:13.3333px"><span>    </span>4. We need mutex lock if we use condition_variable because CV waits on the mutex.</span></div><div><span style="font-size:13.3333px"><span>    </span>5. This is one of the examples of producer/consumer there are many.</span></div><div><span style="font-size:13.3333px">///////////////////////////////////////////////////////////////////////////////////////////////////</span></div><div><span style="font-size:13.3333px"><b>Producer thread:</b></span></div><div><span style="font-size:13.3333px"><span>    </span>1. lock mutex, if success then goes ahead otherwise wait for mutex to get free.</span></div><div><span style="font-size:13.3333px"><span>    </span>2. check if the buffer is FULL then unlock the mutex and sleep, if not then go ahead and produce.</span></div><div><span style="font-size:13.3333px"><span>    </span>3. insert an item in the buffer.</span></div><div><span style="font-size:13.3333px"><span>    </span>4. unlock the mutex.</span></div><div><span style="font-size:13.3333px"><span>    </span>5. notify the consumer.</span></div><div><span style="font-size:13.3333px"><b><br /></b></span></div><div><span style="font-size:13.3333px"><b>Consumer thread:</b></span></div><div><span style="font-size:13.3333px"><span>    </span>1. lock mutex, if successful the go-ahead otherwise wait for mutex to get free.</span></div><div><span style="font-size:13.3333px"><span>    </span>2. check if the buffer is EMPTY and if it is, unlocks the mutex and sleep, if not then go ahead and consume.</span></div><div><span style="font-size:13.3333px"><span>    </span>3. consume item from the buffer.</span></div><div><span style="font-size:13.3333px"><span>    </span>4. unlock the mutex.</span></div><div><span style="font-size:13.3333px"><span>    </span>5. notify producer.</span></div><div><span style="font-size:13.3333px"><br /></span></div><div><span style="font-size:13.3333px"><b>Note:</b> Producer and Consumer have to <b>notify each other</b> upon completion of their job.</span></div><div><span style="font-size:13.3333px">///////////////////////////////////////////////////////////////////////////////////////////////////</span></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div><span style="color:#6a9955">    // Common for both threads</span></div><div>    mutex m;</div><div>    condition_variable not_empty;</div><div>    condition_variable not_full;</div><br /><div>    <span style="color:#569cd6">const</span> <span style="color:#569cd6">unsigned</span> <span style="color:#569cd6">int</span> BUFFER_SIZE = <span style="color:#b5cea8">5</span>;</div><div>    <span style="color:#569cd6">int</span> <span style="color:#9cdcfe">buf</span>[BUFFER_SIZE];</div><br /><br /><div>    <span style="color:#569cd6">unsigned</span> <span style="color:#569cd6">int</span> in = <span style="color:#b5cea8">0</span>, out = <span style="color:#b5cea8">0</span>, n = <span style="color:#b5cea8">0</span>, v = <span style="color:#b5cea8">0</span>;</div><br /><div>    <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">producer</span>()</div><div>    {</div><div>        <span style="color:#c586c0">while</span> (<span style="color:#569cd6">true</span>)</div><div>        {</div><div>            unique_lock&lt;mutex&gt; <span style="color:#dcdcaa">lock</span>(m);</div><div><span style="color:#6a9955">            // while (n == BUFFER_SIZE) not_full.wait(lock); // now full and wait until signals for NOT full</span></div><div>            <span style="color:#9cdcfe">not_full</span>.<span style="color:#dcdcaa">wait</span>(lock, []() { <span style="color:#c586c0">return</span> n != BUFFER_SIZE; });</div><br /><div>            <span style="color:#9cdcfe">buf</span>[in] = v++;</div><div>            n++;</div><div>            in = (in + <span style="color:#b5cea8">1</span>) % BUFFER_SIZE;</div><div>            cout &lt;&lt; <span style="color:#ce9178">"Wrote "</span> &lt;&lt; <span style="color:#9cdcfe">buf</span>[in] &lt;&lt; <span style="color:#ce9178">" (n="</span> &lt;&lt; n &lt;&lt; <span style="color:#ce9178">")"</span> &lt;&lt; endl;</div><br /><div>            <span style="color:#9cdcfe">lock</span>.<span style="color:#dcdcaa">unlock</span>();</div><div>            <span style="color:#9cdcfe">not_empty</span>.<span style="color:#dcdcaa">notify_all</span>();</div><div>            <span style="color:#4ec9b0">this_thread</span>::<span style="color:#dcdcaa">sleep_for</span>(<span style="color:#4ec9b0">chrono</span>::<span style="color:#dcdcaa">milliseconds</span>(<span style="color:#b5cea8">10</span>));</div><div>        }</div><div>    }</div><br /><div>    <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">consumer</span>()</div><div>    {</div><div>        <span style="color:#569cd6">int</span> data;</div><br /><div>        <span style="color:#c586c0">while</span> (<span style="color:#569cd6">true</span>)</div><div>        {</div><div>            unique_lock&lt;mutex&gt; <span style="color:#dcdcaa">lock</span>(m);</div><div><span style="color:#6a9955">            // while (n == 0)   not_empty.wait(lock); // Now empty and wait until signals for FULL</span></div><div>            <span style="color:#9cdcfe">not_empty</span>.<span style="color:#dcdcaa">wait</span>(lock, []() { <span style="color:#c586c0">return</span> n != <span style="color:#b5cea8">0</span>; });</div><br /><div>            data = <span style="color:#9cdcfe">buf</span>[out];</div><div>            n--;</div><div>            out = (out + <span style="color:#b5cea8">1</span>) % BUFFER_SIZE;</div><div>            cout &lt;&lt; <span style="color:#ce9178">"Read "</span> &lt;&lt; data &lt;&lt; <span style="color:#ce9178">" (n="</span> &lt;&lt; n &lt;&lt; <span style="color:#ce9178">")"</span> &lt;&lt; endl;</div><br /><div>            <span style="color:#9cdcfe">lock</span>.<span style="color:#dcdcaa">unlock</span>();</div><div>            <span style="color:#9cdcfe">not_full</span>.<span style="color:#dcdcaa">notify_all</span>();</div><div>            <span style="color:#4ec9b0">this_thread</span>::<span style="color:#dcdcaa">sleep_for</span>(<span style="color:#4ec9b0">chrono</span>::<span style="color:#dcdcaa">milliseconds</span>(<span style="color:#b5cea8">100</span>));</div><div>        }</div><div>    }</div><br /><div>    <span style="color:#569cd6">int</span> <span style="color:#dcdcaa">main</span>()</div><div>    {</div><div>        thread pt = <span style="color:#dcdcaa">thread</span>(producer);</div><div>        thread ct = <span style="color:#dcdcaa">thread</span>(consumer);</div><br /><div>        <span style="color:#9cdcfe">pt</span>.<span style="color:#dcdcaa">join</span>();</div><div>        <span style="color:#9cdcfe">ct</span>.<span style="color:#dcdcaa">join</span>();</div><div>    }</div></div></div><div><span style="background-color:transparent;font-size:10pt">///////////////////////////////////////////////////////////////////////////////////////////////////</span></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div style="line-height:22px"><div style="line-height:22px"><div><span style="color:#6a9955">    // Common to both producer thread &amp; consumer thread</span></div><div>    <span style="color:#4ec9b0">std</span>::mutex mu;<span style="color:#6a9955"> // common but 'pLock, cLock' for this mu must be unique for producer and consumer threads</span></div><div>    <span style="color:#4ec9b0">std</span>::condition_variable cond;</div><br /><div>    deque&lt;<span style="color:#569cd6">int</span>&gt; buff;</div><div>    <span style="color:#569cd6">const</span> <span style="color:#569cd6">unsigned</span> <span style="color:#569cd6">int</span> maxBuffSize = <span style="color:#b5cea8">3</span>;</div><div>    <span style="color:#569cd6">signed</span> <span style="color:#569cd6">int</span> dataRange = <span style="color:#b5cea8">10</span>;<span style="color:#6a9955"> // 0 to 9</span></div><br /><div>    <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">producer</span>() {</div><div>        <span style="color:#c586c0">while</span> (<span style="color:#569cd6">true</span>) {</div><div><span style="color:#6a9955">            // mu - acquired by the winner of race b/w prod &amp; consumer threads</span></div><div>            <span style="color:#4ec9b0">std</span>::unique_lock&lt;<span style="color:#4ec9b0">std</span>::mutex&gt; <span style="color:#dcdcaa">pLock</span>(mu);</div><div><span style="color:#6a9955">            // wait predicate true =&gt; go to next line else unlock the mutex and sleep</span></div><div>            <span style="color:#9cdcfe">cond</span>.<span style="color:#dcdcaa">wait</span>(pLock, []() { <span style="color:#c586c0">return</span> <span style="color:#9cdcfe">buff</span>.<span style="color:#dcdcaa">size</span>() &lt; maxBuffSize; }); </div><div>            <span style="color:#9cdcfe">buff</span>.<span style="color:#dcdcaa">push_back</span>(dataRange);</div><div>            cout &lt;&lt; <span style="color:#ce9178">"Produced: "</span> &lt;&lt; dataRange &lt;&lt; endl;</div><div>            --dataRange;</div><div>            <span style="color:#9cdcfe">pLock</span>.<span style="color:#dcdcaa">unlock</span>();</div><div>            <span style="color:#9cdcfe">cond</span>.<span style="color:#dcdcaa">notify_one</span>();<span style="color:#6a9955">     // notify only one thread which is waiting</span></div><br /><div>            <span style="color:#c586c0">if</span> (!dataRange) <span style="color:#c586c0">break</span>;<span style="color:#6a9955"> // exit condition</span></div><div>        }</div><div>    }</div><br /><div>    <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">consumer</span>() {</div><div>        <span style="color:#c586c0">while</span> (<span style="color:#569cd6">true</span>) {<span style="color:#6a9955"> // Note: true</span></div><div><span style="color:#6a9955">            // mu - acquired by the winner of race b/w producer &amp; consumer threads</span></div><div>            <span style="color:#4ec9b0">std</span>::unique_lock&lt;<span style="color:#4ec9b0">std</span>::mutex&gt; <span style="color:#dcdcaa">cLock</span>(mu); </div><div>            <span style="color:#9cdcfe">cond</span>.<span style="color:#dcdcaa">wait</span>(cLock, []() { <span style="color:#c586c0">return</span> <span style="color:#9cdcfe">buff</span>.<span style="color:#dcdcaa">size</span>() &gt; <span style="color:#b5cea8">0</span>; });</div><div>            <span style="color:#569cd6">int</span> val = <span style="color:#9cdcfe">buff</span>.<span style="color:#dcdcaa">back</span>();</div><div>            <span style="color:#9cdcfe">buff</span>.<span style="color:#dcdcaa">pop_back</span>();</div><div>            cout &lt;&lt; <span style="color:#ce9178">"Consumed: "</span> &lt;&lt; val &lt;&lt; endl;</div><div>            <span style="color:#9cdcfe">cLock</span>.<span style="color:#dcdcaa">unlock</span>();</div><div>            <span style="color:#9cdcfe">cond</span>.<span style="color:#dcdcaa">notify_one</span>();</div><br /><div>            <span style="color:#c586c0">if</span> (!dataRange) <span style="color:#c586c0">break</span>;<span style="color:#6a9955"> // exit condition</span></div><div>        }</div><div>    }</div><br /><div><span style="color:#6a9955">    /*</span></div><div><span style="color:#6a9955">    Produced : 10</span></div><div><span style="color:#6a9955">    Produced :  9</span></div><div><span style="color:#6a9955">    Produced :  8</span></div><div><span style="color:#6a9955">    Consumed :  8</span></div><div><span style="color:#6a9955">    Consumed :  9</span></div><div><span style="color:#6a9955">    Produced :  7</span></div><div><span style="color:#6a9955">    Produced :  6</span></div><div><span style="color:#6a9955">    Consumed :  6</span></div><br /><div><span style="color:#6a9955">    Note: produce/consume will work by varies size of data length (depends upon who wins the race in </span></div><div><span style="color:#6a9955">    acquiring the mutex). NOT work by one element by one element basis.</span></div><div><span style="color:#6a9955">    */</span></div><br /><div>    <span style="color:#569cd6">int</span> <span style="color:#dcdcaa">main</span>() {</div><div>        <span style="color:#4ec9b0">std</span>::thread <span style="color:#dcdcaa">t1</span>(producer);</div><div>        <span style="color:#4ec9b0">std</span>::thread <span style="color:#dcdcaa">t2</span>(consumer);</div><br /><div>        <span style="color:#9cdcfe">t1</span>.<span style="color:#dcdcaa">join</span>();</div><div>        <span style="color:#9cdcfe">t2</span>.<span style="color:#dcdcaa">join</span>();</div><div>    }</div></div></div></div></div><div><span style="font-size:13.3333px">///////////////////////////////////////////////////////////////////////////////////////////////////</span></div><div><span style="font-size:13.3333px">Note: </span><span style="background-color:transparent">In condition variable, both the </span><b style="background-color:transparent">"unlock-and-wait"</b><span style="background-color:transparent">, and </span><b style="background-color:transparent">"wakeUpAfterBeingNotified-and-lock",</b><span style="background-color:transparent"> are atomic operations.</span></div><div><span style="background-color:transparent"><br /></span></div><div><b>Good rule of thumb:</b> Avoid holding the lock associated with a condition variable while calling notify_one() or notify_all()</div><div><span style="background-color:transparent"><br /></span></div><div><div>The C++ standard says that condition_variable::wait() behaves like the following when called with a predicate (as in this case):</div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div style="line-height:22px"><div>    <span style="color:rgb(197,134,192)">while</span> (!<span style="color:rgb(220,220,170)">pred</span>())</div><div>        <span style="color:rgb(220,220,170)">wait</span>(lock);</div></div></div></div><div>///////////////////////////////////////////////////////////////////////////////////////////////////</div></div><div><b style="background-color:transparent">sleep:</b></div><div><span style="font-size:13.3333px"><span>    </span>1. CPU, pls do NOT give any task for at least 'n' milliseconds.</span></div><div><span style="font-size:13.3333px"><span>    </span>2. It <b>keeps </b>the <b>lock </b>and <b>sleep (BAD).</b></span></div><div><span style="font-size:13.3333px"><span>    </span>3. <b>sleep</b> is directly on the <b>thread </b>- it is a thread function</span></div><div><span style="font-size:13.3333px"><br /></span></div><div><span style="font-size:13.3333px"><b>wait:</b></span></div><div><span style="font-size:13.3333px"><span>    </span>1. CPU, pls do NOT give any task until someone noifty()/nofityall().</span></div><div><span style="font-size:13.3333px"><span>    </span>2. It <b>releases </b>the <b>lock and wait(Good).</b></span></div><div><span style="font-size:13.3333px"><span>    </span>3. <b>wait </b>is on the <b>condition variable.</b></span></div><div><span style="font-size:13.3333px"><br /></span></div><div><span style="font-size:13.3333px"><b>Example:</b> Candidates/Threads waiting for the interviewer room/critical section. Once the </span><span style="background-color:transparent">interviewer is ready to take the next candidate he will notify a call to the particular candidate </span><span style="background-color:transparent"><b>(or)</b> notify all the candidates and allow the entry <b>who comes first </b>and ask them remaining to go back to </span><span style="background-color:transparent">waiting for state.</span></div><div>///////////////////////////////////////////////////////////////////////////////////////////////////</div><div><div><span style="font-size:13.3333px"><b>std::shared_timed_mutex: </b></span><span style="background-color:transparent;font-size:10pt">Defined in a header file <b>&lt;shared_mutex&gt;: </b></span><span style="background-color:transparent;font-size:10pt">Shared mutexes are usually used in situations when <b>multiple readers </b>can access the same resource at the same time without causing data races, but <b>only one writer</b> can do so. </span><span style="background-color:transparent">In contrast to <b>other mutex </b>types which facilitate <b>exclusive </b>access, a shared_timed_mutex has two levels of access:</span></div><div><span style="font-size:13.3333px"><span>    </span>1. shared - several threads can share ownership of the same mutex.</span></div><div><span style="font-size:13.3333px"><span>    </span>2. exclusive - only one thread can own the mutex.</span></div><div><br /></div></div><div>///////////////////////////////////////////////////////////////////////////////////////////////////</div><div><b>Reader - Writer Problem:</b> Multiple reading threads but single Writing thread. </div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div><span style="color:#569cd6">    </span><span style="color:#c586c0">#include</span><span style="color:#569cd6"> </span><span style="color:#ce9178">&lt;shared_mutex&gt;</span></div><br /><div><span style="color:#6a9955">    // bookDB - Shared b/w readers and writers threads.</span></div><div><span style="color:#6a9955">    // ONLY one write thread allowed in CS at a time but any no of readers threads can be allowin CS</span></div><div>    <span style="color:#4ec9b0">std</span>::map&lt;<span style="color:#4ec9b0">std</span>::string, <span style="color:#4ec9b0">std</span>::string&gt; bookDB{ {<span style="color:#ce9178">"Dijkstra"</span>,<span style="color:#ce9178">"ShortestPath"</span>},{<span style="color:#ce9178">"Scott"</span>,<span style="color:#ce9178">"EffectiveC++"</span>},{<span style="color:#ce9178">"Ritchie"</span>,<span style="color:#ce9178">"C Pointers"</span>} };</div><br /><div>    <span style="color:#4ec9b0">std</span>::shared_timed_mutex stmu;<span style="color:#6a9955"> // added in C++14. std::shared_mutex added in C++17 </span></div><div><span style="color:#6a9955">    // for muliple read but single write.</span></div><br /><div>    <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">writer</span>(<span style="color:#569cd6">const</span> <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">string</span><span style="color:#569cd6">&amp;</span> <span style="color:#9cdcfe">name</span>, <span style="color:#569cd6">const</span> <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">string</span><span style="color:#569cd6">&amp;</span> <span style="color:#9cdcfe">title</span>) {</div><div><span style="color:#6a9955">        // ONLY one thread allowed in CS by lock_gurad</span></div><div>        <span style="color:#4ec9b0">std</span>::lock_guard&lt;<span style="color:#4ec9b0">std</span>::shared_timed_mutex&gt; <span style="color:#dcdcaa">writerLock</span>(stmu);</div><div>        <span style="color:#4ec9b0">std</span>::cout &lt;&lt; <span style="color:#ce9178">"</span><span style="color:#d7ba7d">\n</span><span style="color:#ce9178">STARTING UPDATE "</span> &lt;&lt; name;</div><div>        <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">this_thread</span>::<span style="color:#dcdcaa">sleep_for</span>(<span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">chrono</span>::<span style="color:#dcdcaa">milliseconds</span>(<span style="color:#b5cea8">500</span>));</div><div>        <span style="color:#9cdcfe">bookDB</span>[name] = title;</div><div>        <span style="color:#4ec9b0">std</span>::cout &lt;&lt; <span style="color:#ce9178">" ... ENDING UPDATE "</span> &lt;&lt; name &lt;&lt; <span style="color:#4ec9b0">std</span>::endl;</div><div>    }</div><br /><div>    <span style="color:#569cd6">void</span> <span style="color:#dcdcaa">reader</span>(<span style="color:#569cd6">const</span> <span style="color:#4ec9b0">std</span>::<span style="color:#4ec9b0">string</span><span style="color:#569cd6">&amp;</span> <span style="color:#9cdcfe">name</span>) {</div><div><span style="color:#6a9955">        // Any #of threads allowed in CS by shared_lock</span></div><div>        <span style="color:#4ec9b0">std</span>::shared_lock&lt;<span style="color:#4ec9b0">std</span>::shared_timed_mutex&gt; <span style="color:#dcdcaa">readerLock</span>(stmu);</div><div>        <span style="color:#4ec9b0">std</span>::cout &lt;&lt; name &lt;&lt; <span style="color:#ce9178">": "</span> &lt;&lt; <span style="color:#9cdcfe">bookDB</span>[name]&lt;&lt;endl;</div><div>    }</div><br /><div>    <span style="color:#569cd6">int</span> <span style="color:#dcdcaa">main</span>() {</div><br /><div>        <span style="color:#4ec9b0">std</span>::cout &lt;&lt; <span style="color:#4ec9b0">std</span>::endl;</div><br /><div>        <span style="color:#4ec9b0">std</span>::thread <span style="color:#dcdcaa">reader1</span>([] { <span style="color:#dcdcaa">reader</span>(<span style="color:#ce9178">"Scott"</span>); });</div><div>        <span style="color:#4ec9b0">std</span>::thread <span style="color:#dcdcaa">reader2</span>([] { <span style="color:#dcdcaa">reader</span>(<span style="color:#ce9178">"Ritchie"</span>); });</div><div>        <span style="color:#4ec9b0">std</span>::thread <span style="color:#dcdcaa">w1</span>([] { <span style="color:#dcdcaa">writer</span>(<span style="color:#ce9178">"Scott"</span>, <span style="color:#ce9178">"MoreEffective"</span>); });</div><div>        <span style="color:#4ec9b0">std</span>::thread <span style="color:#dcdcaa">reader3</span>([] { <span style="color:#dcdcaa">reader</span>(<span style="color:#ce9178">"Dijkstra"</span>); });</div><div>        <span style="color:#4ec9b0">std</span>::thread <span style="color:#dcdcaa">reader4</span>([] { <span style="color:#dcdcaa">reader</span>(<span style="color:#ce9178">"Scott"</span>); });</div><div>        <span style="color:#4ec9b0">std</span>::thread <span style="color:#dcdcaa">w2</span>([] { <span style="color:#dcdcaa">writer</span>(<span style="color:#ce9178">"Bjarne"</span>, <span style="color:#ce9178">"TourOfC++"</span>); });</div><div>        <span style="color:#4ec9b0">std</span>::thread <span style="color:#dcdcaa">reader5</span>([] { <span style="color:#dcdcaa">reader</span>(<span style="color:#ce9178">"Scott"</span>); });</div><div>        <span style="color:#4ec9b0">std</span>::thread <span style="color:#dcdcaa">reader6</span>([] { <span style="color:#dcdcaa">reader</span>(<span style="color:#ce9178">"Ritchie"</span>); });</div><div>        <span style="color:#4ec9b0">std</span>::thread <span style="color:#dcdcaa">reader7</span>([] { <span style="color:#dcdcaa">reader</span>(<span style="color:#ce9178">"Scott"</span>); });</div><div>        <span style="color:#4ec9b0">std</span>::thread <span style="color:#dcdcaa">reader8</span>([] { <span style="color:#dcdcaa">reader</span>(<span style="color:#ce9178">"Bjarne"</span>); });</div><br /><div>        <span style="color:#9cdcfe">reader1</span>.<span style="color:#dcdcaa">join</span>();</div><div>        <span style="color:#9cdcfe">reader2</span>.<span style="color:#dcdcaa">join</span>();</div><div>        <span style="color:#9cdcfe">reader3</span>.<span style="color:#dcdcaa">join</span>();</div><div>        <span style="color:#9cdcfe">reader4</span>.<span style="color:#dcdcaa">join</span>();</div><div>        <span style="color:#9cdcfe">reader5</span>.<span style="color:#dcdcaa">join</span>();</div><div>        <span style="color:#9cdcfe">reader6</span>.<span style="color:#dcdcaa">join</span>();</div><div>        <span style="color:#9cdcfe">reader7</span>.<span style="color:#dcdcaa">join</span>();</div><div>        <span style="color:#9cdcfe">reader8</span>.<span style="color:#dcdcaa">join</span>();</div><div>        <span style="color:#9cdcfe">w1</span>.<span style="color:#dcdcaa">join</span>();</div><div>        <span style="color:#9cdcfe">w2</span>.<span style="color:#dcdcaa">join</span>();</div><br /><div>        <span style="color:#4ec9b0">std</span>::cout &lt;&lt; <span style="color:#ce9178">"</span><span style="color:#d7ba7d">\n</span><span style="color:#ce9178">The new book database"</span> &lt;&lt; <span style="color:#4ec9b0">std</span>::endl;</div><div>        <span style="color:#c586c0">for</span> (<span style="color:#569cd6">auto</span> bk : bookDB) <span style="color:#4ec9b0">std</span>::cout &lt;&lt; <span style="color:#9cdcfe">bk</span>.<span style="color:#9cdcfe">first</span> &lt;&lt; <span style="color:#ce9178">": "</span> &lt;&lt; <span style="color:#9cdcfe">bk</span>.<span style="color:#9cdcfe">second</span> &lt;&lt; <span style="color:#4ec9b0">std</span>::endl;</div><div>    }</div></div></div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><div><div>///////////////////////////////////////////////////////////////////////////////////////////////////</div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><span style="color:rgb(78,201,176)">    std</span>::<span style="color:rgb(78,201,176)">this_thread</span>::<span style="color:rgb(220,220,170)">sleep_for</span>(<span style="color:rgb(78,201,176)">std</span>::<span style="color:rgb(78,201,176)">chrono</span>::<span style="color:rgb(220,220,170)">seconds</span>(<span style="color:rgb(181,206,168)">1</span>));</div></div><div><br /></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre"><div>    <span style="color:rgb(78,201,176)">std</span>::condition_variable <span style="color:rgb(156,220,254)">cv</span>;</div><div>    <span style="color:rgb(78,201,176)">std</span>::mutex <span style="color:rgb(156,220,254)">cv_m</span>;</div><div>    <span style="color:rgb(156,220,254)">std</span><span style="color:rgb(156,220,254)">::</span><span style="color:rgb(156,220,254)">unique</span><span style="color:rgb(78,201,176)">_lock</span>&lt;<span style="color:rgb(78,201,176)">std</span>::<span style="color:rgb(78,201,176)">mutex</span>&gt; <span style="color:rgb(220,220,170)">lk</span>(<span style="color:rgb(78,201,176)">cv_m</span>);</div><div>        <span style="color:rgb(156,220,254)">std</span><span style="color:rgb(156,220,254)">:</span>:cout &lt;&lt; <span style="color:rgb(206,145,120)">"Waiting... </span><span style="color:rgb(215,186,125)">\n</span><span style="color:rgb(206,145,120)">"</span>;</div><div>        <span style="color:rgb(156,220,254)">cv</span>.<span style="color:rgb(220,220,170)">wait</span>(lk, []{<span style="color:rgb(197,134,192)">return</span> i == <span style="color:rgb(181,206,168)">1</span>;});</div></div></div><div><br /></div><div>///////////////////////////////////////////////////////////////////////////////////////////////////</div></div><div><div><span style="font-size:13.3333px">How to run an <b>.exe</b> several times and sort the output using <b>bash shell </b>? </span></div><div><span style="font-size:13.3333px"><br /></span></div><div><span style="font-size:13.3333px">Let's use our bash shell to run it a few more times (assuming you compiled it to a.out):</span></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre">    $ <span style="color:#c586c0">for</span> i in {<span style="color:#f44747">1..40</span>}; <span style="color:#c586c0">do</span> ./<span style="color:#9cdcfe">a</span>.<span style="color:#9cdcfe">out</span>; done</div></div><div><span style="font-size:13.3333px"><br /></span></div><div><span style="font-size:13.3333px">Let's list all distinct outputs from 1000 separate runs, including the count for each output:</span></div><div><div style="color:rgb(212,212,212);background-color:rgb(30,30,30);font-family:Consolas,Courier New,monospace;font-size:16px;line-height:22px;white-space:pre">    $ <span style="color:#c586c0">for</span> i in {<span style="color:#f44747">1..1000</span>}; <span style="color:#c586c0">do</span> ./<span style="color:#9cdcfe">a</span>.<span style="color:#9cdcfe">out</span>; done | sort | uniq -c</div></div><div><br /></div></div><div><br /></div><div>///////////////////////////////////////////////////////////////////////////////////////////////////</div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><div><br /></div><div><span style="font-size:13.3333px"><br /></span></div><div><span style="font-size:13.3333px"><br /></span></div><div><br /></div><div><br /></div></div></td></tr></tbody></table><div class="sites-layout-tile sites-tile-name-footer sites-layout-empty-tile"><div dir="ltr"><br /></div></div></div>
</div> 
</div> 
<div id="sites-canvas-bottom-panel">
<div xmlns="http://www.w3.org/1999/xhtml" id="COMP_page-subpages"> </div>
<div id="sites-attachments-container">
</div>
<a xmlns="http://www.w3.org/1999/xhtml" name="page-comments"></a>
<div xmlns="http://www.w3.org/1999/xhtml" id="COMP_page-comments"><div class="sites-comment-docos-wrapper"><div class="sites-comment-docos"><div class="sites-comment-docos-background"></div><div class="sites-comment-docos-header"><div class="sites-comment-docos-header-title">Comments</div></div><div id="sites-comment-docos-pane" class="sites-comment-docos-pane"></div></div></div></div>
</div>
</div> 
</td> 
</tr>
</table> 
</div> 
</div> 
<div id="sites-chrome-footer-wrapper">
<div id="sites-chrome-footer-wrapper-inside">
<div id="sites-chrome-footer">
</div>
</div>
</div>
</div> 
</div> 
<div id="sites-chrome-adminfooter-container">
<div xmlns="http://www.w3.org/1999/xhtml" class="sites-adminfooter" role="navigation"><p><a class="sites-system-link" href="https://accounts.google.com/ServiceLogin?continue=https://sites.google.com/site/sridharkritha/handyconcepts/cppnuts/threads&amp;service=jotspot">Sign in</a><span aria-hidden="true">|</span><a class="sites-system-link" href="../../system/app/pages/recentChanges.html">Recent Site Activity</a><span aria-hidden="true">|</span><a class="sites-system-link" href="../../system/app/pages/reportAbuse.html" target="_blank">Report Abuse</a><span aria-hidden="true">|</span><a class="sites-system-link" href="javascript:;" onclick="window.open(webspace.printUrl)">Print Page</a><span aria-hidden="true">|</span><span class="sites-system-link">Powered By</span> <b class="powered-by"><a href="http://sites.google.com/site">Google Sites</a></b></p></div>
</div>
</div> 
</div> 
<script xmlns="http://www.w3.org/1999/xhtml" type="text/javascript">
    window.jstiming.load.tick('sjl');
  </script>
<script xmlns="http://www.w3.org/1999/xhtml" src="../../../../../ssl.gstatic.com/sites/p/a71eef/system/js/jot_min_view__en.js"></script>
<script xmlns="http://www.w3.org/1999/xhtml" type="text/javascript">
    window.jstiming.load.tick('jl');
  </script>
<script xmlns="http://www.w3.org/1999/xhtml" type="text/javascript">
      gsites.HoverPopupMenu.createSiteDropdownMenus('sites-header-nav-dropdown', false);
    </script>
<script xmlns="http://www.w3.org/1999/xhtml" type="text/javascript">
              new sites.CommentPane('//docs.google.com/comments/d/AAHRpnXtASf_M2E6cjJ9Hgufts3RfM7MwuhM--x9xhZTQT2CPH6b8hluqx2x1VgGjaIVLMzvk299QY5Ndgfxs0Hz0LJZAbDUGMqUkZdI46vuPyVD1HjMvJX2tF0yn5RjnMPxiMZ1hS15J/api/js?anon=true',
                  false, false);
            </script>
<script xmlns="http://www.w3.org/1999/xhtml" type="text/javascript">
  setTimeout(function() {
    var fingerprint = gsites.date.TimeZone.getFingerprint([1109635200000, 1128902400000, 1130657000000, 1143333000000, 1143806400000, 1145000000000, 1146380000000, 1152489600000, 1159800000000, 1159500000000, 1162095000000, 1162075000000, 1162105500000]);
    gsites.Xhr.send('../../_/tz.html', null, null, 'GET', null, null, { afjstz: fingerprint });
  }, 500);
</script>
<script xmlns="http://www.w3.org/1999/xhtml">
                    window.onload = function() {
                      if (false) {
                        JOT_setMobilePreview();
                      }
                      var loadTimer = window.jstiming.load;
                      loadTimer.tick("ol");
                      loadTimer["name"] = "load," + webspace.page.type + ",user_page";
                      window.jstiming.report(loadTimer, {}, '../../../../../gg.google.com/csi.gif');
                    }
                  </script>
<script xmlns="http://www.w3.org/1999/xhtml" type="text/javascript">
        JOT_insertAnalyticsCode(false,
            false);
      </script>
<script xmlns="http://www.w3.org/1999/xhtml" type="text/javascript">
    var maestroRunner = new gsites.pages.view.SitesMaestroRunner(
        webspace, "en");
    maestroRunner.initListeners();
    maestroRunner.installEditRender();
  </script>
<script xmlns="http://www.w3.org/1999/xhtml" type="text/javascript" defer="true">
  //<![CDATA[
    // Decorate any fastUI buttons on the page with a class of 'goog-button'.
    if (webspace.user.hasWriteAccess) {
      JOT_decorateButtons();
    }

    // Fires delayed events.
    (function() {
      JOT_fullyLoaded = true;
      var delayedEvents = JOT_delayedEvents;
      for (var x = 0; x < delayedEvents.length; x++) {
        var event = delayedEvents[x];
        JOT_postEvent(event.eventName, event.eventSrc, event.payload);
      }
      JOT_delayedEvents = null;
      JOT_postEvent('pageLoaded');
    })();
  //]]>
</script>
<script xmlns="http://www.w3.org/1999/xhtml" type="text/javascript">
    JOT_postEvent('decorateGvizCharts');
  </script>
<script type="text/javascript">
          JOT_setupPostRenderingManager();
        </script>
<script type="text/javascript">
          JOT_postEvent('renderPlus', null, 'sites-chrome-main');
        </script>
<script type="text/javascript">
          sites.codeembed.init();
        </script>
<div id="server-timer-div" style="display:none"> </div>
<script type="text/javascript">
          window.jstiming.load.tick('render');
          JOT_postEvent('usercontentrendered', this);
        </script>
</body>

<!-- Mirrored from sites.google.com/site/sridharkritha/handyconcepts/cppnuts/threads by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 09 Jul 2021 10:31:35 GMT -->
</html>
